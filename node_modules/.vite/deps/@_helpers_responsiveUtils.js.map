{
  "version": 3,
  "sources": ["../../../src/helpers/responsiveUtils.ts"],
  "sourcesContent": ["import {cloneLayout, compact, correctBounds} from \"./utils\"\n\nimport type {Layout} from \"./utils\"\nexport type ResponsiveLayout = {lg?: Layout; md?: Layout; sm?: Layout; xs?: Layout; xxs?: Layout}\nexport type Breakpoint = string\nexport type Breakpoints = {lg?: number; md?: number; sm?: number; xs?: number; xxs?: number}\n\n/**\n * Given a width, find the highest breakpoint that matches is valid for it (width > breakpoint).\n *\n * @param  {Object} breakpoints Breakpoints object (e.g. {lg: 1200, md: 960, ...})\n * @param  {Number} width Screen width.\n * @return {String}       Highest breakpoint that is less than width.\n */\nexport function getBreakpointFromWidth(breakpoints: Breakpoints, width: number): Breakpoint {\n  const sorted = sortBreakpoints(breakpoints)\n  let matching = sorted[0]\n  for (let i = 1, len = sorted.length; i < len; i++) {\n    const breakpointName = sorted[i]\n    if (width > breakpoints[breakpointName]) matching = breakpointName\n  }\n  return matching\n}\n\n/**\n * Given a breakpoint, get the # of cols set for it.\n * @param  {String} breakpoint Breakpoint name.\n * @param  {Object} cols       Map of breakpoints to cols.\n * @return {Number}            Number of cols.\n */\nexport function getColsFromBreakpoint(breakpoint: Breakpoint, cols: Breakpoints): number {\n  if (!cols[breakpoint]) {\n    throw new Error(\n      \"ResponsiveGridLayout: `cols` entry for breakpoint \" + breakpoint + \" is missing!\"\n    )\n  }\n  return cols[breakpoint]\n}\n\n/**\n * Given existing layouts and a new breakpoint, find or generate a new layout.\n *\n * This finds the layout above the new one and generates from it, if it exists.\n *\n * @param  {Array} orgLayout     Original layout.\n * @param  {Object} layouts     Existing layouts.\n * @param  {Array} breakpoints All breakpoints.\n * @param  {String} breakpoint New breakpoint.\n * @param  {String} breakpoint Last breakpoint (for fallback).\n * @param  {Number} cols       Column count at new breakpoint.\n * @param  {Boolean} verticalCompact Whether or not to compact the layout\n *   vertically.\n * @return {Array}             New layout.\n */\nexport function findOrGenerateResponsiveLayout(\n  orgLayout: Layout,\n  layouts: ResponsiveLayout,\n  breakpoints: Breakpoints,\n  breakpoint: Breakpoint,\n  lastBreakpoint: Breakpoint,\n  cols: number,\n  verticalCompact: boolean\n): Layout {\n  // If it already exists, just return it.\n  if (layouts[breakpoint]) return cloneLayout(layouts[breakpoint])\n  // Find or generate the next layout\n  let layout = orgLayout\n\n  const breakpointsSorted = sortBreakpoints(breakpoints)\n  const breakpointsAbove = breakpointsSorted.slice(breakpointsSorted.indexOf(breakpoint))\n  for (let i = 0, len = breakpointsAbove.length; i < len; i++) {\n    const b = breakpointsAbove[i]\n    if (layouts[b]) {\n      layout = layouts[b]\n      break\n    }\n  }\n  layout = cloneLayout(layout || []) // clone layout so we don't modify existing items\n  return compact(correctBounds(layout, {cols: cols}), verticalCompact)\n}\n\nexport function generateResponsiveLayout(\n  layout: Layout,\n  breakpoints: Breakpoints,\n  breakpoint: Breakpoint,\n  lastBreakpoint: Breakpoint,\n  cols: number,\n  verticalCompact: boolean\n): Layout {\n  // If it already exists, just return it.\n  /*if (layouts[breakpoint]) return cloneLayout(layouts[breakpoint]);\n  // Find or generate the next layout\n  let layout = layouts[lastBreakpoint];*/\n  /*const breakpointsSorted = sortBreakpoints(breakpoints);\n  const breakpointsAbove = breakpointsSorted.slice(breakpointsSorted.indexOf(breakpoint));\n  for (let i = 0, len = breakpointsAbove.length; i < len; i++) {\n    const b = breakpointsAbove[i];\n    if (layouts[b]) {\n      layout = layouts[b];\n      break;\n    }\n  }*/\n  layout = cloneLayout(layout || []) // clone layout so we don't modify existing items\n  return compact(correctBounds(layout, {cols: cols}), verticalCompact)\n}\n\n/**\n * Given breakpoints, return an array of breakpoints sorted by width. This is usually\n * e.g. ['xxs', 'xs', 'sm', ...]\n *\n * @param  {Object} breakpoints Key/value pair of breakpoint names to widths.\n * @return {Array}              Sorted breakpoints.\n */\nexport function sortBreakpoints(breakpoints: Breakpoints): Array<Breakpoint> {\n  const keys: Array<string> = Object.keys(breakpoints)\n  return keys.sort(function (a, b) {\n    return breakpoints[a] - breakpoints[b]\n  })\n}\n"],
  "mappings": ";;;;;;;AAcO,SAAS,uBAAuB,aAA0B,OAA2B;AAC1F,QAAM,SAAS,gBAAgB,WAAW;AAC1C,MAAI,WAAW,OAAO;AACtB,WAAS,IAAI,GAAG,MAAM,OAAO,QAAQ,IAAI,KAAK,KAAK;AACjD,UAAM,iBAAiB,OAAO;AAC9B,QAAI,QAAQ,YAAY;AAAiB,iBAAW;AAAA,EACtD;AACA,SAAO;AACT;AAQO,SAAS,sBAAsB,YAAwB,MAA2B;AACvF,MAAI,CAAC,KAAK,aAAa;AACrB,UAAM,IAAI;AAAA,MACR,uDAAuD,aAAa;AAAA,IACtE;AAAA,EACF;AACA,SAAO,KAAK;AACd;AAiBO,SAAS,+BACd,WACA,SACA,aACA,YACA,gBACA,MACA,iBACQ;AAER,MAAI,QAAQ;AAAa,WAAO,YAAY,QAAQ,WAAW;AAE/D,MAAI,SAAS;AAEb,QAAM,oBAAoB,gBAAgB,WAAW;AACrD,QAAM,mBAAmB,kBAAkB,MAAM,kBAAkB,QAAQ,UAAU,CAAC;AACtF,WAAS,IAAI,GAAG,MAAM,iBAAiB,QAAQ,IAAI,KAAK,KAAK;AAC3D,UAAM,IAAI,iBAAiB;AAC3B,QAAI,QAAQ,IAAI;AACd,eAAS,QAAQ;AACjB;AAAA,IACF;AAAA,EACF;AACA,WAAS,YAAY,UAAU,CAAC,CAAC;AACjC,SAAO,QAAQ,cAAc,QAAQ,EAAC,KAAU,CAAC,GAAG,eAAe;AACrE;AAEO,SAAS,yBACd,QACA,aACA,YACA,gBACA,MACA,iBACQ;AAcR,WAAS,YAAY,UAAU,CAAC,CAAC;AACjC,SAAO,QAAQ,cAAc,QAAQ,EAAC,KAAU,CAAC,GAAG,eAAe;AACrE;AASO,SAAS,gBAAgB,aAA6C;AAC3E,QAAM,OAAsB,OAAO,KAAK,WAAW;AACnD,SAAO,KAAK,KAAK,SAAU,GAAG,GAAG;AAC/B,WAAO,YAAY,KAAK,YAAY;AAAA,EACtC,CAAC;AACH;",
  "names": []
}
