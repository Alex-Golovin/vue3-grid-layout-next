{
  "version": 3,
  "sources": ["../../.pnpm/@interactjs+auto-start@1.10.27_@interactjs+core@1.10.27_@interactjs+utils@1.10.27__@interactjs+utils@1.10.27/node_modules/@interactjs/auto-start/InteractableMethods.ts", "../../.pnpm/@interactjs+auto-start@1.10.27_@interactjs+core@1.10.27_@interactjs+utils@1.10.27__@interactjs+utils@1.10.27/node_modules/@interactjs/auto-start/base.ts", "../../.pnpm/@interactjs+auto-start@1.10.27_@interactjs+core@1.10.27_@interactjs+utils@1.10.27__@interactjs+utils@1.10.27/node_modules/@interactjs/auto-start/dragAxis.ts", "../../.pnpm/@interactjs+auto-start@1.10.27_@interactjs+core@1.10.27_@interactjs+utils@1.10.27__@interactjs+utils@1.10.27/node_modules/@interactjs/auto-start/hold.ts", "../../.pnpm/@interactjs+auto-start@1.10.27_@interactjs+core@1.10.27_@interactjs+utils@1.10.27__@interactjs+utils@1.10.27/node_modules/@interactjs/auto-start/plugin.ts", "../../.pnpm/@interactjs+auto-start@1.10.27_@interactjs+core@1.10.27_@interactjs+utils@1.10.27__@interactjs+utils@1.10.27/node_modules/@interactjs/auto-start/index.ts"],
  "sourcesContent": ["import type { Interactable } from '@interactjs/core/Interactable'\nimport type { Interaction } from '@interactjs/core/Interaction'\nimport type { Scope } from '@interactjs/core/scope'\nimport type { ActionProps, PointerType, PointerEventType, Element } from '@interactjs/core/types'\nimport is from '@interactjs/utils/is'\nimport { warnOnce } from '@interactjs/utils/misc'\n\ndeclare module '@interactjs/core/Interactable' {\n  interface Interactable {\n    getAction: (\n      this: Interactable,\n      pointer: PointerType,\n      event: PointerEventType,\n      interaction: Interaction,\n      element: Element,\n    ) => ActionProps | null\n    styleCursor(newValue: boolean): this\n    styleCursor(): boolean\n    /**\n     * Returns or sets whether the the cursor should be changed depending on the\n     * action that would be performed if the mouse were pressed and dragged.\n     *\n     * @param {boolean} [newValue]\n     * @return {boolean | Interactable} The current setting or this Interactable\n     */\n    styleCursor(newValue?: boolean): boolean | this\n    actionChecker(checker: Function): Interactable\n    actionChecker(): Function\n    /**\n     * ```js\n     * interact('.resize-drag')\n     *   .resizable(true)\n     *   .draggable(true)\n     *   .actionChecker(function (pointer, event, action, interactable, element, interaction) {\n     *\n     *     if (interact.matchesSelector(event.target, '.drag-handle')) {\n     *       // force drag with handle target\n     *       action.name = drag\n     *     }\n     *     else {\n     *       // resize from the top and right edges\n     *       action.name  = 'resize'\n     *       action.edges = { top: true, right: true }\n     *     }\n     *\n     *     return action\n     * })\n     * ```\n     *\n     * Returns or sets the function used to check action to be performed on\n     * pointerDown\n     *\n     * @param checker - A function which takes a pointer event,\n     * defaultAction string, interactable, element and interaction as parameters\n     * and returns an object with name property 'drag' 'resize' or 'gesture' and\n     * optionally an `edges` object with boolean 'top', 'left', 'bottom' and right\n     * props.\n     * @returns The checker function or this Interactable\n     */\n    actionChecker(checker?: Function): Interactable | Function\n    /** @returns This interactable */\n    ignoreFrom(newValue: string | Element | null): Interactable\n    /** @returns The current ignoreFrom value */\n    ignoreFrom(): string | Element | null\n    /**\n     * If the target of the `mousedown`, `pointerdown` or `touchstart` event or any\n     * of it's parents match the given CSS selector or Element, no\n     * drag/resize/gesture is started.\n     *\n     * @deprecated\n     * Don't use this method. Instead set the `ignoreFrom` option for each action\n     * or for `pointerEvents`\n     *\n     * ```js\n     * interact(targett)\n     *   .draggable({\n     *     ignoreFrom: 'input, textarea, a[href]'',\n     *   })\n     *   .pointerEvents({\n     *     ignoreFrom: '[no-pointer]',\n     *   })\n     * ```\n     * Interactable\n     */\n    ignoreFrom(\n      /** a CSS selector string, an Element or `null` to not ignore any elements */\n      newValue?: string | Element | null,\n    ): Interactable | string | Element | null\n    allowFrom(): boolean\n    /**\n     *\n     * A drag/resize/gesture is started only If the target of the `mousedown`,\n     * `pointerdown` or `touchstart` event or any of it's parents match the given\n     * CSS selector or Element.\n     *\n     * @deprecated\n     * Don't use this method. Instead set the `allowFrom` option for each action\n     * or for `pointerEvents`\n     *\n     * ```js\n     * interact(targett)\n     *   .resizable({\n     *     allowFrom: '.resize-handle',\n     *   .pointerEvents({\n     *     allowFrom: '.handle',,\n     *   })\n     * ```\n     *\n     * @param {string | Element | null} [newValue]\n     * @return {string | Element | object} The current allowFrom value or this\n     * Interactable\n     */\n    allowFrom(\n      /** A CSS selector string, an Element or `null` to allow from any element */\n      newValue: string | Element | null,\n    ): Interactable\n  }\n}\n\nfunction install(scope: Scope) {\n  const {\n    Interactable, // tslint:disable-line no-shadowed-variable\n  } = scope\n\n  Interactable.prototype.getAction = function getAction(\n    this: Interactable,\n    pointer: PointerType,\n    event: PointerEventType,\n    interaction: Interaction,\n    element: Element,\n  ): ActionProps {\n    const action = defaultActionChecker(this, event, interaction, element, scope)\n\n    if (this.options.actionChecker) {\n      return this.options.actionChecker(pointer, event, action, this, element, interaction)\n    }\n\n    return action\n  }\n\n  Interactable.prototype.ignoreFrom = warnOnce(function (this: Interactable, newValue) {\n    return this._backCompatOption('ignoreFrom', newValue)\n  }, 'Interactable.ignoreFrom() has been deprecated. Use Interactble.draggable({ignoreFrom: newValue}).')\n\n  Interactable.prototype.allowFrom = warnOnce(function (this: Interactable, newValue) {\n    return this._backCompatOption('allowFrom', newValue)\n  }, 'Interactable.allowFrom() has been deprecated. Use Interactble.draggable({allowFrom: newValue}).')\n\n  Interactable.prototype.actionChecker = actionChecker\n\n  Interactable.prototype.styleCursor = styleCursor\n}\n\nfunction defaultActionChecker(\n  interactable: Interactable,\n  event: PointerEventType,\n  interaction: Interaction,\n  element: Element,\n  scope: Scope,\n) {\n  const rect = interactable.getRect(element)\n  const buttons =\n    (event as MouseEvent).buttons ||\n    {\n      0: 1,\n      1: 4,\n      3: 8,\n      4: 16,\n    }[(event as MouseEvent).button as 0 | 1 | 3 | 4]\n  const arg = {\n    action: null,\n    interactable,\n    interaction,\n    element,\n    rect,\n    buttons,\n  }\n\n  scope.fire('auto-start:check', arg)\n\n  return arg.action\n}\n\nfunction styleCursor(this: Interactable, newValue?: boolean) {\n  if (is.bool(newValue)) {\n    this.options.styleCursor = newValue\n\n    return this\n  }\n\n  if (newValue === null) {\n    delete this.options.styleCursor\n\n    return this\n  }\n\n  return this.options.styleCursor\n}\n\nfunction actionChecker(this: Interactable, checker?: any) {\n  if (is.func(checker)) {\n    this.options.actionChecker = checker\n\n    return this\n  }\n\n  if (checker === null) {\n    delete this.options.actionChecker\n\n    return this\n  }\n\n  return this.options.actionChecker\n}\n\nexport default {\n  id: 'auto-start/interactableMethods',\n  install,\n}\n", "import type { Interactable } from '@interactjs/core/Interactable'\nimport type { Interaction } from '@interactjs/core/Interaction'\nimport type { Scope, SignalArgs, Plugin } from '@interactjs/core/scope'\nimport type {\n  CursorChecker,\n  PointerType,\n  PointerEventType,\n  Element,\n  ActionName,\n  ActionProps,\n} from '@interactjs/core/types'\nimport * as domUtils from '@interactjs/utils/domUtils'\nimport extend from '@interactjs/utils/extend'\nimport is from '@interactjs/utils/is'\nimport { copyAction } from '@interactjs/utils/misc'\n\n/* eslint-disable import/no-duplicates -- for typescript module augmentations */\nimport './InteractableMethods'\nimport InteractableMethods from './InteractableMethods'\n/* eslint-enable import/no-duplicates */\n\ndeclare module '@interactjs/core/InteractStatic' {\n  export interface InteractStatic {\n    /**\n     * Returns or sets the maximum number of concurrent interactions allowed.  By\n     * default only 1 interaction is allowed at a time (for backwards\n     * compatibility). To allow multiple interactions on the same Interactables and\n     * elements, you need to enable it in the draggable, resizable and gesturable\n     * `'max'` and `'maxPerElement'` options.\n     *\n     * @param {number} [newValue] Any number. newValue <= 0 means no interactions.\n     */\n    maxInteractions: (newValue: any) => any\n  }\n}\n\ndeclare module '@interactjs/core/scope' {\n  interface Scope {\n    autoStart: AutoStart\n  }\n\n  interface SignalArgs {\n    'autoStart:before-start': Omit<SignalArgs['interactions:move'], 'interaction'> & {\n      interaction: Interaction<ActionName>\n    }\n    'autoStart:prepared': { interaction: Interaction }\n    'auto-start:check': CheckSignalArg\n  }\n}\n\ndeclare module '@interactjs/core/options' {\n  interface BaseDefaults {\n    actionChecker?: any\n    cursorChecker?: any\n    styleCursor?: any\n  }\n\n  interface PerActionDefaults {\n    manualStart?: boolean\n    max?: number\n    maxPerElement?: number\n    allowFrom?: string | Element\n    ignoreFrom?: string | Element\n    cursorChecker?: CursorChecker\n\n    // only allow left button by default\n    // see https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/buttons#Return_value\n    // TODO: docst\n    mouseButtons?: 0 | 1 | 2 | 4 | 8 | 16\n  }\n}\n\ninterface CheckSignalArg {\n  interactable: Interactable\n  interaction: Interaction\n  element: Element\n  action: ActionProps<ActionName>\n  buttons: number\n}\n\nexport interface AutoStart {\n  // Allow this many interactions to happen simultaneously\n  maxInteractions: number\n  withinInteractionLimit: typeof withinInteractionLimit\n  cursorElement: Element\n}\n\nfunction install(scope: Scope) {\n  const { interactStatic: interact, defaults } = scope\n\n  scope.usePlugin(InteractableMethods)\n\n  defaults.base.actionChecker = null\n  defaults.base.styleCursor = true\n\n  extend(defaults.perAction, {\n    manualStart: false,\n    max: Infinity,\n    maxPerElement: 1,\n    allowFrom: null,\n    ignoreFrom: null,\n\n    // only allow left button by default\n    // see https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/buttons#Return_value\n    mouseButtons: 1,\n  })\n\n  interact.maxInteractions = (newValue: number) => maxInteractions(newValue, scope)\n\n  scope.autoStart = {\n    // Allow this many interactions to happen simultaneously\n    maxInteractions: Infinity,\n    withinInteractionLimit,\n    cursorElement: null,\n  }\n}\n\nfunction prepareOnDown(\n  { interaction, pointer, event, eventTarget }: SignalArgs['interactions:down'],\n  scope: Scope,\n) {\n  if (interaction.interacting()) return\n\n  const actionInfo = getActionInfo(interaction, pointer, event, eventTarget, scope)\n  prepare(interaction, actionInfo, scope)\n}\n\nfunction prepareOnMove(\n  { interaction, pointer, event, eventTarget }: SignalArgs['interactions:move'],\n  scope: Scope,\n) {\n  if (interaction.pointerType !== 'mouse' || interaction.pointerIsDown || interaction.interacting()) return\n\n  const actionInfo = getActionInfo(interaction, pointer, event, eventTarget as Element, scope)\n  prepare(interaction, actionInfo, scope)\n}\n\nfunction startOnMove(arg: SignalArgs['interactions:move'], scope: Scope) {\n  const { interaction } = arg\n\n  if (\n    !interaction.pointerIsDown ||\n    interaction.interacting() ||\n    !interaction.pointerWasMoved ||\n    !interaction.prepared.name\n  ) {\n    return\n  }\n\n  scope.fire('autoStart:before-start', arg)\n\n  const { interactable } = interaction\n  const actionName = (interaction as Interaction<ActionName>).prepared.name\n\n  if (actionName && interactable) {\n    // check manualStart and interaction limit\n    if (\n      interactable.options[actionName].manualStart ||\n      !withinInteractionLimit(interactable, interaction.element, interaction.prepared, scope)\n    ) {\n      interaction.stop()\n    } else {\n      interaction.start(interaction.prepared, interactable, interaction.element)\n      setInteractionCursor(interaction, scope)\n    }\n  }\n}\n\nfunction clearCursorOnStop({ interaction }: { interaction: Interaction }, scope: Scope) {\n  const { interactable } = interaction\n\n  if (interactable && interactable.options.styleCursor) {\n    setCursor(interaction.element, '', scope)\n  }\n}\n\n// Check if the current interactable supports the action.\n// If so, return the validated action. Otherwise, return null\nfunction validateAction<T extends ActionName>(\n  action: ActionProps<T>,\n  interactable: Interactable,\n  element: Element,\n  eventTarget: Node,\n  scope: Scope,\n) {\n  if (\n    interactable.testIgnoreAllow(interactable.options[action.name], element, eventTarget) &&\n    interactable.options[action.name].enabled &&\n    withinInteractionLimit(interactable, element, action, scope)\n  ) {\n    return action\n  }\n\n  return null\n}\n\nfunction validateMatches(\n  interaction: Interaction,\n  pointer: PointerType,\n  event: PointerEventType,\n  matches: Interactable[],\n  matchElements: Element[],\n  eventTarget: Node,\n  scope: Scope,\n) {\n  for (let i = 0, len = matches.length; i < len; i++) {\n    const match = matches[i]\n    const matchElement = matchElements[i]\n    const matchAction = match.getAction(pointer, event, interaction, matchElement)\n\n    if (!matchAction) {\n      continue\n    }\n\n    const action = validateAction<ActionName>(matchAction, match, matchElement, eventTarget, scope)\n\n    if (action) {\n      return {\n        action,\n        interactable: match,\n        element: matchElement,\n      }\n    }\n  }\n\n  return { action: null, interactable: null, element: null }\n}\n\nfunction getActionInfo(\n  interaction: Interaction,\n  pointer: PointerType,\n  event: PointerEventType,\n  eventTarget: Node,\n  scope: Scope,\n) {\n  let matches: Interactable[] = []\n  let matchElements: Element[] = []\n\n  let element = eventTarget as Element\n\n  function pushMatches(interactable: Interactable) {\n    matches.push(interactable)\n    matchElements.push(element)\n  }\n\n  while (is.element(element)) {\n    matches = []\n    matchElements = []\n\n    scope.interactables.forEachMatch(element, pushMatches)\n\n    const actionInfo = validateMatches(\n      interaction,\n      pointer,\n      event,\n      matches,\n      matchElements,\n      eventTarget,\n      scope,\n    )\n\n    if (actionInfo.action && !actionInfo.interactable.options[actionInfo.action.name].manualStart) {\n      return actionInfo\n    }\n\n    element = domUtils.parentNode(element) as Element\n  }\n\n  return { action: null, interactable: null, element: null }\n}\n\nfunction prepare(\n  interaction: Interaction,\n  {\n    action,\n    interactable,\n    element,\n  }: {\n    action: ActionProps<any>\n    interactable: Interactable\n    element: Element\n  },\n  scope: Scope,\n) {\n  action = action || { name: null }\n\n  interaction.interactable = interactable\n  interaction.element = element\n  copyAction(interaction.prepared, action)\n\n  interaction.rect = interactable && action.name ? interactable.getRect(element) : null\n\n  setInteractionCursor(interaction, scope)\n\n  scope.fire('autoStart:prepared', { interaction })\n}\n\nfunction withinInteractionLimit<T extends ActionName>(\n  interactable: Interactable,\n  element: Element,\n  action: ActionProps<T>,\n  scope: Scope,\n) {\n  const options = interactable.options\n  const maxActions = options[action.name].max\n  const maxPerElement = options[action.name].maxPerElement\n  const autoStartMax = scope.autoStart.maxInteractions\n  let activeInteractions = 0\n  let interactableCount = 0\n  let elementCount = 0\n\n  // no actions if any of these values == 0\n  if (!(maxActions && maxPerElement && autoStartMax)) {\n    return false\n  }\n\n  for (const interaction of scope.interactions.list) {\n    const otherAction = interaction.prepared.name\n\n    if (!interaction.interacting()) {\n      continue\n    }\n\n    activeInteractions++\n\n    if (activeInteractions >= autoStartMax) {\n      return false\n    }\n\n    if (interaction.interactable !== interactable) {\n      continue\n    }\n\n    interactableCount += otherAction === action.name ? 1 : 0\n\n    if (interactableCount >= maxActions) {\n      return false\n    }\n\n    if (interaction.element === element) {\n      elementCount++\n\n      if (otherAction === action.name && elementCount >= maxPerElement) {\n        return false\n      }\n    }\n  }\n\n  return autoStartMax > 0\n}\n\nfunction maxInteractions(newValue: any, scope: Scope) {\n  if (is.number(newValue)) {\n    scope.autoStart.maxInteractions = newValue\n\n    return this\n  }\n\n  return scope.autoStart.maxInteractions\n}\n\nfunction setCursor(element: Element, cursor: string, scope: Scope) {\n  const { cursorElement: prevCursorElement } = scope.autoStart\n\n  if (prevCursorElement && prevCursorElement !== element) {\n    prevCursorElement.style.cursor = ''\n  }\n\n  element.ownerDocument.documentElement.style.cursor = cursor\n  element.style.cursor = cursor\n  scope.autoStart.cursorElement = cursor ? element : null\n}\n\nfunction setInteractionCursor<T extends ActionName>(interaction: Interaction<T>, scope: Scope) {\n  const { interactable, element, prepared } = interaction\n\n  if (!(interaction.pointerType === 'mouse' && interactable && interactable.options.styleCursor)) {\n    // clear previous target element cursor\n    if (scope.autoStart.cursorElement) {\n      setCursor(scope.autoStart.cursorElement, '', scope)\n    }\n\n    return\n  }\n\n  let cursor = ''\n\n  if (prepared.name) {\n    const cursorChecker = interactable.options[prepared.name].cursorChecker\n\n    if (is.func(cursorChecker)) {\n      cursor = cursorChecker(prepared, interactable, element, interaction._interacting)\n    } else {\n      cursor = scope.actions.map[prepared.name].getCursor(prepared)\n    }\n  }\n\n  setCursor(interaction.element, cursor || '', scope)\n}\n\nconst autoStart: Plugin = {\n  id: 'auto-start/base',\n  before: ['actions'],\n  install,\n  listeners: {\n    'interactions:down': prepareOnDown,\n    'interactions:move': (arg, scope) => {\n      prepareOnMove(arg, scope)\n      startOnMove(arg, scope)\n    },\n    'interactions:stop': clearCursorOnStop,\n  },\n  maxInteractions,\n  withinInteractionLimit,\n  validateAction,\n}\n\nexport default autoStart\n", "import type { Interactable } from '@interactjs/core/Interactable'\nimport type Interaction from '@interactjs/core/Interaction'\nimport type { SignalArgs, Scope } from '@interactjs/core/scope'\nimport type { ActionName, Element } from '@interactjs/core/types'\nimport { parentNode } from '@interactjs/utils/domUtils'\nimport is from '@interactjs/utils/is'\n\nimport autoStart from './base'\n\nfunction beforeStart({ interaction, eventTarget, dx, dy }: SignalArgs['interactions:move'], scope: Scope) {\n  if (interaction.prepared.name !== 'drag') return\n\n  // check if a drag is in the correct axis\n  const absX = Math.abs(dx)\n  const absY = Math.abs(dy)\n  const targetOptions = interaction.interactable.options.drag\n  const startAxis = targetOptions.startAxis\n  const currentAxis = absX > absY ? 'x' : absX < absY ? 'y' : 'xy'\n\n  interaction.prepared.axis =\n    targetOptions.lockAxis === 'start'\n      ? (currentAxis[0] as 'x' | 'y') // always lock to one axis even if currentAxis === 'xy'\n      : targetOptions.lockAxis\n\n  // if the movement isn't in the startAxis of the interactable\n  if (currentAxis !== 'xy' && startAxis !== 'xy' && startAxis !== currentAxis) {\n    // cancel the prepared action\n    ;(interaction as Interaction<ActionName>).prepared.name = null\n\n    // then try to get a drag from another ineractable\n    let element = eventTarget as Element\n\n    const getDraggable = function (interactable: Interactable): Interactable | void {\n      if (interactable === interaction.interactable) return\n\n      const options = interaction.interactable.options.drag\n\n      if (!options.manualStart && interactable.testIgnoreAllow(options, element, eventTarget)) {\n        const action = interactable.getAction(\n          interaction.downPointer,\n          interaction.downEvent,\n          interaction,\n          element,\n        )\n\n        if (\n          action &&\n          action.name === 'drag' &&\n          checkStartAxis(currentAxis, interactable) &&\n          autoStart.validateAction(action, interactable, element, eventTarget, scope)\n        ) {\n          return interactable\n        }\n      }\n    }\n\n    // check all interactables\n    while (is.element(element)) {\n      const interactable = scope.interactables.forEachMatch(element, getDraggable)\n\n      if (interactable) {\n        ;(interaction as Interaction<ActionName>).prepared.name = 'drag'\n        interaction.interactable = interactable\n        interaction.element = element\n        break\n      }\n\n      element = parentNode(element) as Element\n    }\n  }\n}\n\nfunction checkStartAxis(startAxis: string, interactable: Interactable) {\n  if (!interactable) {\n    return false\n  }\n\n  const thisAxis = interactable.options.drag.startAxis\n\n  return startAxis === 'xy' || thisAxis === 'xy' || thisAxis === startAxis\n}\n\nexport default {\n  id: 'auto-start/dragAxis',\n  listeners: { 'autoStart:before-start': beforeStart },\n}\n", "import type Interaction from '@interactjs/core/Interaction'\nimport type { Scope, Plugin } from '@interactjs/core/scope'\n\n/* eslint-disable import/no-duplicates -- for typescript module augmentations */\nimport './base'\nimport basePlugin from './base'\n/* eslint-enable */\n\ndeclare module '@interactjs/core/options' {\n  interface PerActionDefaults {\n    hold?: number\n    delay?: number\n  }\n}\n\ndeclare module '@interactjs/core/Interaction' {\n  interface Interaction {\n    autoStartHoldTimer?: any\n  }\n}\n\nfunction install(scope: Scope) {\n  const { defaults } = scope\n\n  scope.usePlugin(basePlugin)\n\n  defaults.perAction.hold = 0\n  defaults.perAction.delay = 0\n}\n\nfunction getHoldDuration(interaction: Interaction) {\n  const actionName = interaction.prepared && interaction.prepared.name\n\n  if (!actionName) {\n    return null\n  }\n\n  const options = interaction.interactable.options\n\n  return options[actionName].hold || options[actionName].delay\n}\n\nconst hold: Plugin = {\n  id: 'auto-start/hold',\n  install,\n  listeners: {\n    'interactions:new': ({ interaction }) => {\n      interaction.autoStartHoldTimer = null\n    },\n\n    'autoStart:prepared': ({ interaction }) => {\n      const hold = getHoldDuration(interaction)\n\n      if (hold > 0) {\n        interaction.autoStartHoldTimer = setTimeout(() => {\n          interaction.start(interaction.prepared, interaction.interactable, interaction.element)\n        }, hold)\n      }\n    },\n\n    'interactions:move': ({ interaction, duplicate }) => {\n      if (interaction.autoStartHoldTimer && interaction.pointerWasMoved && !duplicate) {\n        clearTimeout(interaction.autoStartHoldTimer)\n        interaction.autoStartHoldTimer = null\n      }\n    },\n\n    // prevent regular down->move autoStart\n    'autoStart:before-start': ({ interaction }) => {\n      const holdDuration = getHoldDuration(interaction)\n\n      if (holdDuration > 0) {\n        interaction.prepared.name = null\n      }\n    },\n  },\n  getHoldDuration,\n}\nexport default hold\n", "import type { Scope } from '@interactjs/core/scope'\n\n/* eslint-disable import/no-duplicates -- for typescript module augmentations */\nimport './base'\nimport './dragAxis'\nimport './hold'\n\nimport autoStart from './base'\nimport dragAxis from './dragAxis'\nimport hold from './hold'\n/* eslint-enable import/no-duplicates */\n\nexport default {\n  id: 'auto-start',\n  install(scope: Scope) {\n    scope.usePlugin(autoStart)\n    scope.usePlugin(hold)\n    scope.usePlugin(dragAxis)\n  },\n}\n", "/* eslint-disable no-console, eol-last, import/no-duplicates,  import/no-extraneous-dependencies, import/order */\nimport '@interactjs/auto-start/plugin'\nimport interact from '@interactjs/interact/index'\nimport plugin from '@interactjs/auto-start/plugin'\ninteract.use(plugin)"],
  "mappings": "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",
  "names": ["Interactable", "prototype", "getAction", "event", "interaction", "action", "defaultActionChecker", "options", "actionChecker", "ignoreFrom", "interactable", "rect", "button", "element", "buttons", "scope", "fire", "styleCursor", "newValue", "bool", "checker", "func", "id", "install", "install", "scope", "interactStatic", "interact", "defaults", "usePlugin", "InteractableMethods", "base", "actionChecker", "styleCursor", "extend", "perAction", "manualStart", "max", "Infinity", "maxPerElement", "allowFrom", "ignoreFrom", "mouseButtons", "maxInteractions", "newValue", "autoStart", "withinInteractionLimit", "cursorElement", "prepareOnDown", "_ref", "interaction", "pointer", "event", "eventTarget", "interacting", "actionInfo", "getActionInfo", "prepare", "prepareOnMove", "_ref2", "pointerType", "pointerIsDown", "startOnMove", "arg", "pointerWasMoved", "prepared", "name", "fire", "interactable", "actionName", "options", "element", "stop", "start", "setInteractionCursor", "clearCursorOnStop", "_ref3", "setCursor", "validateAction", "action", "testIgnoreAllow", "enabled", "validateMatches", "matches", "matchElements", "i", "len", "length", "match", "matchElement", "matchAction", "getAction", "pushMatches", "push", "is", "interactables", "forEachMatch", "parentNode", "_ref4", "copyAction", "rect", "getRect", "maxActions", "autoStartMax", "activeInteractions", "interactableCount", "elementCount", "interactions", "list", "otherAction", "number", "cursor", "prevCursorElement", "style", "ownerDocument", "documentElement", "cursorChecker", "func", "_interacting", "actions", "map", "getCursor", "id", "before", "listeners", "interactions:move", "interaction", "eventTarget", "dx", "dy", "_ref", "absX", "Math", "abs", "absY", "targetOptions", "startAxis", "currentAxis", "prepared", "element", "getDraggable", "interactable", "options", "manualStart", "testIgnoreAllow", "getAction", "downPointer", "downEvent", "action", "is", "checkStartAxis", "thisAxis", "id", "listeners", "install", "scope", "defaults", "usePlugin", "basePlugin", "perAction", "hold", "delay", "getHoldDuration", "interaction", "actionName", "prepared", "name", "options", "interactable", "id", "listeners", "_ref", "autoStartHoldTimer", "_ref2", "setTimeout", "start", "element", "_ref3", "duplicate", "pointerWasMoved", "clearTimeout", "_ref4", "holdDuration", "id", "install", "scope", "usePlugin", "autoStart", "hold", "dragAxis", "interact", "use", "plugin"]
}
