import {
  getStringOptionResult,
  interact,
  raf
} from "./chunk-5BACM2RS.js";
import {
  getElementClientRect,
  getWindow,
  is
} from "./chunk-PAETVFDA.js";
import "./chunk-RSJERJUL.js";

// node_modules/.pnpm/@interactjs+auto-scroll@1.10.27_@interactjs+utils@1.10.27/node_modules/@interactjs/auto-scroll/plugin.js
function install(scope) {
  const {
    defaults,
    actions
  } = scope;
  scope.autoScroll = autoScroll;
  autoScroll.now = () => scope.now();
  actions.phaselessTypes.autoscroll = true;
  defaults.perAction.autoScroll = autoScroll.defaults;
}
var autoScroll = {
  defaults: {
    enabled: false,
    margin: 60,
    container: null,
    speed: 300
  },
  now: Date.now,
  interaction: null,
  i: 0,
  x: 0,
  y: 0,
  isScrolling: false,
  prevTime: 0,
  margin: 0,
  speed: 0,
  start(interaction) {
    autoScroll.isScrolling = true;
    raf.cancel(autoScroll.i);
    interaction.autoScroll = autoScroll;
    autoScroll.interaction = interaction;
    autoScroll.prevTime = autoScroll.now();
    autoScroll.i = raf.request(autoScroll.scroll);
  },
  stop() {
    autoScroll.isScrolling = false;
    if (autoScroll.interaction) {
      autoScroll.interaction.autoScroll = null;
    }
    raf.cancel(autoScroll.i);
  },
  scroll() {
    const {
      interaction
    } = autoScroll;
    const {
      interactable,
      element
    } = interaction;
    const actionName = interaction.prepared.name;
    const options = interactable.options[actionName].autoScroll;
    const container = getContainer(options.container, interactable, element);
    const now = autoScroll.now();
    const dt = (now - autoScroll.prevTime) / 1e3;
    const s = options.speed * dt;
    if (s >= 1) {
      const scrollBy = {
        x: autoScroll.x * s,
        y: autoScroll.y * s
      };
      if (scrollBy.x || scrollBy.y) {
        const prevScroll = getScroll(container);
        if (is.window(container)) {
          container.scrollBy(scrollBy.x, scrollBy.y);
        } else if (container) {
          container.scrollLeft += scrollBy.x;
          container.scrollTop += scrollBy.y;
        }
        const curScroll = getScroll(container);
        const delta = {
          x: curScroll.x - prevScroll.x,
          y: curScroll.y - prevScroll.y
        };
        if (delta.x || delta.y) {
          interactable.fire({
            type: "autoscroll",
            target: element,
            interactable,
            delta,
            interaction,
            container
          });
        }
      }
      autoScroll.prevTime = now;
    }
    if (autoScroll.isScrolling) {
      raf.cancel(autoScroll.i);
      autoScroll.i = raf.request(autoScroll.scroll);
    }
  },
  check(interactable, actionName) {
    var _options$actionName$a;
    const options = interactable.options;
    return (_options$actionName$a = options[actionName].autoScroll) == null ? void 0 : _options$actionName$a.enabled;
  },
  onInteractionMove(_ref) {
    let {
      interaction,
      pointer
    } = _ref;
    if (!(interaction.interacting() && autoScroll.check(interaction.interactable, interaction.prepared.name))) {
      return;
    }
    if (interaction.simulation) {
      autoScroll.x = autoScroll.y = 0;
      return;
    }
    let top;
    let right;
    let bottom;
    let left;
    const {
      interactable,
      element
    } = interaction;
    const actionName = interaction.prepared.name;
    const options = interactable.options[actionName].autoScroll;
    const container = getContainer(options.container, interactable, element);
    if (is.window(container)) {
      left = pointer.clientX < autoScroll.margin;
      top = pointer.clientY < autoScroll.margin;
      right = pointer.clientX > container.innerWidth - autoScroll.margin;
      bottom = pointer.clientY > container.innerHeight - autoScroll.margin;
    } else {
      const rect = getElementClientRect(container);
      left = pointer.clientX < rect.left + autoScroll.margin;
      top = pointer.clientY < rect.top + autoScroll.margin;
      right = pointer.clientX > rect.right - autoScroll.margin;
      bottom = pointer.clientY > rect.bottom - autoScroll.margin;
    }
    autoScroll.x = right ? 1 : left ? -1 : 0;
    autoScroll.y = bottom ? 1 : top ? -1 : 0;
    if (!autoScroll.isScrolling) {
      autoScroll.margin = options.margin;
      autoScroll.speed = options.speed;
      autoScroll.start(interaction);
    }
  }
};
function getContainer(value, interactable, element) {
  return (is.string(value) ? getStringOptionResult(value, interactable, element) : value) || getWindow(element);
}
function getScroll(container) {
  if (is.window(container)) {
    container = window.document.body;
  }
  return {
    x: container.scrollLeft,
    y: container.scrollTop
  };
}
var autoScrollPlugin = {
  id: "auto-scroll",
  install,
  listeners: {
    "interactions:new": (_ref3) => {
      let {
        interaction
      } = _ref3;
      interaction.autoScroll = null;
    },
    "interactions:destroy": (_ref4) => {
      let {
        interaction
      } = _ref4;
      interaction.autoScroll = null;
      autoScroll.stop();
      if (autoScroll.interaction) {
        autoScroll.interaction = null;
      }
    },
    "interactions:stop": autoScroll.stop,
    "interactions:action-move": (arg) => autoScroll.onInteractionMove(arg)
  }
};

// node_modules/.pnpm/@interactjs+auto-scroll@1.10.27_@interactjs+utils@1.10.27/node_modules/@interactjs/auto-scroll/index.js
interact.use(autoScrollPlugin);
//# sourceMappingURL=@interactjs_auto-scroll.js.map
