// node_modules/.pnpm/@interactjs+utils@1.10.27/node_modules/@interactjs/utils/arr.js
var merge = (target, source) => {
  for (const item of source) {
    target.push(item);
  }
  return target;
};
var from = (source) => merge([], source);
var findIndex = (array2, func2) => {
  for (let i = 0; i < array2.length; i++) {
    if (func2(array2[i], i, array2)) {
      return i;
    }
  }
  return -1;
};
var find = (array2, func2) => array2[findIndex(array2, func2)];

// node_modules/.pnpm/@interactjs+utils@1.10.27/node_modules/@interactjs/utils/domObjects.js
var domObjects = {
  init,
  document: null,
  DocumentFragment: null,
  SVGElement: null,
  SVGSVGElement: null,
  SVGElementInstance: null,
  Element: null,
  HTMLElement: null,
  Event: null,
  Touch: null,
  PointerEvent: null
};
function blank() {
}
function init(window3) {
  const win2 = window3;
  domObjects.document = win2.document;
  domObjects.DocumentFragment = win2.DocumentFragment || blank;
  domObjects.SVGElement = win2.SVGElement || blank;
  domObjects.SVGSVGElement = win2.SVGSVGElement || blank;
  domObjects.SVGElementInstance = win2.SVGElementInstance || blank;
  domObjects.Element = win2.Element || blank;
  domObjects.HTMLElement = win2.HTMLElement || domObjects.Element;
  domObjects.Event = win2.Event;
  domObjects.Touch = win2.Touch || blank;
  domObjects.PointerEvent = win2.PointerEvent || win2.MSPointerEvent;
}

// node_modules/.pnpm/@interactjs+utils@1.10.27/node_modules/@interactjs/utils/isWindow.js
var isWindow = (thing) => !!(thing && thing.Window) && thing instanceof thing.Window;

// node_modules/.pnpm/@interactjs+utils@1.10.27/node_modules/@interactjs/utils/window.js
var realWindow = void 0;
var win = void 0;
function init2(window3) {
  realWindow = window3;
  const el = window3.document.createTextNode("");
  if (el.ownerDocument !== window3.document && typeof window3.wrap === "function" && window3.wrap(el) === el) {
    window3 = window3.wrap(window3);
  }
  win = window3;
}
if (typeof window !== "undefined" && !!window) {
  init2(window);
}
function getWindow(node) {
  if (isWindow(node)) {
    return node;
  }
  const rootNode = node.ownerDocument || node;
  return rootNode.defaultView || win.window;
}

// node_modules/.pnpm/@interactjs+utils@1.10.27/node_modules/@interactjs/utils/is.js
var window2 = (thing) => thing === win || isWindow(thing);
var docFrag = (thing) => object(thing) && thing.nodeType === 11;
var object = (thing) => !!thing && typeof thing === "object";
var func = (thing) => typeof thing === "function";
var number = (thing) => typeof thing === "number";
var bool = (thing) => typeof thing === "boolean";
var string = (thing) => typeof thing === "string";
var element = (thing) => {
  if (!thing || typeof thing !== "object") {
    return false;
  }
  const _window = getWindow(thing) || win;
  return /object|function/.test(typeof Element) ? thing instanceof Element || thing instanceof _window.Element : thing.nodeType === 1 && typeof thing.nodeName === "string";
};
var plainObject = (thing) => object(thing) && !!thing.constructor && /function Object\b/.test(thing.constructor.toString());
var array = (thing) => object(thing) && typeof thing.length !== "undefined" && func(thing.splice);
var is = {
  window: window2,
  docFrag,
  object,
  func,
  number,
  bool,
  string,
  element,
  plainObject,
  array
};

// node_modules/.pnpm/@interactjs+utils@1.10.27/node_modules/@interactjs/utils/browser.js
var browser = {
  init: init3,
  supportsTouch: null,
  supportsPointerEvent: null,
  isIOS7: null,
  isIOS: null,
  isIe9: null,
  isOperaMobile: null,
  prefixedMatchesSelector: null,
  pEventTypes: null,
  wheelEvent: null
};
function init3(window3) {
  const Element2 = domObjects.Element;
  const navigator = window3.navigator || {};
  browser.supportsTouch = "ontouchstart" in window3 || is.func(window3.DocumentTouch) && domObjects.document instanceof window3.DocumentTouch;
  browser.supportsPointerEvent = navigator.pointerEnabled !== false && !!domObjects.PointerEvent;
  browser.isIOS = /iP(hone|od|ad)/.test(navigator.platform);
  browser.isIOS7 = /iP(hone|od|ad)/.test(navigator.platform) && /OS 7[^\d]/.test(navigator.appVersion);
  browser.isIe9 = /MSIE 9/.test(navigator.userAgent);
  browser.isOperaMobile = navigator.appName === "Opera" && browser.supportsTouch && /Presto/.test(navigator.userAgent);
  browser.prefixedMatchesSelector = "matches" in Element2.prototype ? "matches" : "webkitMatchesSelector" in Element2.prototype ? "webkitMatchesSelector" : "mozMatchesSelector" in Element2.prototype ? "mozMatchesSelector" : "oMatchesSelector" in Element2.prototype ? "oMatchesSelector" : "msMatchesSelector";
  browser.pEventTypes = browser.supportsPointerEvent ? domObjects.PointerEvent === window3.MSPointerEvent ? {
    up: "MSPointerUp",
    down: "MSPointerDown",
    over: "mouseover",
    out: "mouseout",
    move: "MSPointerMove",
    cancel: "MSPointerCancel"
  } : {
    up: "pointerup",
    down: "pointerdown",
    over: "pointerover",
    out: "pointerout",
    move: "pointermove",
    cancel: "pointercancel"
  } : null;
  browser.wheelEvent = domObjects.document && "onmousewheel" in domObjects.document ? "mousewheel" : "wheel";
}

// node_modules/.pnpm/@interactjs+utils@1.10.27/node_modules/@interactjs/utils/clone.js
function clone(source) {
  const dest = {};
  for (const prop in source) {
    const value = source[prop];
    if (is.plainObject(value)) {
      dest[prop] = clone(value);
    } else if (is.array(value)) {
      dest[prop] = from(value);
    } else {
      dest[prop] = value;
    }
  }
  return dest;
}

// node_modules/.pnpm/@interactjs+utils@1.10.27/node_modules/@interactjs/utils/domUtils.js
function nodeContains(parent, child) {
  if (parent.contains) {
    return parent.contains(child);
  }
  while (child) {
    if (child === parent) {
      return true;
    }
    child = child.parentNode;
  }
  return false;
}
function closest(element2, selector) {
  while (is.element(element2)) {
    if (matchesSelector(element2, selector)) {
      return element2;
    }
    element2 = parentNode(element2);
  }
  return null;
}
function parentNode(node) {
  let parent = node.parentNode;
  if (is.docFrag(parent)) {
    while ((parent = parent.host) && is.docFrag(parent)) {
      continue;
    }
    return parent;
  }
  return parent;
}
function matchesSelector(element2, selector) {
  if (win !== realWindow) {
    selector = selector.replace(/\/deep\//g, " ");
  }
  return element2[browser.prefixedMatchesSelector](selector);
}
function matchesUpTo(element2, selector, limit) {
  while (is.element(element2)) {
    if (matchesSelector(element2, selector)) {
      return true;
    }
    element2 = parentNode(element2);
    if (element2 === limit) {
      return matchesSelector(element2, selector);
    }
  }
  return false;
}
function getActualElement(element2) {
  return element2.correspondingUseElement || element2;
}
function getScrollXY(relevantWindow) {
  relevantWindow = relevantWindow || win;
  return {
    x: relevantWindow.scrollX || relevantWindow.document.documentElement.scrollLeft,
    y: relevantWindow.scrollY || relevantWindow.document.documentElement.scrollTop
  };
}
function getElementClientRect(element2) {
  const clientRect = element2 instanceof domObjects.SVGElement ? element2.getBoundingClientRect() : element2.getClientRects()[0];
  return clientRect && {
    left: clientRect.left,
    right: clientRect.right,
    top: clientRect.top,
    bottom: clientRect.bottom,
    width: clientRect.width || clientRect.right - clientRect.left,
    height: clientRect.height || clientRect.bottom - clientRect.top
  };
}
function getElementRect(element2) {
  const clientRect = getElementClientRect(element2);
  if (!browser.isIOS7 && clientRect) {
    const scroll = getScrollXY(getWindow(element2));
    clientRect.left += scroll.x;
    clientRect.right += scroll.x;
    clientRect.top += scroll.y;
    clientRect.bottom += scroll.y;
  }
  return clientRect;
}
function trySelector(value) {
  if (!is.string(value)) {
    return false;
  }
  domObjects.document.querySelector(value);
  return true;
}

// node_modules/.pnpm/@interactjs+utils@1.10.27/node_modules/@interactjs/utils/extend.js
function extend(dest, source) {
  for (const prop in source) {
    dest[prop] = source[prop];
  }
  const ret = dest;
  return ret;
}

// node_modules/.pnpm/@interactjs+utils@1.10.27/node_modules/@interactjs/utils/isNonNativeEvent.js
function isNonNativeEvent(type, actions) {
  if (actions.phaselessTypes[type]) {
    return true;
  }
  for (const name in actions.map) {
    if (type.indexOf(name) === 0 && type.substr(name.length) in actions.phases) {
      return true;
    }
  }
  return false;
}

// node_modules/.pnpm/@interactjs+utils@1.10.27/node_modules/@interactjs/utils/normalizeListeners.js
function normalize(type, listeners) {
  let filter = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : (_typeOrPrefix) => true;
  let result = arguments.length > 3 ? arguments[3] : void 0;
  result = result || {};
  if (is.string(type) && type.search(" ") !== -1) {
    type = split(type);
  }
  if (is.array(type)) {
    type.forEach((t) => normalize(t, listeners, filter, result));
    return result;
  }
  if (is.object(type)) {
    listeners = type;
    type = "";
  }
  if (is.func(listeners) && filter(type)) {
    result[type] = result[type] || [];
    result[type].push(listeners);
  } else if (is.array(listeners)) {
    for (const l of listeners) {
      normalize(type, l, filter, result);
    }
  } else if (is.object(listeners)) {
    for (const prefix in listeners) {
      const combinedTypes = split(prefix).map((p) => `${type}${p}`);
      normalize(combinedTypes, listeners[prefix], filter, result);
    }
  }
  return result;
}
function split(type) {
  return type.trim().split(/ +/);
}

// node_modules/.pnpm/@interactjs+core@1.10.27_@interactjs+utils@1.10.27/node_modules/@interactjs/core/Eventable.js
function fireUntilImmediateStopped(event, listeners) {
  for (const listener of listeners) {
    if (event.immediatePropagationStopped) {
      break;
    }
    listener(event);
  }
}
var Eventable = class {
  constructor(options) {
    this.options = void 0;
    this.types = {};
    this.propagationStopped = false;
    this.immediatePropagationStopped = false;
    this.global = void 0;
    this.options = extend({}, options || {});
  }
  fire(event) {
    let listeners;
    const global = this.global;
    if (listeners = this.types[event.type]) {
      fireUntilImmediateStopped(event, listeners);
    }
    if (!event.propagationStopped && global && (listeners = global[event.type])) {
      fireUntilImmediateStopped(event, listeners);
    }
  }
  on(type, listener) {
    const listeners = normalize(type, listener);
    for (type in listeners) {
      this.types[type] = merge(this.types[type] || [], listeners[type]);
    }
  }
  off(type, listener) {
    const listeners = normalize(type, listener);
    for (type in listeners) {
      const eventList = this.types[type];
      if (!eventList || !eventList.length) {
        continue;
      }
      for (const subListener of listeners[type]) {
        const index = eventList.indexOf(subListener);
        if (index !== -1) {
          eventList.splice(index, 1);
        }
      }
    }
  }
  getRect(_element) {
    return null;
  }
};

// node_modules/.pnpm/@interactjs+core@1.10.27_@interactjs+utils@1.10.27/node_modules/@interactjs/core/Interactable.js
var OnOffMethod = function(OnOffMethod2) {
  OnOffMethod2[OnOffMethod2["On"] = 0] = "On";
  OnOffMethod2[OnOffMethod2["Off"] = 1] = "Off";
  return OnOffMethod2;
}(OnOffMethod || {});
var Interactable = class {
  get _defaults() {
    return {
      base: {},
      perAction: {},
      actions: {}
    };
  }
  constructor(target, options, defaultContext, scopeEvents) {
    this.target = void 0;
    this.options = void 0;
    this._actions = void 0;
    this.events = new Eventable();
    this._context = void 0;
    this._win = void 0;
    this._doc = void 0;
    this._scopeEvents = void 0;
    this._actions = options.actions;
    this.target = target;
    this._context = options.context || defaultContext;
    this._win = getWindow(trySelector(target) ? this._context : target);
    this._doc = this._win.document;
    this._scopeEvents = scopeEvents;
    this.set(options);
  }
  setOnEvents(actionName, phases) {
    if (is.func(phases.onstart)) {
      this.on(`${actionName}start`, phases.onstart);
    }
    if (is.func(phases.onmove)) {
      this.on(`${actionName}move`, phases.onmove);
    }
    if (is.func(phases.onend)) {
      this.on(`${actionName}end`, phases.onend);
    }
    if (is.func(phases.oninertiastart)) {
      this.on(`${actionName}inertiastart`, phases.oninertiastart);
    }
    return this;
  }
  updatePerActionListeners(actionName, prev, cur) {
    var _this$_actions$map$ac;
    const actionFilter = (_this$_actions$map$ac = this._actions.map[actionName]) == null ? void 0 : _this$_actions$map$ac.filterEventType;
    const filter = (type) => (actionFilter == null || actionFilter(type)) && isNonNativeEvent(type, this._actions);
    if (is.array(prev) || is.object(prev)) {
      this._onOff(OnOffMethod.Off, actionName, prev, void 0, filter);
    }
    if (is.array(cur) || is.object(cur)) {
      this._onOff(OnOffMethod.On, actionName, cur, void 0, filter);
    }
  }
  setPerAction(actionName, options) {
    const defaults = this._defaults;
    for (const optionName_ in options) {
      const optionName = optionName_;
      const actionOptions = this.options[actionName];
      const optionValue = options[optionName];
      if (optionName === "listeners") {
        this.updatePerActionListeners(actionName, actionOptions.listeners, optionValue);
      }
      if (is.array(optionValue)) {
        actionOptions[optionName] = from(optionValue);
      } else if (is.plainObject(optionValue)) {
        actionOptions[optionName] = extend(actionOptions[optionName] || {}, clone(optionValue));
        if (is.object(defaults.perAction[optionName]) && "enabled" in defaults.perAction[optionName]) {
          actionOptions[optionName].enabled = optionValue.enabled !== false;
        }
      } else if (is.bool(optionValue) && is.object(defaults.perAction[optionName])) {
        actionOptions[optionName].enabled = optionValue;
      } else {
        actionOptions[optionName] = optionValue;
      }
    }
  }
  getRect(element2) {
    element2 = element2 || (is.element(this.target) ? this.target : null);
    if (is.string(this.target)) {
      element2 = element2 || this._context.querySelector(this.target);
    }
    return getElementRect(element2);
  }
  rectChecker(checker) {
    if (is.func(checker)) {
      this.getRect = (element2) => {
        const rect = extend({}, checker.apply(this, element2));
        if (!("width" in rect)) {
          rect.width = rect.right - rect.left;
          rect.height = rect.bottom - rect.top;
        }
        return rect;
      };
      return this;
    }
    if (checker === null) {
      delete this.getRect;
      return this;
    }
    return this.getRect;
  }
  _backCompatOption(optionName, newValue) {
    if (trySelector(newValue) || is.object(newValue)) {
      this.options[optionName] = newValue;
      for (const action in this._actions.map) {
        this.options[action][optionName] = newValue;
      }
      return this;
    }
    return this.options[optionName];
  }
  origin(newValue) {
    return this._backCompatOption("origin", newValue);
  }
  deltaSource(newValue) {
    if (newValue === "page" || newValue === "client") {
      this.options.deltaSource = newValue;
      return this;
    }
    return this.options.deltaSource;
  }
  getAllElements() {
    const {
      target
    } = this;
    if (is.string(target)) {
      return Array.from(this._context.querySelectorAll(target));
    }
    if (is.func(target) && target.getAllElements) {
      return target.getAllElements();
    }
    return is.element(target) ? [target] : [];
  }
  context() {
    return this._context;
  }
  inContext(element2) {
    return this._context === element2.ownerDocument || nodeContains(this._context, element2);
  }
  testIgnoreAllow(options, targetNode, eventTarget) {
    return !this.testIgnore(options.ignoreFrom, targetNode, eventTarget) && this.testAllow(options.allowFrom, targetNode, eventTarget);
  }
  testAllow(allowFrom, targetNode, element2) {
    if (!allowFrom) {
      return true;
    }
    if (!is.element(element2)) {
      return false;
    }
    if (is.string(allowFrom)) {
      return matchesUpTo(element2, allowFrom, targetNode);
    } else if (is.element(allowFrom)) {
      return nodeContains(allowFrom, element2);
    }
    return false;
  }
  testIgnore(ignoreFrom, targetNode, element2) {
    if (!ignoreFrom || !is.element(element2)) {
      return false;
    }
    if (is.string(ignoreFrom)) {
      return matchesUpTo(element2, ignoreFrom, targetNode);
    } else if (is.element(ignoreFrom)) {
      return nodeContains(ignoreFrom, element2);
    }
    return false;
  }
  fire(iEvent) {
    this.events.fire(iEvent);
    return this;
  }
  _onOff(method, typeArg, listenerArg, options, filter) {
    if (is.object(typeArg) && !is.array(typeArg)) {
      options = listenerArg;
      listenerArg = null;
    }
    const listeners = normalize(typeArg, listenerArg, filter);
    for (let type in listeners) {
      if (type === "wheel") {
        type = browser.wheelEvent;
      }
      for (const listener of listeners[type]) {
        if (isNonNativeEvent(type, this._actions)) {
          this.events[method === OnOffMethod.On ? "on" : "off"](type, listener);
        } else if (is.string(this.target)) {
          this._scopeEvents[method === OnOffMethod.On ? "addDelegate" : "removeDelegate"](this.target, this._context, type, listener, options);
        } else {
          this._scopeEvents[method === OnOffMethod.On ? "add" : "remove"](this.target, type, listener, options);
        }
      }
    }
    return this;
  }
  on(types, listener, options) {
    return this._onOff(OnOffMethod.On, types, listener, options);
  }
  off(types, listener, options) {
    return this._onOff(OnOffMethod.Off, types, listener, options);
  }
  set(options) {
    const defaults = this._defaults;
    if (!is.object(options)) {
      options = {};
    }
    this.options = clone(defaults.base);
    for (const actionName_ in this._actions.methodDict) {
      const actionName = actionName_;
      const methodName = this._actions.methodDict[actionName];
      this.options[actionName] = {};
      this.setPerAction(actionName, extend(extend({}, defaults.perAction), defaults.actions[actionName]));
      this[methodName](options[actionName]);
    }
    for (const setting in options) {
      if (setting === "getRect") {
        this.rectChecker(options.getRect);
        continue;
      }
      if (is.func(this[setting])) {
        this[setting](options[setting]);
      }
    }
    return this;
  }
  unset() {
    if (is.string(this.target)) {
      for (const type in this._scopeEvents.delegatedEvents) {
        const delegated = this._scopeEvents.delegatedEvents[type];
        for (let i = delegated.length - 1; i >= 0; i--) {
          const {
            selector,
            context,
            listeners
          } = delegated[i];
          if (selector === this.target && context === this._context) {
            delegated.splice(i, 1);
          }
          for (let l = listeners.length - 1; l >= 0; l--) {
            this._scopeEvents.removeDelegate(this.target, this._context, type, listeners[l][0], listeners[l][1]);
          }
        }
      }
    } else {
      this._scopeEvents.remove(this.target, "all");
    }
  }
};

export {
  win,
  init2 as init,
  getWindow,
  is,
  domObjects,
  browser,
  findIndex,
  find,
  clone,
  extend,
  normalize,
  Eventable,
  nodeContains,
  closest,
  parentNode,
  matchesSelector,
  matchesUpTo,
  getActualElement,
  getElementClientRect,
  getElementRect,
  isNonNativeEvent,
  Interactable
};
//# sourceMappingURL=chunk-PAETVFDA.js.map
