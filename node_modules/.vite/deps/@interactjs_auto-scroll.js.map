{
  "version": 3,
  "sources": ["../../.pnpm/@interactjs+auto-scroll@1.10.27_@interactjs+utils@1.10.27/node_modules/@interactjs/auto-scroll/plugin.ts", "../../.pnpm/@interactjs+auto-scroll@1.10.27_@interactjs+utils@1.10.27/node_modules/@interactjs/auto-scroll/index.ts"],
  "sourcesContent": ["import type { Interactable } from '@interactjs/core/Interactable'\nimport type Interaction from '@interactjs/core/Interaction'\nimport type { Scope, Plugin } from '@interactjs/core/scope'\nimport type { ActionName, PointerType } from '@interactjs/core/types'\nimport * as domUtils from '@interactjs/utils/domUtils'\nimport is from '@interactjs/utils/is'\nimport raf from '@interactjs/utils/raf'\nimport { getStringOptionResult } from '@interactjs/utils/rect'\nimport { getWindow } from '@interactjs/utils/window'\n\ndeclare module '@interactjs/core/scope' {\n  interface Scope {\n    autoScroll: typeof autoScroll\n  }\n}\n\ndeclare module '@interactjs/core/Interaction' {\n  interface Interaction {\n    autoScroll?: typeof autoScroll\n  }\n}\n\ndeclare module '@interactjs/core/options' {\n  interface PerActionDefaults {\n    autoScroll?: AutoScrollOptions\n  }\n}\n\nexport interface AutoScrollOptions {\n  container?: Window | HTMLElement | string\n  margin?: number\n  distance?: number\n  interval?: number\n  speed?: number\n  enabled?: boolean\n}\n\nfunction install(scope: Scope) {\n  const { defaults, actions } = scope\n\n  scope.autoScroll = autoScroll\n  autoScroll.now = () => scope.now()\n\n  actions.phaselessTypes.autoscroll = true\n  defaults.perAction.autoScroll = autoScroll.defaults\n}\n\nconst autoScroll = {\n  defaults: {\n    enabled: false,\n    margin: 60,\n\n    // the item that is scrolled (Window or HTMLElement)\n    container: null as AutoScrollOptions['container'],\n\n    // the scroll speed in pixels per second\n    speed: 300,\n  } as AutoScrollOptions,\n\n  now: Date.now,\n\n  interaction: null as Interaction<ActionName> | null,\n  i: 0, // the handle returned by window.setInterval\n\n  // Direction each pulse is to scroll in\n  x: 0,\n  y: 0,\n\n  isScrolling: false,\n  prevTime: 0,\n  margin: 0,\n  speed: 0,\n\n  start(interaction: Interaction) {\n    autoScroll.isScrolling = true\n    raf.cancel(autoScroll.i)\n\n    interaction.autoScroll = autoScroll\n    autoScroll.interaction = interaction\n    autoScroll.prevTime = autoScroll.now()\n    autoScroll.i = raf.request(autoScroll.scroll)\n  },\n\n  stop() {\n    autoScroll.isScrolling = false\n    if (autoScroll.interaction) {\n      autoScroll.interaction.autoScroll = null\n    }\n    raf.cancel(autoScroll.i)\n  },\n\n  // scroll the window by the values in scroll.x/y\n  scroll() {\n    const { interaction } = autoScroll\n    const { interactable, element } = interaction\n    const actionName = interaction.prepared.name\n    const options = interactable.options[actionName].autoScroll\n    const container = getContainer(options.container, interactable, element)\n    const now = autoScroll.now()\n    // change in time in seconds\n    const dt = (now - autoScroll.prevTime) / 1000\n    // displacement\n    const s = options.speed * dt\n\n    if (s >= 1) {\n      const scrollBy = {\n        x: autoScroll.x * s,\n        y: autoScroll.y * s,\n      }\n\n      if (scrollBy.x || scrollBy.y) {\n        const prevScroll = getScroll(container)\n\n        if (is.window(container)) {\n          container.scrollBy(scrollBy.x, scrollBy.y)\n        } else if (container) {\n          container.scrollLeft += scrollBy.x\n          container.scrollTop += scrollBy.y\n        }\n\n        const curScroll = getScroll(container)\n        const delta = {\n          x: curScroll.x - prevScroll.x,\n          y: curScroll.y - prevScroll.y,\n        }\n\n        if (delta.x || delta.y) {\n          interactable.fire({\n            type: 'autoscroll',\n            target: element,\n            interactable,\n            delta,\n            interaction,\n            container,\n          })\n        }\n      }\n\n      autoScroll.prevTime = now\n    }\n\n    if (autoScroll.isScrolling) {\n      raf.cancel(autoScroll.i)\n      autoScroll.i = raf.request(autoScroll.scroll)\n    }\n  },\n  check(interactable: Interactable, actionName: ActionName) {\n    const options = interactable.options\n\n    return options[actionName].autoScroll?.enabled\n  },\n  onInteractionMove<T extends ActionName>({\n    interaction,\n    pointer,\n  }: {\n    interaction: Interaction<T>\n    pointer: PointerType\n  }) {\n    if (\n      !(interaction.interacting() && autoScroll.check(interaction.interactable, interaction.prepared.name))\n    ) {\n      return\n    }\n\n    if (interaction.simulation) {\n      autoScroll.x = autoScroll.y = 0\n      return\n    }\n\n    let top: boolean\n    let right: boolean\n    let bottom: boolean\n    let left: boolean\n\n    const { interactable, element } = interaction\n    const actionName = interaction.prepared.name\n    const options = interactable.options[actionName].autoScroll\n    const container = getContainer(options.container, interactable, element)\n\n    if (is.window(container)) {\n      left = pointer.clientX < autoScroll.margin\n      top = pointer.clientY < autoScroll.margin\n      right = pointer.clientX > container.innerWidth - autoScroll.margin\n      bottom = pointer.clientY > container.innerHeight - autoScroll.margin\n    } else {\n      const rect = domUtils.getElementClientRect(container)\n\n      left = pointer.clientX < rect.left + autoScroll.margin\n      top = pointer.clientY < rect.top + autoScroll.margin\n      right = pointer.clientX > rect.right - autoScroll.margin\n      bottom = pointer.clientY > rect.bottom - autoScroll.margin\n    }\n\n    autoScroll.x = right ? 1 : left ? -1 : 0\n    autoScroll.y = bottom ? 1 : top ? -1 : 0\n\n    if (!autoScroll.isScrolling) {\n      // set the autoScroll properties to those of the target\n      autoScroll.margin = options.margin\n      autoScroll.speed = options.speed\n\n      autoScroll.start(interaction)\n    }\n  },\n}\n\nexport function getContainer(value: any, interactable: Interactable, element: Element) {\n  return (\n    (is.string(value) ? getStringOptionResult(value, interactable, element) : value) || getWindow(element)\n  )\n}\n\nexport function getScroll(container: any) {\n  if (is.window(container)) {\n    container = window.document.body\n  }\n\n  return { x: container.scrollLeft, y: container.scrollTop }\n}\n\nexport function getScrollSize(container: any) {\n  if (is.window(container)) {\n    container = window.document.body\n  }\n\n  return { x: container.scrollWidth, y: container.scrollHeight }\n}\n\nexport function getScrollSizeDelta<T extends ActionName>(\n  {\n    interaction,\n    element,\n  }: {\n    interaction: Partial<Interaction<T>>\n    element: Element\n  },\n  func: any,\n) {\n  const scrollOptions = interaction && interaction.interactable.options[interaction.prepared.name].autoScroll\n\n  if (!scrollOptions || !scrollOptions.enabled) {\n    func()\n    return { x: 0, y: 0 }\n  }\n\n  const scrollContainer = getContainer(scrollOptions.container, interaction.interactable, element)\n\n  const prevSize = getScroll(scrollContainer)\n  func()\n  const curSize = getScroll(scrollContainer)\n\n  return {\n    x: curSize.x - prevSize.x,\n    y: curSize.y - prevSize.y,\n  }\n}\n\nconst autoScrollPlugin: Plugin = {\n  id: 'auto-scroll',\n  install,\n  listeners: {\n    'interactions:new': ({ interaction }) => {\n      interaction.autoScroll = null\n    },\n\n    'interactions:destroy': ({ interaction }) => {\n      interaction.autoScroll = null\n      autoScroll.stop()\n      if (autoScroll.interaction) {\n        autoScroll.interaction = null\n      }\n    },\n\n    'interactions:stop': autoScroll.stop,\n\n    'interactions:action-move': (arg: any) => autoScroll.onInteractionMove(arg),\n  },\n}\n\nexport default autoScrollPlugin\n", "/* eslint-disable no-console, eol-last, import/no-duplicates,  import/no-extraneous-dependencies, import/order */\nimport '@interactjs/auto-scroll/plugin'\nimport interact from '@interactjs/interact/index'\nimport plugin from '@interactjs/auto-scroll/plugin'\ninteract.use(plugin)"],
  "mappings": "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",
  "names": ["defaults", "actions", "scope", "autoScroll", "phaselessTypes", "autoscroll", "enabled", "speed", "now", "interaction", "x", "y", "isScrolling", "prevTime", "margin", "start", "raf", "stop", "scroll", "interactable", "element", "actionName", "prepared", "options", "container", "getContainer", "s", "scrollBy", "prevScroll", "getScroll", "window", "scrollLeft", "curScroll", "delta", "type", "target", "check", "_options$actionName$a", "onInteractionMove", "pointer", "_ref", "simulation", "top", "right", "bottom", "left", "clientY", "clientX", "innerWidth", "rect", "domUtils", "getElementClientRect", "value", "autoScrollPlugin", "id", "install", "listeners", "interaction", "autoScroll", "stop", "interact", "use", "plugin"]
}
