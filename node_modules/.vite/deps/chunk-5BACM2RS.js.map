{
  "version": 3,
  "sources": ["../../.pnpm/@interactjs+utils@1.10.27/node_modules/@interactjs/utils/raf.ts", "../../.pnpm/@interactjs+utils@1.10.27/node_modules/@interactjs/utils/pointerExtend.ts", "../../.pnpm/@interactjs+utils@1.10.27/node_modules/@interactjs/utils/hypot.ts", "../../.pnpm/@interactjs+utils@1.10.27/node_modules/@interactjs/utils/pointerUtils.ts", "../../.pnpm/@interactjs+core@1.10.27_@interactjs+utils@1.10.27/node_modules/@interactjs/core/events.ts", "../../.pnpm/@interactjs+core@1.10.27_@interactjs+utils@1.10.27/node_modules/@interactjs/core/interactablePreventDefault.ts", "../../.pnpm/@interactjs+utils@1.10.27/node_modules/@interactjs/utils/misc.ts", "../../.pnpm/@interactjs+utils@1.10.27/node_modules/@interactjs/utils/rect.ts", "../../.pnpm/@interactjs+utils@1.10.27/node_modules/@interactjs/utils/getOriginXY.ts", "../../.pnpm/@interactjs+core@1.10.27_@interactjs+utils@1.10.27/node_modules/@interactjs/core/BaseEvent.ts", "../../.pnpm/@interactjs+core@1.10.27_@interactjs+utils@1.10.27/node_modules/@interactjs/core/options.ts", "../../.pnpm/@interactjs+core@1.10.27_@interactjs+utils@1.10.27/node_modules/@interactjs/core/InteractEvent.ts", "../../.pnpm/@interactjs+core@1.10.27_@interactjs+utils@1.10.27/node_modules/@interactjs/core/PointerInfo.ts", "../../.pnpm/@interactjs+core@1.10.27_@interactjs+utils@1.10.27/node_modules/@interactjs/core/Interaction.ts", "../../.pnpm/@interactjs+core@1.10.27_@interactjs+utils@1.10.27/node_modules/@interactjs/core/interactionFinder.ts", "../../.pnpm/@interactjs+core@1.10.27_@interactjs+utils@1.10.27/node_modules/@interactjs/core/interactions.ts", "../../.pnpm/@interactjs+core@1.10.27_@interactjs+utils@1.10.27/node_modules/@interactjs/core/InteractableSet.ts", "../../.pnpm/@interactjs+core@1.10.27_@interactjs+utils@1.10.27/node_modules/@interactjs/core/InteractStatic.ts", "../../.pnpm/@interactjs+core@1.10.27_@interactjs+utils@1.10.27/node_modules/@interactjs/core/scope.ts", "../../.pnpm/@interactjs+interact@1.10.27/node_modules/@interactjs/interact/index.ts"],
  "sourcesContent": ["let lastTime = 0\nlet request: typeof requestAnimationFrame\nlet cancel: typeof cancelAnimationFrame\n\nfunction init(global: Window | typeof globalThis) {\n  request = global.requestAnimationFrame\n  cancel = global.cancelAnimationFrame\n\n  if (!request) {\n    const vendors = ['ms', 'moz', 'webkit', 'o']\n\n    for (const vendor of vendors) {\n      request = global[`${vendor}RequestAnimationFrame` as 'requestAnimationFrame']\n      cancel =\n        global[`${vendor}CancelAnimationFrame` as 'cancelAnimationFrame'] ||\n        global[`${vendor}CancelRequestAnimationFrame` as 'cancelAnimationFrame']\n    }\n  }\n\n  request = request && request.bind(global)\n  cancel = cancel && cancel.bind(global)\n\n  if (!request) {\n    request = (callback) => {\n      const currTime = Date.now()\n      const timeToCall = Math.max(0, 16 - (currTime - lastTime))\n      const token = global.setTimeout(() => {\n        // eslint-disable-next-line n/no-callback-literal\n        callback(currTime + timeToCall)\n      }, timeToCall)\n\n      lastTime = currTime + timeToCall\n      return token as any\n    }\n\n    cancel = (token) => clearTimeout(token)\n  }\n}\n\nexport default {\n  request: (callback: FrameRequestCallback) => request(callback),\n  cancel: (token: number) => cancel(token),\n  init,\n}\n", "const VENDOR_PREFIXES = ['webkit', 'moz']\n\nexport default function pointerExtend<T>(dest: Partial<T & { __set?: Partial<T> }>, source: T) {\n  dest.__set ||= {} as any\n\n  for (const prop in source) {\n    // skip deprecated prefixed properties\n    if (VENDOR_PREFIXES.some((prefix) => prop.indexOf(prefix) === 0)) continue\n\n    if (typeof dest[prop] !== 'function' && prop !== '__set') {\n      Object.defineProperty(dest, prop, {\n        get() {\n          if (prop in dest.__set) return dest.__set[prop]\n\n          return (dest.__set[prop] = source[prop] as any)\n        },\n        set(value: any) {\n          dest.__set[prop] = value\n        },\n        configurable: true,\n      })\n    }\n  }\n  return dest\n}\n", "export default (x: number, y: number) => Math.sqrt(x * x + y * y)\n", "import type { InteractEvent } from '@interactjs/core/InteractEvent'\nimport type { CoordsSetMember, PointerType, Point, PointerEventType, Element } from '@interactjs/core/types'\n\nimport browser from './browser'\nimport dom from './domObjects'\nimport * as domUtils from './domUtils'\nimport hypot from './hypot'\nimport is from './is'\nimport pointerExtend from './pointerExtend'\n\nexport function copyCoords(dest: CoordsSetMember, src: CoordsSetMember) {\n  dest.page = dest.page || ({} as any)\n  dest.page.x = src.page.x\n  dest.page.y = src.page.y\n\n  dest.client = dest.client || ({} as any)\n  dest.client.x = src.client.x\n  dest.client.y = src.client.y\n\n  dest.timeStamp = src.timeStamp\n}\n\nexport function setCoordDeltas(targetObj: CoordsSetMember, prev: CoordsSetMember, cur: CoordsSetMember) {\n  targetObj.page.x = cur.page.x - prev.page.x\n  targetObj.page.y = cur.page.y - prev.page.y\n  targetObj.client.x = cur.client.x - prev.client.x\n  targetObj.client.y = cur.client.y - prev.client.y\n  targetObj.timeStamp = cur.timeStamp - prev.timeStamp\n}\n\nexport function setCoordVelocity(targetObj: CoordsSetMember, delta: CoordsSetMember) {\n  const dt = Math.max(delta.timeStamp / 1000, 0.001)\n\n  targetObj.page.x = delta.page.x / dt\n  targetObj.page.y = delta.page.y / dt\n  targetObj.client.x = delta.client.x / dt\n  targetObj.client.y = delta.client.y / dt\n  targetObj.timeStamp = dt\n}\n\nexport function setZeroCoords(targetObj: CoordsSetMember) {\n  targetObj.page.x = 0\n  targetObj.page.y = 0\n  targetObj.client.x = 0\n  targetObj.client.y = 0\n}\n\nexport function isNativePointer(pointer: any) {\n  return pointer instanceof dom.Event || pointer instanceof dom.Touch\n}\n\n// Get specified X/Y coords for mouse or event.touches[0]\nexport function getXY(type: string, pointer: PointerType | InteractEvent, xy: Point) {\n  xy = xy || ({} as Point)\n  type = type || 'page'\n\n  xy.x = pointer[(type + 'X') as 'pageX']\n  xy.y = pointer[(type + 'Y') as 'pageY']\n\n  return xy\n}\n\nexport function getPageXY(pointer: PointerType | InteractEvent, page?: Point) {\n  page = page || { x: 0, y: 0 }\n\n  // Opera Mobile handles the viewport and scrolling oddly\n  if (browser.isOperaMobile && isNativePointer(pointer)) {\n    getXY('screen', pointer, page)\n\n    page.x += window.scrollX\n    page.y += window.scrollY\n  } else {\n    getXY('page', pointer, page)\n  }\n\n  return page\n}\n\nexport function getClientXY(pointer: PointerType, client: Point) {\n  client = client || ({} as any)\n\n  if (browser.isOperaMobile && isNativePointer(pointer)) {\n    // Opera Mobile handles the viewport and scrolling oddly\n    getXY('screen', pointer, client)\n  } else {\n    getXY('client', pointer, client)\n  }\n\n  return client\n}\n\nexport function getPointerId(pointer: { pointerId?: number; identifier?: number; type?: string }) {\n  return is.number(pointer.pointerId) ? pointer.pointerId! : pointer.identifier!\n}\n\nexport function setCoords(dest: CoordsSetMember, pointers: any[], timeStamp: number) {\n  const pointer = pointers.length > 1 ? pointerAverage(pointers) : pointers[0]\n\n  getPageXY(pointer, dest.page)\n  getClientXY(pointer, dest.client)\n\n  dest.timeStamp = timeStamp\n}\n\nexport function getTouchPair(event: TouchEvent | PointerType[]) {\n  const touches: PointerType[] = []\n\n  // array of touches is supplied\n  if (is.array(event)) {\n    touches[0] = event[0]\n    touches[1] = event[1]\n  }\n  // an event\n  else {\n    if (event.type === 'touchend') {\n      if (event.touches.length === 1) {\n        touches[0] = event.touches[0]\n        touches[1] = event.changedTouches[0]\n      } else if (event.touches.length === 0) {\n        touches[0] = event.changedTouches[0]\n        touches[1] = event.changedTouches[1]\n      }\n    } else {\n      touches[0] = event.touches[0]\n      touches[1] = event.touches[1]\n    }\n  }\n\n  return touches\n}\n\nexport function pointerAverage(pointers: PointerType[]) {\n  const average = {\n    pageX: 0,\n    pageY: 0,\n    clientX: 0,\n    clientY: 0,\n    screenX: 0,\n    screenY: 0,\n  }\n\n  type CoordKeys = keyof typeof average\n\n  for (const pointer of pointers) {\n    for (const prop in average) {\n      average[prop as CoordKeys] += pointer[prop as CoordKeys]\n    }\n  }\n  for (const prop in average) {\n    average[prop as CoordKeys] /= pointers.length\n  }\n\n  return average\n}\n\nexport function touchBBox(event: PointerType[]) {\n  if (!event.length) {\n    return null\n  }\n\n  const touches = getTouchPair(event)\n  const minX = Math.min(touches[0].pageX, touches[1].pageX)\n  const minY = Math.min(touches[0].pageY, touches[1].pageY)\n  const maxX = Math.max(touches[0].pageX, touches[1].pageX)\n  const maxY = Math.max(touches[0].pageY, touches[1].pageY)\n\n  return {\n    x: minX,\n    y: minY,\n    left: minX,\n    top: minY,\n    right: maxX,\n    bottom: maxY,\n    width: maxX - minX,\n    height: maxY - minY,\n  }\n}\n\nexport function touchDistance(event: PointerType[] | TouchEvent, deltaSource: string) {\n  const sourceX = (deltaSource + 'X') as 'pageX'\n  const sourceY = (deltaSource + 'Y') as 'pageY'\n  const touches = getTouchPair(event)\n\n  const dx = touches[0][sourceX] - touches[1][sourceX]\n  const dy = touches[0][sourceY] - touches[1][sourceY]\n\n  return hypot(dx, dy)\n}\n\nexport function touchAngle(event: PointerType[] | TouchEvent, deltaSource: string) {\n  const sourceX = (deltaSource + 'X') as 'pageX'\n  const sourceY = (deltaSource + 'Y') as 'pageY'\n  const touches = getTouchPair(event)\n  const dx = touches[1][sourceX] - touches[0][sourceX]\n  const dy = touches[1][sourceY] - touches[0][sourceY]\n  const angle = (180 * Math.atan2(dy, dx)) / Math.PI\n\n  return angle\n}\n\nexport function getPointerType(pointer: { pointerType?: string; identifier?: number; type?: string }) {\n  return is.string(pointer.pointerType)\n    ? pointer.pointerType\n    : is.number(pointer.pointerType)\n      ? [undefined, undefined, 'touch', 'pen', 'mouse'][pointer.pointerType]!\n      : // if the PointerEvent API isn't available, then the \"pointer\" must\n        // be either a MouseEvent, TouchEvent, or Touch object\n        /touch/.test(pointer.type || '') || pointer instanceof dom.Touch\n        ? 'touch'\n        : 'mouse'\n}\n\n// [ event.target, event.currentTarget ]\nexport function getEventTargets(event: Event) {\n  const path = is.func(event.composedPath)\n    ? (event.composedPath() as Element[])\n    : (event as unknown as { path: Element[] }).path\n\n  return [\n    domUtils.getActualElement(path ? path[0] : (event.target as Element)),\n    domUtils.getActualElement(event.currentTarget as Element),\n  ]\n}\n\nexport function newCoords(): CoordsSetMember {\n  return {\n    page: { x: 0, y: 0 },\n    client: { x: 0, y: 0 },\n    timeStamp: 0,\n  }\n}\n\nexport function coordsToEvent(coords: MockCoords) {\n  const event = {\n    coords,\n    get page() {\n      return this.coords.page\n    },\n    get client() {\n      return this.coords.client\n    },\n    get timeStamp() {\n      return this.coords.timeStamp\n    },\n    get pageX() {\n      return this.coords.page.x\n    },\n    get pageY() {\n      return this.coords.page.y\n    },\n    get clientX() {\n      return this.coords.client.x\n    },\n    get clientY() {\n      return this.coords.client.y\n    },\n    get pointerId() {\n      return this.coords.pointerId\n    },\n    get target() {\n      return this.coords.target\n    },\n    get type() {\n      return this.coords.type\n    },\n    get pointerType() {\n      return this.coords.pointerType\n    },\n    get buttons() {\n      return this.coords.buttons\n    },\n    preventDefault() {},\n  }\n\n  return event as typeof event & PointerType & PointerEventType\n}\n\nexport interface MockCoords {\n  page: Point\n  client: Point\n  timeStamp?: number\n  pointerId?: any\n  target?: any\n  type?: string\n  pointerType?: string\n  buttons?: number\n}\n\nexport { pointerExtend }\n", "import * as arr from '@interactjs/utils/arr'\nimport * as domUtils from '@interactjs/utils/domUtils'\nimport is from '@interactjs/utils/is'\nimport pExtend from '@interactjs/utils/pointerExtend'\nimport * as pointerUtils from '@interactjs/utils/pointerUtils'\n\nimport type { Scope } from '@interactjs/core/scope'\nimport type { Element } from '@interactjs/core/types'\n\nimport type { NativeEventTarget } from './NativeTypes'\n\ndeclare module '@interactjs/core/scope' {\n  interface Scope {\n    events: ReturnType<typeof install>\n  }\n}\n\ninterface EventOptions {\n  capture: boolean\n  passive: boolean\n}\n\ntype PartialEventTarget = Partial<NativeEventTarget>\n\ntype ListenerEntry = { func: (event: Event | FakeEvent) => any; options: EventOptions }\n\nfunction install(scope: Scope) {\n  const targets: Array<{\n    eventTarget: PartialEventTarget\n    events: { [type: string]: ListenerEntry[] }\n  }> = []\n\n  const delegatedEvents: {\n    [type: string]: Array<{\n      selector: string\n      context: Node\n      listeners: ListenerEntry[]\n    }>\n  } = {}\n  const documents: Document[] = []\n\n  const eventsMethods = {\n    add,\n    remove,\n\n    addDelegate,\n    removeDelegate,\n\n    delegateListener,\n    delegateUseCapture,\n    delegatedEvents,\n    documents,\n\n    targets,\n\n    supportsOptions: false,\n    supportsPassive: false,\n  }\n\n  // check if browser supports passive events and options arg\n  scope.document?.createElement('div').addEventListener('test', null, {\n    get capture() {\n      return (eventsMethods.supportsOptions = true)\n    },\n    get passive() {\n      return (eventsMethods.supportsPassive = true)\n    },\n  })\n\n  scope.events = eventsMethods\n\n  function add(\n    eventTarget: PartialEventTarget,\n    type: string,\n    listener: ListenerEntry['func'],\n    optionalArg?: boolean | EventOptions,\n  ) {\n    if (!eventTarget.addEventListener) return\n\n    const options = getOptions(optionalArg)\n    let target = arr.find(targets, (t) => t.eventTarget === eventTarget)\n\n    if (!target) {\n      target = {\n        eventTarget,\n        events: {},\n      }\n\n      targets.push(target)\n    }\n\n    if (!target.events[type]) {\n      target.events[type] = []\n    }\n\n    if (!arr.find(target.events[type], (l) => l.func === listener && optionsMatch(l.options, options))) {\n      eventTarget.addEventListener(\n        type,\n        listener as any,\n        eventsMethods.supportsOptions ? options : options.capture,\n      )\n      target.events[type].push({ func: listener, options })\n    }\n  }\n\n  function remove(\n    eventTarget: PartialEventTarget,\n    type: string,\n    listener?: 'all' | ListenerEntry['func'],\n    optionalArg?: boolean | EventOptions,\n  ) {\n    if (!eventTarget.addEventListener || !eventTarget.removeEventListener) return\n\n    const targetIndex = arr.findIndex(targets, (t) => t.eventTarget === eventTarget)\n    const target = targets[targetIndex]\n\n    if (!target || !target.events) {\n      return\n    }\n\n    if (type === 'all') {\n      for (type in target.events) {\n        if (target.events.hasOwnProperty(type)) {\n          remove(eventTarget, type, 'all')\n        }\n      }\n      return\n    }\n\n    let typeIsEmpty = false\n    const typeListeners = target.events[type]\n\n    if (typeListeners) {\n      if (listener === 'all') {\n        for (let i = typeListeners.length - 1; i >= 0; i--) {\n          const entry = typeListeners[i]\n          remove(eventTarget, type, entry.func, entry.options)\n        }\n        return\n      } else {\n        const options = getOptions(optionalArg)\n\n        for (let i = 0; i < typeListeners.length; i++) {\n          const entry = typeListeners[i]\n          if (entry.func === listener && optionsMatch(entry.options, options)) {\n            eventTarget.removeEventListener(\n              type,\n              listener as any,\n              eventsMethods.supportsOptions ? options : options.capture,\n            )\n            typeListeners.splice(i, 1)\n\n            if (typeListeners.length === 0) {\n              delete target.events[type]\n              typeIsEmpty = true\n            }\n\n            break\n          }\n        }\n      }\n    }\n\n    if (typeIsEmpty && !Object.keys(target.events).length) {\n      targets.splice(targetIndex, 1)\n    }\n  }\n\n  function addDelegate(\n    selector: string,\n    context: Node,\n    type: string,\n    listener: ListenerEntry['func'],\n    optionalArg?: any,\n  ) {\n    const options = getOptions(optionalArg)\n    if (!delegatedEvents[type]) {\n      delegatedEvents[type] = []\n\n      // add delegate listener functions\n      for (const doc of documents) {\n        add(doc, type, delegateListener)\n        add(doc, type, delegateUseCapture, true)\n      }\n    }\n\n    const delegates = delegatedEvents[type]\n    let delegate = arr.find(delegates, (d) => d.selector === selector && d.context === context)\n\n    if (!delegate) {\n      delegate = { selector, context, listeners: [] }\n      delegates.push(delegate)\n    }\n\n    delegate.listeners.push({ func: listener, options })\n  }\n\n  function removeDelegate(\n    selector: string,\n    context: Document | Element,\n    type: string,\n    listener?: ListenerEntry['func'],\n    optionalArg?: any,\n  ) {\n    const options = getOptions(optionalArg)\n    const delegates = delegatedEvents[type]\n    let matchFound = false\n    let index: number\n\n    if (!delegates) return\n\n    // count from last index of delegated to 0\n    for (index = delegates.length - 1; index >= 0; index--) {\n      const cur = delegates[index]\n      // look for matching selector and context Node\n      if (cur.selector === selector && cur.context === context) {\n        const { listeners } = cur\n\n        // each item of the listeners array is an array: [function, capture, passive]\n        for (let i = listeners.length - 1; i >= 0; i--) {\n          const entry = listeners[i]\n\n          // check if the listener functions and capture and passive flags match\n          if (entry.func === listener && optionsMatch(entry.options, options)) {\n            // remove the listener from the array of listeners\n            listeners.splice(i, 1)\n\n            // if all listeners for this target have been removed\n            // remove the target from the delegates array\n            if (!listeners.length) {\n              delegates.splice(index, 1)\n\n              // remove delegate function from context\n              remove(context, type, delegateListener)\n              remove(context, type, delegateUseCapture, true)\n            }\n\n            // only remove one listener\n            matchFound = true\n            break\n          }\n        }\n\n        if (matchFound) {\n          break\n        }\n      }\n    }\n  }\n\n  // bound to the interactable context when a DOM event\n  // listener is added to a selector interactable\n  function delegateListener(event: Event | FakeEvent, optionalArg?: any) {\n    const options = getOptions(optionalArg)\n    const fakeEvent = new FakeEvent(event as Event)\n    const delegates = delegatedEvents[event.type]\n    const [eventTarget] = pointerUtils.getEventTargets(event as Event)\n    let element: Node = eventTarget\n\n    // climb up document tree looking for selector matches\n    while (is.element(element)) {\n      for (let i = 0; i < delegates.length; i++) {\n        const cur = delegates[i]\n        const { selector, context } = cur\n\n        if (\n          domUtils.matchesSelector(element, selector) &&\n          domUtils.nodeContains(context, eventTarget) &&\n          domUtils.nodeContains(context, element)\n        ) {\n          const { listeners } = cur\n\n          fakeEvent.currentTarget = element\n\n          for (const entry of listeners) {\n            if (optionsMatch(entry.options, options)) {\n              entry.func(fakeEvent)\n            }\n          }\n        }\n      }\n\n      element = domUtils.parentNode(element)\n    }\n  }\n\n  function delegateUseCapture(this: Element, event: Event | FakeEvent) {\n    return delegateListener.call(this, event, true)\n  }\n\n  // for type inferrence\n  return eventsMethods\n}\n\nclass FakeEvent implements Partial<Event> {\n  currentTarget: Node\n  originalEvent: Event\n  type: string\n\n  constructor(originalEvent: Event) {\n    this.originalEvent = originalEvent\n    // duplicate the event so that currentTarget can be changed\n    pExtend(this, originalEvent)\n  }\n\n  preventOriginalDefault() {\n    this.originalEvent.preventDefault()\n  }\n\n  stopPropagation() {\n    this.originalEvent.stopPropagation()\n  }\n\n  stopImmediatePropagation() {\n    this.originalEvent.stopImmediatePropagation()\n  }\n}\n\nfunction getOptions(param: { [index: string]: any } | boolean): { capture: boolean; passive: boolean } {\n  if (!is.object(param)) {\n    return { capture: !!param, passive: false }\n  }\n\n  return {\n    capture: !!param.capture,\n    passive: !!param.passive,\n  }\n}\n\nfunction optionsMatch(a: Partial<EventOptions> | boolean, b: Partial<EventOptions>) {\n  if (a === b) return true\n\n  if (typeof a === 'boolean') return !!b.capture === a && !!b.passive === false\n\n  return !!a.capture === !!b.capture && !!a.passive === !!b.passive\n}\n\nexport default {\n  id: 'events',\n  install,\n}\n", "import { matchesSelector, nodeContains } from '@interactjs/utils/domUtils'\nimport is from '@interactjs/utils/is'\nimport { getWindow } from '@interactjs/utils/window'\n\nimport type { Interactable } from '@interactjs/core/Interactable'\nimport type Interaction from '@interactjs/core/Interaction'\nimport type { Scope } from '@interactjs/core/scope'\nimport type { PointerEventType } from '@interactjs/core/types'\n\ntype PreventDefaultValue = 'always' | 'never' | 'auto'\n\ndeclare module '@interactjs/core/Interactable' {\n  interface Interactable {\n    preventDefault(newValue: PreventDefaultValue): this\n    preventDefault(): PreventDefaultValue\n    /**\n     * Returns or sets whether to prevent the browser's default behaviour in\n     * response to pointer events. Can be set to:\n     *  - `'always'` to always prevent\n     *  - `'never'` to never prevent\n     *  - `'auto'` to let interact.js try to determine what would be best\n     *\n     * @param newValue - `'always'`, `'never'` or `'auto'`\n     * @returns The current setting or this Interactable\n     */\n    preventDefault(newValue?: PreventDefaultValue): PreventDefaultValue | this\n    checkAndPreventDefault(event: Event): void\n  }\n}\n\nconst preventDefault = function preventDefault(this: Interactable, newValue?: PreventDefaultValue) {\n  if (/^(always|never|auto)$/.test(newValue)) {\n    this.options.preventDefault = newValue\n    return this\n  }\n\n  if (is.bool(newValue)) {\n    this.options.preventDefault = newValue ? 'always' : 'never'\n    return this\n  }\n\n  return this.options.preventDefault\n} as Interactable['preventDefault']\n\nfunction checkAndPreventDefault(interactable: Interactable, scope: Scope, event: Event) {\n  const setting = interactable.options.preventDefault\n\n  if (setting === 'never') return\n\n  if (setting === 'always') {\n    event.preventDefault()\n    return\n  }\n\n  // setting === 'auto'\n\n  // if the browser supports passive event listeners and isn't running on iOS,\n  // don't preventDefault of touch{start,move} events. CSS touch-action and\n  // user-select should be used instead of calling event.preventDefault().\n  if (scope.events.supportsPassive && /^touch(start|move)$/.test(event.type)) {\n    const doc = getWindow(event.target).document\n    const docOptions = scope.getDocOptions(doc)\n\n    if (!(docOptions && docOptions.events) || docOptions.events.passive !== false) {\n      return\n    }\n  }\n\n  // don't preventDefault of pointerdown events\n  if (/^(mouse|pointer|touch)*(down|start)/i.test(event.type)) {\n    return\n  }\n\n  // don't preventDefault on editable elements\n  if (\n    is.element(event.target) &&\n    matchesSelector(event.target, 'input,select,textarea,[contenteditable=true],[contenteditable=true] *')\n  ) {\n    return\n  }\n\n  event.preventDefault()\n}\n\nfunction onInteractionEvent({ interaction, event }: { interaction: Interaction; event: PointerEventType }) {\n  if (interaction.interactable) {\n    interaction.interactable.checkAndPreventDefault(event as Event)\n  }\n}\n\nexport function install(scope: Scope) {\n  const { Interactable } = scope\n\n  Interactable.prototype.preventDefault = preventDefault\n\n  Interactable.prototype.checkAndPreventDefault = function (event) {\n    return checkAndPreventDefault(this, scope, event)\n  }\n\n  // prevent native HTML5 drag on interact.js target elements\n  scope.interactions.docEvents.push({\n    type: 'dragstart',\n    listener(event) {\n      for (const interaction of scope.interactions.list) {\n        if (\n          interaction.element &&\n          (interaction.element === event.target || nodeContains(interaction.element, event.target))\n        ) {\n          interaction.interactable.checkAndPreventDefault(event)\n          return\n        }\n      }\n    },\n  })\n}\n\nexport default {\n  id: 'core/interactablePreventDefault',\n  install,\n  listeners: ['down', 'move', 'up', 'cancel'].reduce((acc, eventType) => {\n    acc[`interactions:${eventType}`] = onInteractionEvent\n    return acc\n  }, {} as any),\n}\n", "import type { ActionName, ActionProps } from '@interactjs/core/types'\n\nimport { window } from './window'\n\nexport function warnOnce<T>(this: T, method: (...args: any[]) => any, message: string) {\n  let warned = false\n\n  return function (this: T) {\n    if (!warned) {\n      ;(window as any).console.warn(message)\n      warned = true\n    }\n\n    return method.apply(this, arguments)\n  }\n}\n\nexport function copyAction<T extends ActionName>(dest: ActionProps<any>, src: ActionProps<T>) {\n  dest.name = src.name\n  dest.axis = src.axis\n  dest.edges = src.edges\n\n  return dest\n}\n\nexport const sign = (n: number) => (n >= 0 ? 1 : -1)\n", "import type {\n  HasGetRect,\n  RectResolvable,\n  Rect,\n  Element,\n  Point,\n  FullRect,\n  EdgeOptions,\n} from '@interactjs/core/types'\n\nimport { closest, getElementRect, parentNode } from './domUtils'\nimport extend from './extend'\nimport is from './is'\n\nexport function getStringOptionResult(value: any, target: HasGetRect, element: Node) {\n  if (value === 'parent') {\n    return parentNode(element)\n  }\n\n  if (value === 'self') {\n    return target.getRect(element as Element)\n  }\n\n  return closest(element, value)\n}\n\nexport function resolveRectLike<T extends any[]>(\n  value: RectResolvable<T>,\n  target?: HasGetRect,\n  element?: Node,\n  functionArgs?: T,\n) {\n  let returnValue: any = value\n  if (is.string(returnValue)) {\n    returnValue = getStringOptionResult(returnValue, target, element)\n  } else if (is.func(returnValue)) {\n    returnValue = returnValue(...functionArgs)\n  }\n\n  if (is.element(returnValue)) {\n    returnValue = getElementRect(returnValue)\n  }\n\n  return returnValue as Rect\n}\n\nexport function toFullRect(rect: Rect): FullRect {\n  const { top, left, bottom, right } = rect\n  const width = rect.width ?? rect.right - rect.left\n  const height = rect.height ?? rect.bottom - rect.top\n\n  return { top, left, bottom, right, width, height }\n}\n\nexport function rectToXY(rect: Rect | Point) {\n  return (\n    rect && {\n      x: 'x' in rect ? rect.x : rect.left,\n      y: 'y' in rect ? rect.y : rect.top,\n    }\n  )\n}\n\nexport function xywhToTlbr<T extends Partial<Rect & Point>>(rect: T) {\n  if (rect && !('left' in rect && 'top' in rect)) {\n    rect = extend({}, rect)\n\n    rect.left = rect.x || 0\n    rect.top = rect.y || 0\n    rect.right = rect.right || rect.left + rect.width\n    rect.bottom = rect.bottom || rect.top + rect.height\n  }\n\n  return rect as Rect & T\n}\n\nexport function tlbrToXywh(rect: Rect & Partial<Point>) {\n  if (rect && !('x' in rect && 'y' in rect)) {\n    rect = extend({}, rect)\n\n    rect.x = rect.left || 0\n    rect.y = rect.top || 0\n    rect.width = rect.width || (rect.right || 0) - rect.x\n    rect.height = rect.height || (rect.bottom || 0) - rect.y\n  }\n\n  return rect as FullRect & Point\n}\n\nexport function addEdges(edges: EdgeOptions, rect: Rect, delta: Point) {\n  if (edges.left) {\n    rect.left += delta.x\n  }\n  if (edges.right) {\n    rect.right += delta.x\n  }\n  if (edges.top) {\n    rect.top += delta.y\n  }\n  if (edges.bottom) {\n    rect.bottom += delta.y\n  }\n\n  rect.width = rect.right - rect.left\n  rect.height = rect.bottom - rect.top\n}\n", "import type { PerActionDefaults } from '@interactjs/core/options'\nimport type { ActionName, HasGetRect } from '@interactjs/core/types'\n\nimport { rectToXY, resolveRectLike } from './rect'\n\nexport default function getOriginXY(\n  target: HasGetRect & { options: PerActionDefaults },\n  element: Node,\n  actionName?: ActionName,\n) {\n  const actionOptions = actionName && (target.options as any)[actionName]\n  const actionOrigin = actionOptions && actionOptions.origin\n  const origin = actionOrigin || target.options.origin\n\n  const originRect = resolveRectLike(origin, target, element, [target && element])\n\n  return rectToXY(originRect) || { x: 0, y: 0 }\n}\n", "import type { Interactable } from '@interactjs/core/Interactable'\nimport type { Interaction, InteractionProxy } from '@interactjs/core/Interaction'\nimport type { ActionName } from '@interactjs/core/types'\n\nexport class BaseEvent<T extends ActionName | null = never> {\n  declare type: string\n  declare target: EventTarget\n  declare currentTarget: Node\n  declare interactable: Interactable\n  /** @internal */\n  declare _interaction: Interaction<T>\n  declare timeStamp: number\n  immediatePropagationStopped = false\n  propagationStopped = false\n\n  constructor(interaction: Interaction<T>) {\n    this._interaction = interaction\n  }\n\n  preventDefault() {}\n\n  /**\n   * Don't call any other listeners (even on the current target)\n   */\n  stopPropagation() {\n    this.propagationStopped = true\n  }\n\n  /**\n   * Don't call listeners on the remaining targets\n   */\n  stopImmediatePropagation() {\n    this.immediatePropagationStopped = this.propagationStopped = true\n  }\n}\n\n// defined outside of class definition to avoid assignment of undefined during\n// construction\nexport interface BaseEvent<T extends ActionName | null = never> {\n  interaction: InteractionProxy<T>\n}\n\n// getters and setters defined here to support typescript 3.6 and below which\n// don't support getter and setters in .d.ts files\nObject.defineProperty(BaseEvent.prototype, 'interaction', {\n  get(this: BaseEvent) {\n    return this._interaction._proxy\n  },\n  set(this: BaseEvent) {},\n})\n", "import type { Point, Listeners, OrBoolean, Element, Rect } from '@interactjs/core/types'\n\nexport interface Defaults {\n  base: BaseDefaults\n  perAction: PerActionDefaults\n  actions: ActionDefaults\n}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\nexport interface ActionDefaults {}\n\nexport interface BaseDefaults {\n  preventDefault?: 'always' | 'never' | 'auto'\n  deltaSource?: 'page' | 'client'\n  context?: Node\n  getRect?: (element: Element) => Rect\n}\n\nexport interface PerActionDefaults {\n  enabled?: boolean\n  origin?: Point | string | Element\n  listeners?: Listeners\n  allowFrom?: string | Element\n  ignoreFrom?: string | Element\n}\n\nexport type Options = Partial<BaseDefaults> &\n  Partial<PerActionDefaults> & {\n    [P in keyof ActionDefaults]?: Partial<ActionDefaults[P]>\n  }\n\nexport interface OptionsArg extends BaseDefaults, OrBoolean<Partial<ActionDefaults>> {}\n\nexport const defaults: Defaults = {\n  base: {\n    preventDefault: 'auto',\n    deltaSource: 'page',\n  },\n\n  perAction: {\n    enabled: false,\n    origin: { x: 0, y: 0 },\n  },\n\n  actions: {} as ActionDefaults,\n}\n", "import extend from '@interactjs/utils/extend'\nimport getOriginXY from '@interactjs/utils/getOriginXY'\nimport hypot from '@interactjs/utils/hypot'\n\nimport type { Point, FullRect, PointerEventType, Element, ActionName } from '@interactjs/core/types'\n\nimport { BaseEvent } from './BaseEvent'\nimport type { Interaction } from './Interaction'\nimport { defaults } from './options'\n\nexport type EventPhase = keyof PhaseMap\n\nexport interface PhaseMap {\n  start: true\n  move: true\n  end: true\n}\n\n// defined outside of class definition to avoid assignment of undefined during\n// construction\nexport interface InteractEvent {\n  pageX: number\n  pageY: number\n\n  clientX: number\n  clientY: number\n\n  dx: number\n  dy: number\n\n  velocityX: number\n  velocityY: number\n}\n\nexport class InteractEvent<\n  T extends ActionName = never,\n  P extends EventPhase = EventPhase,\n> extends BaseEvent<T> {\n  declare target: Element\n  declare currentTarget: Element\n  relatedTarget: Element | null = null\n  screenX?: number\n  screenY?: number\n  button: number\n  buttons: number\n  ctrlKey: boolean\n  shiftKey: boolean\n  altKey: boolean\n  metaKey: boolean\n  page: Point\n  client: Point\n  delta: Point\n  rect: FullRect\n  x0: number\n  y0: number\n  t0: number\n  dt: number\n  duration: number\n  clientX0: number\n  clientY0: number\n  velocity: Point\n  speed: number\n  swipe: ReturnType<InteractEvent<T>['getSwipe']>\n  // resize\n  axes?: 'x' | 'y' | 'xy'\n  /** @internal */\n  preEnd?: boolean\n\n  constructor(\n    interaction: Interaction<T>,\n    event: PointerEventType,\n    actionName: T,\n    phase: P,\n    element: Element,\n    preEnd?: boolean,\n    type?: string,\n  ) {\n    super(interaction)\n\n    element = element || interaction.element\n\n    const target = interaction.interactable\n    const deltaSource = (((target && target.options) || defaults) as any).deltaSource as 'page' | 'client'\n    const origin = getOriginXY(target, element, actionName)\n    const starting = phase === 'start'\n    const ending = phase === 'end'\n    const prevEvent = starting ? this : interaction.prevEvent\n    const coords = starting\n      ? interaction.coords.start\n      : ending\n        ? { page: prevEvent.page, client: prevEvent.client, timeStamp: interaction.coords.cur.timeStamp }\n        : interaction.coords.cur\n\n    this.page = extend({}, coords.page)\n    this.client = extend({}, coords.client)\n    this.rect = extend({}, interaction.rect)\n    this.timeStamp = coords.timeStamp\n\n    if (!ending) {\n      this.page.x -= origin.x\n      this.page.y -= origin.y\n\n      this.client.x -= origin.x\n      this.client.y -= origin.y\n    }\n\n    this.ctrlKey = event.ctrlKey\n    this.altKey = event.altKey\n    this.shiftKey = event.shiftKey\n    this.metaKey = event.metaKey\n    this.button = (event as MouseEvent).button\n    this.buttons = (event as MouseEvent).buttons\n    this.target = element\n    this.currentTarget = element\n    this.preEnd = preEnd\n    this.type = type || actionName + (phase || '')\n    this.interactable = target\n\n    this.t0 = starting ? interaction.pointers[interaction.pointers.length - 1].downTime : prevEvent.t0\n\n    this.x0 = interaction.coords.start.page.x - origin.x\n    this.y0 = interaction.coords.start.page.y - origin.y\n    this.clientX0 = interaction.coords.start.client.x - origin.x\n    this.clientY0 = interaction.coords.start.client.y - origin.y\n\n    if (starting || ending) {\n      this.delta = { x: 0, y: 0 }\n    } else {\n      this.delta = {\n        x: this[deltaSource].x - prevEvent[deltaSource].x,\n        y: this[deltaSource].y - prevEvent[deltaSource].y,\n      }\n    }\n\n    this.dt = interaction.coords.delta.timeStamp\n    this.duration = this.timeStamp - this.t0\n\n    // velocity and speed in pixels per second\n    this.velocity = extend({}, interaction.coords.velocity[deltaSource])\n    this.speed = hypot(this.velocity.x, this.velocity.y)\n\n    this.swipe = ending || phase === 'inertiastart' ? this.getSwipe() : null\n  }\n\n  getSwipe() {\n    const interaction = this._interaction\n\n    if (interaction.prevEvent.speed < 600 || this.timeStamp - interaction.prevEvent.timeStamp > 150) {\n      return null\n    }\n\n    let angle = (180 * Math.atan2(interaction.prevEvent.velocityY, interaction.prevEvent.velocityX)) / Math.PI\n    const overlap = 22.5\n\n    if (angle < 0) {\n      angle += 360\n    }\n\n    const left = 135 - overlap <= angle && angle < 225 + overlap\n    const up = 225 - overlap <= angle && angle < 315 + overlap\n\n    const right = !left && (315 - overlap <= angle || angle < 45 + overlap)\n    const down = !up && 45 - overlap <= angle && angle < 135 + overlap\n\n    return {\n      up,\n      down,\n      left,\n      right,\n      angle,\n      speed: interaction.prevEvent.speed,\n      velocity: {\n        x: interaction.prevEvent.velocityX,\n        y: interaction.prevEvent.velocityY,\n      },\n    }\n  }\n\n  preventDefault() {}\n\n  /**\n   * Don't call listeners on the remaining targets\n   */\n  stopImmediatePropagation() {\n    this.immediatePropagationStopped = this.propagationStopped = true\n  }\n\n  /**\n   * Don't call any other listeners (even on the current target)\n   */\n  stopPropagation() {\n    this.propagationStopped = true\n  }\n}\n\n// getters and setters defined here to support typescript 3.6 and below which\n// don't support getter and setters in .d.ts files\nObject.defineProperties(InteractEvent.prototype, {\n  pageX: {\n    get() {\n      return this.page.x\n    },\n    set(value) {\n      this.page.x = value\n    },\n  },\n  pageY: {\n    get() {\n      return this.page.y\n    },\n    set(value) {\n      this.page.y = value\n    },\n  },\n\n  clientX: {\n    get() {\n      return this.client.x\n    },\n    set(value) {\n      this.client.x = value\n    },\n  },\n  clientY: {\n    get() {\n      return this.client.y\n    },\n    set(value) {\n      this.client.y = value\n    },\n  },\n\n  dx: {\n    get() {\n      return this.delta.x\n    },\n    set(value) {\n      this.delta.x = value\n    },\n  },\n  dy: {\n    get() {\n      return this.delta.y\n    },\n    set(value) {\n      this.delta.y = value\n    },\n  },\n\n  velocityX: {\n    get() {\n      return this.velocity.x\n    },\n    set(value) {\n      this.velocity.x = value\n    },\n  },\n  velocityY: {\n    get() {\n      return this.velocity.y\n    },\n    set(value) {\n      this.velocity.y = value\n    },\n  },\n})\n", "import type { PointerEventType, PointerType } from '@interactjs/core/types'\n\nexport class PointerInfo {\n  id: number\n  pointer: PointerType\n  event: PointerEventType\n  downTime: number\n  downTarget: Node\n\n  constructor(id: number, pointer: PointerType, event: PointerEventType, downTime: number, downTarget: Node) {\n    this.id = id\n    this.pointer = pointer\n    this.event = event\n    this.downTime = downTime\n    this.downTarget = downTarget\n  }\n}\n", "import * as arr from '@interactjs/utils/arr'\nimport extend from '@interactjs/utils/extend'\nimport hypot from '@interactjs/utils/hypot'\nimport { warnOnce, copyAction } from '@interactjs/utils/misc'\nimport * as pointerUtils from '@interactjs/utils/pointerUtils'\nimport * as rectUtils from '@interactjs/utils/rect'\n\nimport type {\n  Element,\n  EdgeOptions,\n  PointerEventType,\n  PointerType,\n  FullRect,\n  CoordsSet,\n  ActionName,\n  ActionProps,\n} from '@interactjs/core/types'\n\nimport type { Interactable } from './Interactable'\nimport type { EventPhase } from './InteractEvent'\nimport { InteractEvent } from './InteractEvent'\nimport type { ActionDefaults } from './options'\nimport { PointerInfo } from './PointerInfo'\nimport type { Scope } from './scope'\n\nexport enum _ProxyValues {\n  interactable = '',\n  element = '',\n  prepared = '',\n  pointerIsDown = '',\n  pointerWasMoved = '',\n  _proxy = '',\n}\n\nexport enum _ProxyMethods {\n  start = '',\n  move = '',\n  end = '',\n  stop = '',\n  interacting = '',\n}\n\nexport type PointerArgProps<T extends {} = {}> = {\n  pointer: PointerType\n  event: PointerEventType\n  eventTarget: Node\n  pointerIndex: number\n  pointerInfo: PointerInfo\n  interaction: Interaction<never>\n} & T\n\nexport interface DoPhaseArg<T extends ActionName, P extends EventPhase> {\n  event: PointerEventType\n  phase: EventPhase\n  interaction: Interaction<T>\n  iEvent: InteractEvent<T, P>\n  preEnd?: boolean\n  type?: string\n}\n\nexport type DoAnyPhaseArg = DoPhaseArg<ActionName, EventPhase>\n\ndeclare module '@interactjs/core/scope' {\n  interface SignalArgs {\n    'interactions:new': { interaction: Interaction<ActionName> }\n    'interactions:down': PointerArgProps<{\n      type: 'down'\n    }>\n    'interactions:move': PointerArgProps<{\n      type: 'move'\n      dx: number\n      dy: number\n      duplicate: boolean\n    }>\n    'interactions:up': PointerArgProps<{\n      type: 'up'\n      curEventTarget: EventTarget\n    }>\n    'interactions:cancel': SignalArgs['interactions:up'] & {\n      type: 'cancel'\n      curEventTarget: EventTarget\n    }\n    'interactions:update-pointer': PointerArgProps<{\n      down: boolean\n    }>\n    'interactions:remove-pointer': PointerArgProps\n    'interactions:blur': { interaction: Interaction<never>; event: Event; type: 'blur' }\n    'interactions:before-action-start': Omit<DoAnyPhaseArg, 'iEvent'>\n    'interactions:action-start': DoAnyPhaseArg\n    'interactions:after-action-start': DoAnyPhaseArg\n    'interactions:before-action-move': Omit<DoAnyPhaseArg, 'iEvent'>\n    'interactions:action-move': DoAnyPhaseArg\n    'interactions:after-action-move': DoAnyPhaseArg\n    'interactions:before-action-end': Omit<DoAnyPhaseArg, 'iEvent'>\n    'interactions:action-end': DoAnyPhaseArg\n    'interactions:after-action-end': DoAnyPhaseArg\n    'interactions:stop': { interaction: Interaction }\n  }\n}\n\nexport type InteractionProxy<T extends ActionName | null = never> = Pick<\n  Interaction<T>,\n  Exclude<keyof typeof _ProxyValues | keyof typeof _ProxyMethods, '_proxy'>\n>\n\nlet idCounter = 0\n\nexport class Interaction<T extends ActionName | null = ActionName> {\n  /** current interactable being interacted with */\n  interactable: Interactable | null = null\n\n  /** the target element of the interactable */\n  element: Element | null = null\n  rect: FullRect | null = null\n  /** @internal */\n  _rects?: {\n    start: FullRect\n    corrected: FullRect\n    previous: FullRect\n    delta: FullRect\n  }\n  /** @internal */\n  edges: EdgeOptions | null = null\n\n  /** @internal */\n  _scopeFire: Scope['fire']\n\n  // action that's ready to be fired on next move event\n  prepared: ActionProps<T> = {\n    name: null,\n    axis: null,\n    edges: null,\n  }\n\n  pointerType: string\n\n  /** @internal keep track of added pointers */\n  pointers: PointerInfo[] = []\n\n  /** @internal pointerdown/mousedown/touchstart event */\n  downEvent: PointerEventType | null = null\n\n  /** @internal */ downPointer: PointerType = {} as PointerType\n\n  /** @internal */\n  _latestPointer: {\n    pointer: PointerType\n    event: PointerEventType\n    eventTarget: Node\n  } = {\n    pointer: null,\n    event: null,\n    eventTarget: null,\n  }\n\n  /** @internal */ prevEvent: InteractEvent<T, EventPhase> = null\n\n  pointerIsDown = false\n  pointerWasMoved = false\n  /** @internal */ _interacting = false\n  /** @internal */ _ending = false\n  /** @internal */ _stopped = true\n  /** @internal */ _proxy: InteractionProxy<T>\n\n  /** @internal */ simulation = null\n\n  /** @internal */ get pointerMoveTolerance() {\n    return 1\n  }\n\n  doMove = warnOnce(function (this: Interaction, signalArg: any) {\n    this.move(signalArg)\n  }, 'The interaction.doMove() method has been renamed to interaction.move()')\n\n  coords: CoordsSet = {\n    // Starting InteractEvent pointer coordinates\n    start: pointerUtils.newCoords(),\n    // Previous native pointer move event coordinates\n    prev: pointerUtils.newCoords(),\n    // current native pointer move event coordinates\n    cur: pointerUtils.newCoords(),\n    // Change in coordinates and time of the pointer\n    delta: pointerUtils.newCoords(),\n    // pointer velocity\n    velocity: pointerUtils.newCoords(),\n  }\n\n  /** @internal */ readonly _id: number = idCounter++\n\n  constructor({ pointerType, scopeFire }: { pointerType?: string; scopeFire: Scope['fire'] }) {\n    this._scopeFire = scopeFire\n    this.pointerType = pointerType\n\n    const that = this\n\n    this._proxy = {} as InteractionProxy<T>\n\n    for (const key in _ProxyValues) {\n      Object.defineProperty(this._proxy, key, {\n        get() {\n          return that[key]\n        },\n      })\n    }\n\n    for (const key in _ProxyMethods) {\n      Object.defineProperty(this._proxy, key, {\n        value: (...args: any[]) => that[key](...args),\n      })\n    }\n\n    this._scopeFire('interactions:new', { interaction: this })\n  }\n\n  pointerDown(pointer: PointerType, event: PointerEventType, eventTarget: Node) {\n    const pointerIndex = this.updatePointer(pointer, event, eventTarget, true)\n    const pointerInfo = this.pointers[pointerIndex]\n\n    this._scopeFire('interactions:down', {\n      pointer,\n      event,\n      eventTarget,\n      pointerIndex,\n      pointerInfo,\n      type: 'down',\n      interaction: this as unknown as Interaction<never>,\n    })\n  }\n\n  /**\n   * ```js\n   * interact(target)\n   *   .draggable({\n   *     // disable the default drag start by down->move\n   *     manualStart: true\n   *   })\n   *   // start dragging after the user holds the pointer down\n   *   .on('hold', function (event) {\n   *     var interaction = event.interaction\n   *\n   *     if (!interaction.interacting()) {\n   *       interaction.start({ name: 'drag' },\n   *                         event.interactable,\n   *                         event.currentTarget)\n   *     }\n   * })\n   * ```\n   *\n   * Start an action with the given Interactable and Element as tartgets. The\n   * action must be enabled for the target Interactable and an appropriate\n   * number of pointers must be held down - 1 for drag/resize, 2 for gesture.\n   *\n   * Use it with `interactable.<action>able({ manualStart: false })` to always\n   * [start actions manually](https://github.com/taye/interact.js/issues/114)\n   *\n   * @param action - The action to be performed - drag, resize, etc.\n   * @param target - The Interactable to target\n   * @param element - The DOM Element to target\n   * @returns Whether the interaction was successfully started\n   */\n  start<A extends ActionName>(action: ActionProps<A>, interactable: Interactable, element: Element): boolean {\n    if (\n      this.interacting() ||\n      !this.pointerIsDown ||\n      this.pointers.length < (action.name === 'gesture' ? 2 : 1) ||\n      !interactable.options[action.name as keyof ActionDefaults].enabled\n    ) {\n      return false\n    }\n\n    copyAction(this.prepared, action)\n\n    this.interactable = interactable\n    this.element = element\n    this.rect = interactable.getRect(element)\n    this.edges = this.prepared.edges\n      ? extend({}, this.prepared.edges)\n      : { left: true, right: true, top: true, bottom: true }\n    this._stopped = false\n    this._interacting =\n      this._doPhase({\n        interaction: this,\n        event: this.downEvent,\n        phase: 'start',\n      }) && !this._stopped\n\n    return this._interacting\n  }\n\n  pointerMove(pointer: PointerType, event: PointerEventType, eventTarget: Node) {\n    if (!this.simulation && !(this.modification && this.modification.endResult)) {\n      this.updatePointer(pointer, event, eventTarget, false)\n    }\n\n    const duplicateMove =\n      this.coords.cur.page.x === this.coords.prev.page.x &&\n      this.coords.cur.page.y === this.coords.prev.page.y &&\n      this.coords.cur.client.x === this.coords.prev.client.x &&\n      this.coords.cur.client.y === this.coords.prev.client.y\n\n    let dx: number\n    let dy: number\n\n    // register movement greater than pointerMoveTolerance\n    if (this.pointerIsDown && !this.pointerWasMoved) {\n      dx = this.coords.cur.client.x - this.coords.start.client.x\n      dy = this.coords.cur.client.y - this.coords.start.client.y\n\n      this.pointerWasMoved = hypot(dx, dy) > this.pointerMoveTolerance\n    }\n\n    const pointerIndex = this.getPointerIndex(pointer)\n    const signalArg = {\n      pointer,\n      pointerIndex,\n      pointerInfo: this.pointers[pointerIndex],\n      event,\n      type: 'move' as const,\n      eventTarget,\n      dx,\n      dy,\n      duplicate: duplicateMove,\n      interaction: this as unknown as Interaction<never>,\n    }\n\n    if (!duplicateMove) {\n      // set pointer coordinate, time changes and velocity\n      pointerUtils.setCoordVelocity(this.coords.velocity, this.coords.delta)\n    }\n\n    this._scopeFire('interactions:move', signalArg)\n\n    if (!duplicateMove && !this.simulation) {\n      // if interacting, fire an 'action-move' signal etc\n      if (this.interacting()) {\n        signalArg.type = null\n        this.move(signalArg)\n      }\n\n      if (this.pointerWasMoved) {\n        pointerUtils.copyCoords(this.coords.prev, this.coords.cur)\n      }\n    }\n  }\n\n  /**\n   * ```js\n   * interact(target)\n   *   .draggable(true)\n   *   .on('dragmove', function (event) {\n   *     if (someCondition) {\n   *       // change the snap settings\n   *       event.interactable.draggable({ snap: { targets: [] }})\n   *       // fire another move event with re-calculated snap\n   *       event.interaction.move()\n   *     }\n   *   })\n   * ```\n   *\n   * Force a move of the current action at the same coordinates. Useful if\n   * snap/restrict has been changed and you want a movement with the new\n   * settings.\n   */\n  move(signalArg?: any) {\n    if (!signalArg || !signalArg.event) {\n      pointerUtils.setZeroCoords(this.coords.delta)\n    }\n\n    signalArg = extend(\n      {\n        pointer: this._latestPointer.pointer,\n        event: this._latestPointer.event,\n        eventTarget: this._latestPointer.eventTarget,\n        interaction: this,\n      },\n      signalArg || {},\n    )\n\n    signalArg.phase = 'move'\n\n    this._doPhase(signalArg)\n  }\n\n  /**\n   * @internal\n   * End interact move events and stop auto-scroll unless simulation is running\n   */\n  pointerUp(pointer: PointerType, event: PointerEventType, eventTarget: Node, curEventTarget: EventTarget) {\n    let pointerIndex = this.getPointerIndex(pointer)\n\n    if (pointerIndex === -1) {\n      pointerIndex = this.updatePointer(pointer, event, eventTarget, false)\n    }\n\n    const type = /cancel$/i.test(event.type) ? 'cancel' : 'up'\n\n    this._scopeFire(`interactions:${type}` as 'interactions:up' | 'interactions:cancel', {\n      pointer,\n      pointerIndex,\n      pointerInfo: this.pointers[pointerIndex],\n      event,\n      eventTarget,\n      type: type as any,\n      curEventTarget,\n      interaction: this as unknown as Interaction<never>,\n    })\n\n    if (!this.simulation) {\n      this.end(event)\n    }\n\n    this.removePointer(pointer, event)\n  }\n\n  /** @internal */\n  documentBlur(event: Event) {\n    this.end(event as any)\n    this._scopeFire('interactions:blur', {\n      event,\n      type: 'blur',\n      interaction: this as unknown as Interaction<never>,\n    })\n  }\n\n  /**\n   * ```js\n   * interact(target)\n   *   .draggable(true)\n   *   .on('move', function (event) {\n   *     if (event.pageX > 1000) {\n   *       // end the current action\n   *       event.interaction.end()\n   *       // stop all further listeners from being called\n   *       event.stopImmediatePropagation()\n   *     }\n   *   })\n   * ```\n   */\n  end(event?: PointerEventType) {\n    this._ending = true\n    event = event || this._latestPointer.event\n    let endPhaseResult: boolean\n\n    if (this.interacting()) {\n      endPhaseResult = this._doPhase({\n        event,\n        interaction: this,\n        phase: 'end',\n      })\n    }\n\n    this._ending = false\n\n    if (endPhaseResult === true) {\n      this.stop()\n    }\n  }\n\n  currentAction() {\n    return this._interacting ? this.prepared.name : null\n  }\n\n  interacting() {\n    return this._interacting\n  }\n\n  stop() {\n    this._scopeFire('interactions:stop', { interaction: this })\n\n    this.interactable = this.element = null\n\n    this._interacting = false\n    this._stopped = true\n    this.prepared.name = this.prevEvent = null\n  }\n\n  /** @internal */\n  getPointerIndex(pointer: any) {\n    const pointerId = pointerUtils.getPointerId(pointer)\n\n    // mouse and pen interactions may have only one pointer\n    return this.pointerType === 'mouse' || this.pointerType === 'pen'\n      ? this.pointers.length - 1\n      : arr.findIndex(this.pointers, (curPointer) => curPointer.id === pointerId)\n  }\n\n  /** @internal */\n  getPointerInfo(pointer: any) {\n    return this.pointers[this.getPointerIndex(pointer)]\n  }\n\n  /** @internal */\n  updatePointer(pointer: PointerType, event: PointerEventType, eventTarget: Node, down?: boolean) {\n    const id = pointerUtils.getPointerId(pointer)\n    let pointerIndex = this.getPointerIndex(pointer)\n    let pointerInfo = this.pointers[pointerIndex]\n\n    down = down === false ? false : down || /(down|start)$/i.test(event.type)\n\n    if (!pointerInfo) {\n      pointerInfo = new PointerInfo(id, pointer, event, null, null)\n\n      pointerIndex = this.pointers.length\n      this.pointers.push(pointerInfo)\n    } else {\n      pointerInfo.pointer = pointer\n    }\n\n    pointerUtils.setCoords(\n      this.coords.cur,\n      this.pointers.map((p) => p.pointer),\n      this._now(),\n    )\n    pointerUtils.setCoordDeltas(this.coords.delta, this.coords.prev, this.coords.cur)\n\n    if (down) {\n      this.pointerIsDown = true\n\n      pointerInfo.downTime = this.coords.cur.timeStamp\n      pointerInfo.downTarget = eventTarget\n      pointerUtils.pointerExtend(this.downPointer, pointer)\n\n      if (!this.interacting()) {\n        pointerUtils.copyCoords(this.coords.start, this.coords.cur)\n        pointerUtils.copyCoords(this.coords.prev, this.coords.cur)\n\n        this.downEvent = event\n        this.pointerWasMoved = false\n      }\n    }\n\n    this._updateLatestPointer(pointer, event, eventTarget)\n\n    this._scopeFire('interactions:update-pointer', {\n      pointer,\n      event,\n      eventTarget,\n      down,\n      pointerInfo,\n      pointerIndex,\n      interaction: this as unknown as Interaction<never>,\n    })\n\n    return pointerIndex\n  }\n\n  /** @internal */\n  removePointer(pointer: PointerType, event: PointerEventType) {\n    const pointerIndex = this.getPointerIndex(pointer)\n\n    if (pointerIndex === -1) return\n\n    const pointerInfo = this.pointers[pointerIndex]\n\n    this._scopeFire('interactions:remove-pointer', {\n      pointer,\n      event,\n      eventTarget: null,\n      pointerIndex,\n      pointerInfo,\n      interaction: this as unknown as Interaction<never>,\n    })\n\n    this.pointers.splice(pointerIndex, 1)\n    this.pointerIsDown = false\n  }\n\n  /** @internal */\n  _updateLatestPointer(pointer: PointerType, event: PointerEventType, eventTarget: Node) {\n    this._latestPointer.pointer = pointer\n    this._latestPointer.event = event\n    this._latestPointer.eventTarget = eventTarget\n  }\n\n  destroy() {\n    this._latestPointer.pointer = null\n    this._latestPointer.event = null\n    this._latestPointer.eventTarget = null\n  }\n\n  /** @internal */\n  _createPreparedEvent<P extends EventPhase>(\n    event: PointerEventType,\n    phase: P,\n    preEnd?: boolean,\n    type?: string,\n  ) {\n    return new InteractEvent<T, P>(this, event, this.prepared.name, phase, this.element, preEnd, type)\n  }\n\n  /** @internal */\n  _fireEvent<P extends EventPhase>(iEvent: InteractEvent<T, P>) {\n    this.interactable?.fire(iEvent)\n\n    if (!this.prevEvent || iEvent.timeStamp >= this.prevEvent.timeStamp) {\n      this.prevEvent = iEvent\n    }\n  }\n\n  /** @internal */\n  _doPhase<P extends EventPhase>(\n    signalArg: Omit<DoPhaseArg<T, P>, 'iEvent'> & { iEvent?: InteractEvent<T, P> },\n  ) {\n    const { event, phase, preEnd, type } = signalArg\n    const { rect } = this\n\n    if (rect && phase === 'move') {\n      // update the rect changes due to pointer move\n      rectUtils.addEdges(this.edges, rect, this.coords.delta[this.interactable.options.deltaSource])\n\n      rect.width = rect.right - rect.left\n      rect.height = rect.bottom - rect.top\n    }\n\n    const beforeResult = this._scopeFire(`interactions:before-action-${phase}` as any, signalArg)\n\n    if (beforeResult === false) {\n      return false\n    }\n\n    const iEvent = (signalArg.iEvent = this._createPreparedEvent(event, phase, preEnd, type))\n\n    this._scopeFire(`interactions:action-${phase}` as any, signalArg)\n\n    if (phase === 'start') {\n      this.prevEvent = iEvent\n    }\n\n    this._fireEvent(iEvent)\n\n    this._scopeFire(`interactions:after-action-${phase}` as any, signalArg)\n\n    return true\n  }\n\n  /** @internal */\n  _now() {\n    return Date.now()\n  }\n}\n\nexport default Interaction\nexport { PointerInfo }\n", "import * as dom from '@interactjs/utils/domUtils'\n\nimport type Interaction from '@interactjs/core/Interaction'\nimport type { Scope } from '@interactjs/core/scope'\nimport type { PointerType } from '@interactjs/core/types'\n\nexport interface SearchDetails {\n  pointer: PointerType\n  pointerId: number\n  pointerType: string\n  eventType: string\n  eventTarget: EventTarget\n  curEventTarget: EventTarget\n  scope: Scope\n}\n\nconst finder = {\n  methodOrder: ['simulationResume', 'mouseOrPen', 'hasPointer', 'idle'] as const,\n\n  search(details: SearchDetails) {\n    for (const method of finder.methodOrder) {\n      const interaction = finder[method](details)\n\n      if (interaction) {\n        return interaction\n      }\n    }\n\n    return null\n  },\n\n  // try to resume simulation with a new pointer\n  simulationResume({ pointerType, eventType, eventTarget, scope }: SearchDetails) {\n    if (!/down|start/i.test(eventType)) {\n      return null\n    }\n\n    for (const interaction of scope.interactions.list) {\n      let element = eventTarget as Node\n\n      if (\n        interaction.simulation &&\n        interaction.simulation.allowResume &&\n        interaction.pointerType === pointerType\n      ) {\n        while (element) {\n          // if the element is the interaction element\n          if (element === interaction.element) {\n            return interaction\n          }\n          element = dom.parentNode(element)\n        }\n      }\n    }\n\n    return null\n  },\n\n  // if it's a mouse or pen interaction\n  mouseOrPen({ pointerId, pointerType, eventType, scope }: SearchDetails) {\n    if (pointerType !== 'mouse' && pointerType !== 'pen') {\n      return null\n    }\n\n    let firstNonActive\n\n    for (const interaction of scope.interactions.list) {\n      if (interaction.pointerType === pointerType) {\n        // if it's a down event, skip interactions with running simulations\n        if (interaction.simulation && !hasPointerId(interaction, pointerId)) {\n          continue\n        }\n\n        // if the interaction is active, return it immediately\n        if (interaction.interacting()) {\n          return interaction\n        }\n        // otherwise save it and look for another active interaction\n        else if (!firstNonActive) {\n          firstNonActive = interaction\n        }\n      }\n    }\n\n    // if no active mouse interaction was found use the first inactive mouse\n    // interaction\n    if (firstNonActive) {\n      return firstNonActive\n    }\n\n    // find any mouse or pen interaction.\n    // ignore the interaction if the eventType is a *down, and a simulation\n    // is active\n    for (const interaction of scope.interactions.list) {\n      if (interaction.pointerType === pointerType && !(/down/i.test(eventType) && interaction.simulation)) {\n        return interaction\n      }\n    }\n\n    return null\n  },\n\n  // get interaction that has this pointer\n  hasPointer({ pointerId, scope }: SearchDetails) {\n    for (const interaction of scope.interactions.list) {\n      if (hasPointerId(interaction, pointerId)) {\n        return interaction\n      }\n    }\n\n    return null\n  },\n\n  // get first idle interaction with a matching pointerType\n  idle({ pointerType, scope }: SearchDetails) {\n    for (const interaction of scope.interactions.list) {\n      // if there's already a pointer held down\n      if (interaction.pointers.length === 1) {\n        const target = interaction.interactable\n        // don't add this pointer if there is a target interactable and it\n        // isn't gesturable\n        if (target && !(target.options.gesture && target.options.gesture.enabled)) {\n          continue\n        }\n      }\n      // maximum of 2 pointers per interaction\n      else if (interaction.pointers.length >= 2) {\n        continue\n      }\n\n      if (!interaction.interacting() && pointerType === interaction.pointerType) {\n        return interaction\n      }\n    }\n\n    return null\n  },\n}\n\nfunction hasPointerId(interaction: Interaction, pointerId: number) {\n  return interaction.pointers.some(({ id }) => id === pointerId)\n}\n\nexport default finder\n", "import browser from '@interactjs/utils/browser'\nimport domObjects from '@interactjs/utils/domObjects'\nimport { nodeContains } from '@interactjs/utils/domUtils'\nimport * as pointerUtils from '@interactjs/utils/pointerUtils'\n\nimport type { Scope, SignalArgs, Plugin } from '@interactjs/core/scope'\nimport type { ActionName, Listener } from '@interactjs/core/types'\n\n/* eslint-disable import/no-duplicates -- for typescript module augmentations */\nimport './interactablePreventDefault'\nimport interactablePreventDefault from './interactablePreventDefault'\nimport InteractionBase from './Interaction'\n/* eslint-enable import/no-duplicates */\nimport type { SearchDetails } from './interactionFinder'\nimport finder from './interactionFinder'\n\ndeclare module '@interactjs/core/scope' {\n  interface Scope {\n    Interaction: typeof InteractionBase\n    interactions: {\n      new: <T extends ActionName>(options: any) => InteractionBase<T>\n      list: Array<InteractionBase<ActionName>>\n      listeners: { [type: string]: Listener }\n      docEvents: Array<{ type: string; listener: Listener }>\n      pointerMoveTolerance: number\n    }\n    prevTouchTime: number\n  }\n\n  interface SignalArgs {\n    'interactions:find': {\n      interaction: InteractionBase\n      searchDetails: SearchDetails\n    }\n  }\n}\n\nconst methodNames = [\n  'pointerDown',\n  'pointerMove',\n  'pointerUp',\n  'updatePointer',\n  'removePointer',\n  'windowBlur',\n]\n\nfunction install(scope: Scope) {\n  const listeners = {} as any\n\n  for (const method of methodNames) {\n    listeners[method] = doOnInteractions(method, scope)\n  }\n\n  const pEventTypes = browser.pEventTypes\n  let docEvents: typeof scope.interactions.docEvents\n\n  if (domObjects.PointerEvent) {\n    docEvents = [\n      { type: pEventTypes.down, listener: releasePointersOnRemovedEls },\n      { type: pEventTypes.down, listener: listeners.pointerDown },\n      { type: pEventTypes.move, listener: listeners.pointerMove },\n      { type: pEventTypes.up, listener: listeners.pointerUp },\n      { type: pEventTypes.cancel, listener: listeners.pointerUp },\n    ]\n  } else {\n    docEvents = [\n      { type: 'mousedown', listener: listeners.pointerDown },\n      { type: 'mousemove', listener: listeners.pointerMove },\n      { type: 'mouseup', listener: listeners.pointerUp },\n\n      { type: 'touchstart', listener: releasePointersOnRemovedEls },\n      { type: 'touchstart', listener: listeners.pointerDown },\n      { type: 'touchmove', listener: listeners.pointerMove },\n      { type: 'touchend', listener: listeners.pointerUp },\n      { type: 'touchcancel', listener: listeners.pointerUp },\n    ]\n  }\n\n  docEvents.push({\n    type: 'blur',\n    listener(event) {\n      for (const interaction of scope.interactions.list) {\n        interaction.documentBlur(event)\n      }\n    },\n  })\n\n  // for ignoring browser's simulated mouse events\n  scope.prevTouchTime = 0\n\n  scope.Interaction = class<T extends ActionName> extends InteractionBase<T> {\n    get pointerMoveTolerance() {\n      return scope.interactions.pointerMoveTolerance\n    }\n\n    set pointerMoveTolerance(value) {\n      scope.interactions.pointerMoveTolerance = value\n    }\n\n    _now() {\n      return scope.now()\n    }\n  }\n\n  scope.interactions = {\n    // all active and idle interactions\n    list: [],\n    new<T extends ActionName>(options: { pointerType?: string; scopeFire?: Scope['fire'] }) {\n      options.scopeFire = (name, arg) => scope.fire(name, arg)\n\n      const interaction = new scope.Interaction<T>(options as Required<typeof options>)\n\n      scope.interactions.list.push(interaction)\n      return interaction\n    },\n    listeners,\n    docEvents,\n    pointerMoveTolerance: 1,\n  }\n\n  function releasePointersOnRemovedEls() {\n    // for all inactive touch interactions with pointers down\n    for (const interaction of scope.interactions.list) {\n      if (!interaction.pointerIsDown || interaction.pointerType !== 'touch' || interaction._interacting) {\n        continue\n      }\n\n      // if a pointer is down on an element that is no longer in the DOM tree\n      for (const pointer of interaction.pointers) {\n        if (!scope.documents.some(({ doc }) => nodeContains(doc, pointer.downTarget))) {\n          // remove the pointer from the interaction\n          interaction.removePointer(pointer.pointer, pointer.event)\n        }\n      }\n    }\n  }\n\n  scope.usePlugin(interactablePreventDefault)\n}\n\nfunction doOnInteractions(method: string, scope: Scope) {\n  return function (event: Event) {\n    const interactions = scope.interactions.list\n\n    const pointerType = pointerUtils.getPointerType(event)\n    const [eventTarget, curEventTarget] = pointerUtils.getEventTargets(event)\n    const matches: any[] = [] // [ [pointer, interaction], ...]\n\n    if (/^touch/.test(event.type)) {\n      scope.prevTouchTime = scope.now()\n\n      // @ts-expect-error\n      for (const changedTouch of event.changedTouches) {\n        const pointer = changedTouch\n        const pointerId = pointerUtils.getPointerId(pointer)\n        const searchDetails: SearchDetails = {\n          pointer,\n          pointerId,\n          pointerType,\n          eventType: event.type,\n          eventTarget,\n          curEventTarget,\n          scope,\n        }\n        const interaction = getInteraction(searchDetails)\n\n        matches.push([\n          searchDetails.pointer,\n          searchDetails.eventTarget,\n          searchDetails.curEventTarget,\n          interaction,\n        ])\n      }\n    } else {\n      let invalidPointer = false\n\n      if (!browser.supportsPointerEvent && /mouse/.test(event.type)) {\n        // ignore mouse events while touch interactions are active\n        for (let i = 0; i < interactions.length && !invalidPointer; i++) {\n          invalidPointer = interactions[i].pointerType !== 'mouse' && interactions[i].pointerIsDown\n        }\n\n        // try to ignore mouse events that are simulated by the browser\n        // after a touch event\n        invalidPointer =\n          invalidPointer ||\n          scope.now() - scope.prevTouchTime < 500 ||\n          // on iOS and Firefox Mobile, MouseEvent.timeStamp is zero if simulated\n          event.timeStamp === 0\n      }\n\n      if (!invalidPointer) {\n        const searchDetails = {\n          pointer: event as PointerEvent,\n          pointerId: pointerUtils.getPointerId(event as PointerEvent),\n          pointerType,\n          eventType: event.type,\n          curEventTarget,\n          eventTarget,\n          scope,\n        }\n\n        const interaction = getInteraction(searchDetails)\n\n        matches.push([\n          searchDetails.pointer,\n          searchDetails.eventTarget,\n          searchDetails.curEventTarget,\n          interaction,\n        ])\n      }\n    }\n\n    // eslint-disable-next-line no-shadow\n    for (const [pointer, eventTarget, curEventTarget, interaction] of matches) {\n      interaction[method](pointer, event, eventTarget, curEventTarget)\n    }\n  }\n}\n\nfunction getInteraction(searchDetails: SearchDetails) {\n  const { pointerType, scope } = searchDetails\n\n  const foundInteraction = finder.search(searchDetails)\n  const signalArg = { interaction: foundInteraction, searchDetails }\n\n  scope.fire('interactions:find', signalArg)\n\n  return signalArg.interaction || scope.interactions.new({ pointerType })\n}\n\nfunction onDocSignal<T extends 'scope:add-document' | 'scope:remove-document'>(\n  { doc, scope, options }: SignalArgs[T],\n  eventMethodName: 'add' | 'remove',\n) {\n  const {\n    interactions: { docEvents },\n    events,\n  } = scope\n  const eventMethod = events[eventMethodName]\n\n  if (scope.browser.isIOS && !options.events) {\n    options.events = { passive: false }\n  }\n\n  // delegate event listener\n  for (const eventType in events.delegatedEvents) {\n    eventMethod(doc, eventType, events.delegateListener)\n    eventMethod(doc, eventType, events.delegateUseCapture, true)\n  }\n\n  const eventOptions = options && options.events\n\n  for (const { type, listener } of docEvents) {\n    eventMethod(doc, type, listener, eventOptions)\n  }\n}\n\nconst interactions: Plugin = {\n  id: 'core/interactions',\n  install,\n  listeners: {\n    'scope:add-document': (arg) => onDocSignal(arg, 'add'),\n    'scope:remove-document': (arg) => onDocSignal(arg, 'remove'),\n    'interactable:unset': ({ interactable }, scope) => {\n      // Stop and destroy related interactions when an Interactable is unset\n      for (let i = scope.interactions.list.length - 1; i >= 0; i--) {\n        const interaction = scope.interactions.list[i]\n\n        if (interaction.interactable !== interactable) {\n          continue\n        }\n\n        interaction.stop()\n        scope.fire('interactions:destroy', { interaction })\n        interaction.destroy()\n\n        if (scope.interactions.list.length > 2) {\n          scope.interactions.list.splice(i, 1)\n        }\n      }\n    },\n  },\n  onDocSignal,\n  doOnInteractions,\n  methodNames,\n}\n\nexport default interactions\n", "import * as arr from '@interactjs/utils/arr'\nimport * as domUtils from '@interactjs/utils/domUtils'\nimport extend from '@interactjs/utils/extend'\nimport is from '@interactjs/utils/is'\n\nimport type { Interactable } from '@interactjs/core/Interactable'\nimport type { OptionsArg, Options } from '@interactjs/core/options'\nimport type { Scope } from '@interactjs/core/scope'\nimport type { Target } from '@interactjs/core/types'\n\ndeclare module '@interactjs/core/scope' {\n  interface SignalArgs {\n    'interactable:new': {\n      interactable: Interactable\n      target: Target\n      options: OptionsArg\n      win: Window\n    }\n  }\n}\n\nexport class InteractableSet {\n  // all set interactables\n  list: Interactable[] = []\n\n  selectorMap: {\n    [selector: string]: Interactable[]\n  } = {}\n\n  scope: Scope\n\n  constructor(scope: Scope) {\n    this.scope = scope\n    scope.addListeners({\n      'interactable:unset': ({ interactable }) => {\n        const { target } = interactable\n        const interactablesOnTarget: Interactable[] = is.string(target)\n          ? this.selectorMap[target]\n          : (target as any)[this.scope.id]\n\n        const targetIndex = arr.findIndex(interactablesOnTarget, (i) => i === interactable)\n        interactablesOnTarget.splice(targetIndex, 1)\n      },\n    })\n  }\n\n  new(target: Target, options?: any): Interactable {\n    options = extend(options || {}, {\n      actions: this.scope.actions,\n    })\n    const interactable = new this.scope.Interactable(target, options, this.scope.document, this.scope.events)\n\n    this.scope.addDocument(interactable._doc)\n    this.list.push(interactable)\n\n    if (is.string(target)) {\n      if (!this.selectorMap[target]) {\n        this.selectorMap[target] = []\n      }\n      this.selectorMap[target].push(interactable)\n    } else {\n      if (!(interactable.target as any)[this.scope.id]) {\n        Object.defineProperty(target, this.scope.id, {\n          value: [],\n          configurable: true,\n        })\n      }\n\n      ;(target as any)[this.scope.id].push(interactable)\n    }\n\n    this.scope.fire('interactable:new', {\n      target,\n      options,\n      interactable,\n      win: this.scope._win,\n    })\n\n    return interactable\n  }\n\n  getExisting(target: Target, options?: Options) {\n    const context = (options && options.context) || this.scope.document\n    const isSelector = is.string(target)\n    const interactablesOnTarget: Interactable[] = isSelector\n      ? this.selectorMap[target as string]\n      : (target as any)[this.scope.id]\n\n    if (!interactablesOnTarget) return undefined\n\n    return arr.find(\n      interactablesOnTarget,\n      (interactable) =>\n        interactable._context === context && (isSelector || interactable.inContext(target as any)),\n    )\n  }\n\n  forEachMatch<T>(node: Node, callback: (interactable: Interactable) => T): T | void {\n    for (const interactable of this.list) {\n      let ret: T\n\n      if (\n        (is.string(interactable.target)\n          ? // target is a selector and the element matches\n            is.element(node) && domUtils.matchesSelector(node, interactable.target)\n          : // target is the element\n            node === interactable.target) &&\n        // the element is in context\n        interactable.inContext(node)\n      ) {\n        ret = callback(interactable)\n      }\n\n      if (ret !== undefined) {\n        return ret\n      }\n    }\n  }\n}\n", "import browser from '@interactjs/utils/browser'\nimport * as domUtils from '@interactjs/utils/domUtils'\nimport is from '@interactjs/utils/is'\nimport isNonNativeEvent from '@interactjs/utils/isNonNativeEvent'\nimport { warnOnce } from '@interactjs/utils/misc'\nimport * as pointerUtils from '@interactjs/utils/pointerUtils'\n\nimport type { Scope, Plugin } from '@interactjs/core/scope'\nimport type { Context, EventTypes, Listener, ListenersArg, Target } from '@interactjs/core/types'\n\nimport type { Interactable } from './Interactable'\nimport type { Options } from './options'\n\n/**\n * ```js\n * interact('#draggable').draggable(true)\n *\n * var rectables = interact('rect')\n * rectables\n *   .gesturable(true)\n *   .on('gesturemove', function (event) {\n *       // ...\n *   })\n * ```\n *\n * The methods of this variable can be used to set elements as interactables\n * and also to change various default settings.\n *\n * Calling it as a function and passing an element or a valid CSS selector\n * string returns an Interactable object which has various methods to configure\n * it.\n *\n * @param {Element | string} target The HTML or SVG Element to interact with\n * or CSS selector\n * @return {Interactable}\n */\nexport interface InteractStatic {\n  (target: Target, options?: Options): Interactable\n  getPointerAverage: typeof pointerUtils.pointerAverage\n  getTouchBBox: typeof pointerUtils.touchBBox\n  getTouchDistance: typeof pointerUtils.touchDistance\n  getTouchAngle: typeof pointerUtils.touchAngle\n  getElementRect: typeof domUtils.getElementRect\n  getElementClientRect: typeof domUtils.getElementClientRect\n  matchesSelector: typeof domUtils.matchesSelector\n  closest: typeof domUtils.closest\n  /** @internal */ globalEvents: any\n  version: string\n  /** @internal */ scope: Scope\n  /**\n   * Use a plugin\n   */\n  use(\n    plugin: Plugin,\n    options?: {\n      [key: string]: any\n    },\n  ): any\n  /**\n   * Check if an element or selector has been set with the `interact(target)`\n   * function\n   *\n   * @return {boolean} Indicates if the element or CSS selector was previously\n   * passed to interact\n   */\n  isSet(\n    /* The Element or string being searched for */\n    target: Target,\n    options?: any,\n  ): boolean\n  on(type: string | EventTypes, listener: ListenersArg, options?: object): any\n  off(type: EventTypes, listener: any, options?: object): any\n  debug(): any\n  /**\n   * Whether or not the browser supports touch input\n   */\n  supportsTouch(): boolean\n  /**\n   * Whether or not the browser supports PointerEvents\n   */\n  supportsPointerEvent(): boolean\n  /**\n   * Cancels all interactions (end events are not fired)\n   */\n  stop(): InteractStatic\n  /**\n   * Returns or sets the distance the pointer must be moved before an action\n   * sequence occurs. This also affects tolerance for tap events.\n   */\n  pointerMoveTolerance(\n    /** The movement from the start position must be greater than this value */\n    newValue?: number,\n  ): InteractStatic | number\n  addDocument(doc: Document, options?: object): void\n  removeDocument(doc: Document): void\n}\n\nexport function createInteractStatic(scope: Scope): InteractStatic {\n  const interact = ((target: Target, options: Options) => {\n    let interactable = scope.interactables.getExisting(target, options)\n\n    if (!interactable) {\n      interactable = scope.interactables.new(target, options)\n      interactable.events.global = interact.globalEvents\n    }\n\n    return interactable\n  }) as InteractStatic\n\n  // expose the functions used to calculate multi-touch properties\n  interact.getPointerAverage = pointerUtils.pointerAverage\n  interact.getTouchBBox = pointerUtils.touchBBox\n  interact.getTouchDistance = pointerUtils.touchDistance\n  interact.getTouchAngle = pointerUtils.touchAngle\n\n  interact.getElementRect = domUtils.getElementRect\n  interact.getElementClientRect = domUtils.getElementClientRect\n  interact.matchesSelector = domUtils.matchesSelector\n  interact.closest = domUtils.closest\n\n  interact.globalEvents = {} as any\n\n  // eslint-disable-next-line no-undef\n  interact.version = process.env.npm_package_version\n  interact.scope = scope\n  interact.use = function (plugin, options) {\n    this.scope.usePlugin(plugin, options)\n\n    return this\n  }\n\n  interact.isSet = function (target: Target, options?: { context?: Context }): boolean {\n    return !!this.scope.interactables.get(target, options && options.context)\n  }\n\n  interact.on = warnOnce(function on(type: string | EventTypes, listener: ListenersArg, options?: object) {\n    if (is.string(type) && type.search(' ') !== -1) {\n      type = type.trim().split(/ +/)\n    }\n\n    if (is.array(type)) {\n      for (const eventType of type as any[]) {\n        this.on(eventType, listener, options)\n      }\n\n      return this\n    }\n\n    if (is.object(type)) {\n      for (const prop in type) {\n        this.on(prop, (type as any)[prop], listener)\n      }\n\n      return this\n    }\n\n    // if it is an InteractEvent type, add listener to globalEvents\n    if (isNonNativeEvent(type, this.scope.actions)) {\n      // if this type of event was never bound\n      if (!this.globalEvents[type]) {\n        this.globalEvents[type] = [listener]\n      } else {\n        this.globalEvents[type].push(listener)\n      }\n    }\n    // If non InteractEvent type, addEventListener to document\n    else {\n      this.scope.events.add(this.scope.document, type, listener as Listener, { options })\n    }\n\n    return this\n  }, 'The interact.on() method is being deprecated')\n\n  interact.off = warnOnce(function off(type: EventTypes, listener: any, options?: object) {\n    if (is.string(type) && type.search(' ') !== -1) {\n      type = type.trim().split(/ +/)\n    }\n\n    if (is.array(type)) {\n      for (const eventType of type) {\n        this.off(eventType, listener, options)\n      }\n\n      return this\n    }\n\n    if (is.object(type)) {\n      for (const prop in type) {\n        this.off(prop, type[prop], listener)\n      }\n\n      return this\n    }\n\n    if (isNonNativeEvent(type, this.scope.actions)) {\n      let index: number\n\n      if (type in this.globalEvents && (index = this.globalEvents[type].indexOf(listener)) !== -1) {\n        this.globalEvents[type].splice(index, 1)\n      }\n    } else {\n      this.scope.events.remove(this.scope.document, type, listener, options)\n    }\n\n    return this\n  }, 'The interact.off() method is being deprecated')\n\n  interact.debug = function () {\n    return this.scope\n  }\n\n  interact.supportsTouch = function () {\n    return browser.supportsTouch\n  }\n\n  interact.supportsPointerEvent = function () {\n    return browser.supportsPointerEvent\n  }\n\n  interact.stop = function () {\n    for (const interaction of this.scope.interactions.list) {\n      interaction.stop()\n    }\n\n    return this\n  }\n\n  interact.pointerMoveTolerance = function (newValue?: number) {\n    if (is.number(newValue)) {\n      this.scope.interactions.pointerMoveTolerance = newValue\n\n      return this\n    }\n\n    return this.scope.interactions.pointerMoveTolerance\n  }\n\n  interact.addDocument = function (doc: Document, options?: object) {\n    this.scope.addDocument(doc, options)\n  }\n\n  interact.removeDocument = function (doc: Document) {\n    this.scope.removeDocument(doc)\n  }\n\n  return interact\n}\n", "import browser from '@interactjs/utils/browser'\nimport clone from '@interactjs/utils/clone'\nimport domObjects from '@interactjs/utils/domObjects'\nimport extend from '@interactjs/utils/extend'\nimport is from '@interactjs/utils/is'\nimport raf from '@interactjs/utils/raf'\nimport * as win from '@interactjs/utils/window'\n\nimport type Interaction from '@interactjs/core/Interaction'\n\nimport { Eventable } from './Eventable'\n/* eslint-disable import/no-duplicates -- for typescript module augmentations */\nimport './events'\nimport './interactions'\nimport events from './events'\nimport { Interactable as InteractableBase } from './Interactable'\nimport { InteractableSet } from './InteractableSet'\nimport { InteractEvent } from './InteractEvent'\nimport interactions from './interactions'\n/* eslint-enable import/no-duplicates */\nimport { createInteractStatic } from './InteractStatic'\nimport type { OptionsArg } from './options'\nimport { defaults } from './options'\nimport type { Actions } from './types'\n\nexport interface SignalArgs {\n  'scope:add-document': DocSignalArg\n  'scope:remove-document': DocSignalArg\n  'interactable:unset': { interactable: InteractableBase }\n  'interactable:set': { interactable: InteractableBase; options: OptionsArg }\n  'interactions:destroy': { interaction: Interaction }\n}\n\nexport type ListenerName = keyof SignalArgs\n\nexport type ListenerMap = {\n  [P in ListenerName]?: (arg: SignalArgs[P], scope: Scope, signalName: P) => void | boolean\n}\n\ninterface DocSignalArg {\n  doc: Document\n  window: Window\n  scope: Scope\n  options: Record<string, any>\n}\n\nexport interface Plugin {\n  [key: string]: any\n  id?: string\n  listeners?: ListenerMap\n  before?: string[]\n  install?(scope: Scope, options?: any): void\n}\n\n/** @internal */\nexport class Scope {\n  id = `__interact_scope_${Math.floor(Math.random() * 100)}`\n  isInitialized = false\n  listenerMaps: Array<{\n    map: ListenerMap\n    id?: string\n  }> = []\n\n  browser = browser\n  defaults = clone(defaults) as typeof defaults\n  Eventable = Eventable\n  actions: Actions = {\n    map: {},\n    phases: {\n      start: true,\n      move: true,\n      end: true,\n    },\n    methodDict: {} as any,\n    phaselessTypes: {},\n  }\n\n  interactStatic = createInteractStatic(this)\n  InteractEvent = InteractEvent\n  Interactable: typeof InteractableBase\n  interactables = new InteractableSet(this)\n\n  // main window\n  _win!: Window\n\n  // main document\n  document!: Document\n\n  // main window\n  window!: Window\n\n  // all documents being listened to\n  documents: Array<{ doc: Document; options: any }> = []\n\n  _plugins: {\n    list: Plugin[]\n    map: { [id: string]: Plugin }\n  } = {\n    list: [],\n    map: {},\n  }\n\n  constructor() {\n    const scope = this\n\n    this.Interactable = class extends InteractableBase {\n      get _defaults() {\n        return scope.defaults\n      }\n\n      set<T extends InteractableBase>(this: T, options: OptionsArg) {\n        super.set(options)\n\n        scope.fire('interactable:set', {\n          options,\n          interactable: this,\n        })\n\n        return this\n      }\n\n      unset(this: InteractableBase) {\n        super.unset()\n\n        const index = scope.interactables.list.indexOf(this)\n        if (index < 0) return\n\n        scope.interactables.list.splice(index, 1)\n        scope.fire('interactable:unset', { interactable: this })\n      }\n    }\n  }\n\n  addListeners(map: ListenerMap, id?: string) {\n    this.listenerMaps.push({ id, map })\n  }\n\n  fire<T extends ListenerName>(name: T, arg: SignalArgs[T]): void | false {\n    for (const {\n      map: { [name]: listener },\n    } of this.listenerMaps) {\n      if (!!listener && listener(arg as any, this, name as never) === false) {\n        return false\n      }\n    }\n  }\n\n  onWindowUnload = (event: BeforeUnloadEvent) => this.removeDocument(event.target as Document)\n\n  init(window: Window | typeof globalThis) {\n    return this.isInitialized ? this : initScope(this, window)\n  }\n\n  pluginIsInstalled(plugin: Plugin) {\n    const { id } = plugin\n    return id ? !!this._plugins.map[id] : this._plugins.list.indexOf(plugin) !== -1\n  }\n\n  usePlugin(plugin: Plugin, options?: { [key: string]: any }) {\n    if (!this.isInitialized) {\n      return this\n    }\n\n    if (this.pluginIsInstalled(plugin)) {\n      return this\n    }\n\n    if (plugin.id) {\n      this._plugins.map[plugin.id] = plugin\n    }\n    this._plugins.list.push(plugin)\n\n    if (plugin.install) {\n      plugin.install(this, options)\n    }\n\n    if (plugin.listeners && plugin.before) {\n      let index = 0\n      const len = this.listenerMaps.length\n      const before = plugin.before.reduce((acc, id) => {\n        acc[id] = true\n        acc[pluginIdRoot(id)] = true\n        return acc\n      }, {})\n\n      for (; index < len; index++) {\n        const otherId = this.listenerMaps[index].id\n\n        if (otherId && (before[otherId] || before[pluginIdRoot(otherId)])) {\n          break\n        }\n      }\n\n      this.listenerMaps.splice(index, 0, { id: plugin.id, map: plugin.listeners })\n    } else if (plugin.listeners) {\n      this.listenerMaps.push({ id: plugin.id, map: plugin.listeners })\n    }\n\n    return this\n  }\n\n  addDocument(doc: Document, options?: any): void | false {\n    // do nothing if document is already known\n    if (this.getDocIndex(doc) !== -1) {\n      return false\n    }\n\n    const window = win.getWindow(doc)\n\n    options = options ? extend({}, options) : {}\n\n    this.documents.push({ doc, options })\n    this.events.documents.push(doc)\n\n    // don't add an unload event for the main document\n    // so that the page may be cached in browser history\n    if (doc !== this.document) {\n      this.events.add(window, 'unload', this.onWindowUnload)\n    }\n\n    this.fire('scope:add-document', { doc, window, scope: this, options })\n  }\n\n  removeDocument(doc: Document) {\n    const index = this.getDocIndex(doc)\n\n    const window = win.getWindow(doc)\n    const options = this.documents[index].options\n\n    this.events.remove(window, 'unload', this.onWindowUnload)\n\n    this.documents.splice(index, 1)\n    this.events.documents.splice(index, 1)\n\n    this.fire('scope:remove-document', { doc, window, scope: this, options })\n  }\n\n  getDocIndex(doc: Document) {\n    for (let i = 0; i < this.documents.length; i++) {\n      if (this.documents[i].doc === doc) {\n        return i\n      }\n    }\n\n    return -1\n  }\n\n  getDocOptions(doc: Document) {\n    const docIndex = this.getDocIndex(doc)\n\n    return docIndex === -1 ? null : this.documents[docIndex].options\n  }\n\n  now() {\n    return (((this.window as any).Date as typeof Date) || Date).now()\n  }\n}\n\n// Keep Scope class internal, but expose minimal interface to avoid broken types when Scope is stripped out\nexport interface Scope {\n  fire<T extends ListenerName>(name: T, arg: SignalArgs[T]): void | false\n}\n\n/** @internal */\nexport function initScope(scope: Scope, window: Window | typeof globalThis) {\n  scope.isInitialized = true\n\n  if (is.window(window)) {\n    win.init(window)\n  }\n\n  domObjects.init(window)\n  browser.init(window)\n  raf.init(window)\n\n  // @ts-expect-error\n  scope.window = window\n  scope.document = window.document\n\n  scope.usePlugin(interactions)\n  scope.usePlugin(events)\n\n  return scope\n}\n\nfunction pluginIdRoot(id: string) {\n  return id && id.replace(/\\/.*$/, '')\n}\n", "import { Scope } from '@interactjs/core/scope'\n\nconst scope = new Scope()\n\nconst interact = scope.interactStatic\n\nexport default interact\n\nconst _global = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : this\nscope.init(_global)\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;AAAA,IAAIA,WAAW;AACf,IAAIC;AACJ,IAAIC;AAEJ,SAASC,MAAKC,QAAoC;AAChDH,YAAUG,OAAOC;AACjBH,WAASE,OAAOE;AAEhB,MAAI,CAACL,SAAS;AACZ,UAAMM,UAAU,CAAC,MAAM,OAAO,UAAU,GAAG;AAE3C,eAAWC,UAAUD,SAAS;AAC5BN,gBAAUG,OAAQ,GAAEI;AACpBN,eACEE,OAAQ,GAAEI,iCACVJ,OAAQ,GAAEI;IACd;EACF;AAEAP,YAAUA,WAAWA,QAAQQ,KAAKL,MAAM;AACxCF,WAASA,UAAUA,OAAOO,KAAKL,MAAM;AAErC,MAAI,CAACH,SAAS;AACZA,cAAWS,cAAa;AACtB,YAAMC,WAAWC,KAAKC,IAAG;AACzB,YAAMC,aAAaC,KAAKC,IAAI,GAAG,MAAML,WAAWX,SAAS;AACzD,YAAMiB,QAAQb,OAAOc,WAAW,MAAM;AAEpCR,iBAASC,WAAWG,UAAU;SAC7BA,UAAU;AAEbd,iBAAWW,WAAWG;AACtB,aAAOG;;AAGTf,aAAUe,WAAUE,aAAaF,KAAK;EACxC;AACF;AAEA,IAAA,MAAe;EACbhB,SAAUS,cAAmCT,QAAQS,QAAQ;EAC7DR,QAASe,WAAkBf,OAAOe,KAAK;EACvCd,MAAAA;AACF;;;AC3CA,IAAMiB,kBAAkB,CAAC,UAAU,KAAK;AAEzB,SAASC,cAAiBC,MAA2CC,QAAW;AAC7FD,OAAKE,UAALF,KAAKE,QAAU,CAAA;AAEf,aAAWC,QAAQF,QAAQ;AAEzB,QAAIH,gBAAgBM,KAAMC,YAAWF,KAAKG,QAAQD,MAAM,MAAM,CAAC;AAAG;AAElE,QAAI,OAAOL,KAAKG,UAAU,cAAcA,SAAS,SAAS;AACxDI,aAAOC,eAAeR,MAAMG,MAAM;QAChCM,MAAM;AACJ,cAAIN,QAAQH,KAAKE;AAAO,mBAAOF,KAAKE,MAAMC;AAE1C,iBAAQH,KAAKE,MAAMC,QAAQF,OAAOE;;QAEpCO,IAAIC,OAAY;AACdX,eAAKE,MAAMC,QAAQQ;;QAErBC,cAAc;MAChB,CAAC;IACH;EACF;AACA,SAAOZ;AACT;;;ACxBA,IAAA,QAAA,CAAe,GAAU,MAAW,KAAS,KAAK,IAAE,IAAI,IAAI,CAAGa;;;;ACUxD,OAAA,OAASC,KAAUA,QAAwBC,CAAAA;AAChDC,OAAKC,KAAI,IAAGD,IAAKC,KAAI;AACrBD,OAAKC,KAAKC,IAAIH,IAAIE,KAAKC;AACvBF,OAAKC,SAASF,KAAIE,UAAM,CAAA;AAExBD,OAAKG,OAAM,IAAGH,IAAKG,OAAM;AACzBH,OAAKG,OAAOD,IAAIH,IAAII,OAAOD;AAC3BF,OAAKG,YAAWJ,IAAII;AAEpBH;AACF,SAAA,eAAA,WAAA,MAAA,KAAA;AAEO,YAASI,KAAAA,IAAAA,IAAeC,KAAAA,IAA0B,KAAuB,KAAsB;AACpGA,YAAUJ,KAAKC,IAAII,IAAIL,KAAKC,IAAIK,KAAKN,KAAKC;AAC1CG,YAAUJ,OAAM,IAAGK,IAAIL,OAASM,IAAI,KAAK,OAAE;AAC3CF,YAAUF,OAAOD,IAAII,IAAIH,OAAOD,IAAIK,KAAKJ,OAAOD;AAChDG,YAAUF,YAAWG,IAAIH,YAAWI,KAAKJ;;AAE3C,SAAA,iBAAA,WAAA,OAAA;AAEO,QAAA,KAASK,KAAAA,IAAAA,MAAiBH,YAA4BI,KAAwB,IAAA;AACnF,YAAQ,KAAO,IAAI,MAAM,KAACC,IAAAA;AAE1BL,YAAUJ,KAAKC,IAAIO,MAAMR,KAAKC,IAAIS;AAClCN,YAAUJ,OAAM,IAAGQ,MAAMR,OAASU,IAAE;AACpCN,YAAUF,OAAOD,IAAIO,MAAMN,OAAOD,IAAIS;AACtCN,YAAUF,YAAWM;;AAEvB,SAAA,cAAA,WAAA;AAEO,YAASG,KAAAA,IAAAA;AACdP,YAAUJ,KAAKC,IAAI;AACnBG,YAAUJ,OAAM,IAAI;AACpBI,YAAUF,OAAOD,IAAI;AACrBG;AACF,SAAA,gBAAA,SAAA;AAEO,SAASQ,mBAAgBC,WAAc,SAAA,mBAAA,WAAA;;AAI9C,SAAA,MAAA,MAAA,SAAA,IAAA;AACO,OAAA,MAASC,CAAKA;AACnBC,SAAO,QAAiB;AACxBC,KAAAA,IAAOA,QAAQ,OAAM;AAErBD,KAAGd,IAAIY,QAASG,OAAO;AACvBD,SAAOF;AAEP;AACF,SAAA,UAAA,SAAA,MAAA;AAEO,SAASI,QAAAA;IACdjB,GAAI;IAAaC,GAAG;EAAGiB;AAEvB,MAAA,QAAA,iBAAA,gBAAA,OAAA,GAAA;AACA,UAAIC,UAAQC,SAAa,IAAIR;AAC3BE,SAAK,KAAC,OAAUD;AAEhBb,SAAKC,KAAKoB,OAAOC;EACjBtB,OAAKkB;AACN,UAAM,QAAA,SAAA,IAAA;EACLJ;AACF,SAAA;AAEA;AACF,SAAA,YAAA,SAAA,QAAA;AAEO,WAASS,UAAYV,CAAAA;AAC1BX,MAAAA,QAASA,iBAAqB,gBAAA,OAAA,GAAA;AAG5B,UAAA,UAAA,SAAA,MAAA;EACAY,OAAK;AACN,UAAM,UAAA,SAAA,MAAA;EACLA;AACF,SAAA;AAEA;AACF,SAAA,aAAA,SAAA;AAEO,SAASU,GAAAA,OAAAA,QAAaX,SAAqE,IAAA,QAAA,YAAA,QAAA;AAChG;AACF,SAAA,UAAA,MAAA,UAAA,WAAA;AAEO,QAAA,UAAkBY,SAAwBC,SAAiBjB,IAAAA,eAAmB,QAAA,IAAA,SAAA;AACnF,YAAMI,SAAUa,KAAQ,IAACC;AAEzBV,cAAUJ,SAASd,KAAKC,MAAK;AAC7BuB,OAAAA,YAAYV;;AAGd,SAAA,aAAA,OAAA;AAEO,QAAA,UAASe,CAAAA;AAGd,MAAA,GAAA,MAAA,KAAA,GAAA;AACA,YAAOC,KAAMC,MAAQ;AACnBC,YAAQ,KAAKD,MAAM;EACnBC,OAEF;QACK,MAAA,SAAA,YAAA;AACH,UAAID,MAAMd,QAAS,WAAY,GAAA;AAC7B,gBAAUe,KAAAA,MAAQJ,QAAW;AAC3BI,gBAAQ,KAAKD,MAAMC,eAAU;iBACpB,MAAID,QAAME,WAAe,GAAE;AACrC,gBAAM,KAAIF,MAAMC,eAAmB;AAClCA,gBAAQ,KAAKD,MAAME,eAAe;;IAEpC,OAAA;AACD,cAAM,KAAA,MAAA,QAAA;AACLD,cAAQ,KAAKD,MAAMC,QAAQ;;EAE7B;AACF,SAAA;AAEA;AACF,SAAA,eAAA,UAAA;AAEO,QAAA,UAASE;IACd,OAAMC;IACJC,OAAO;IACPC,SAAQ;IACRC,SAAS;IACTC,SAAS;IACTC,SAAS;EACTC;aACD,WAAA,UAAA;AAID,eAAW3B,QAAO,SAAY;AAC5B,cAAK,SAAcqB,QAAO;IACxBA;EACF;AACF,aAAA,QAAA,SAAA;AACA,YAAK,SAAcA,SAAS;EAC1BA;AACF,SAAA;AAEA;AACF,SAAA,UAAA,OAAA;AAEO,MAAA,CAAA,MAASO,QAAUX;AACxB,WAAKA;EACH;AACF,QAAA,UAAA,aAAA,KAAA;AAEA,QAAMC,OAAO,KAAGH,IAAAA,QAAaE,GAAAA,OAAM,QAAA,GAAA,KAAA;AACnC,QAAMY,OAAOC,KAAKC,IAAIb,QAAQ,GAAGI,OAAOJ,QAAQ,GAAGI,KAAK;AACxD,QAAMU,OAAOF,KAAKC,IAAIb,QAAQ,GAAGK,OAAOL,QAAQ,GAAGK,KAAK;AACxD,QAAMU,OAAOH,KAAKI,IAAIhB,QAAQ,GAAGI,OAAOJ,QAAQ,GAAGI,KAAK;AACxD,SAAMa;IAEN,GAAA;IACE/C,GAAGyC;IACHxB,MAAG2B;IACHI,KAAI;IACJC,OAAKL;IACLM,QAAOL;IACPM,OAAM,OAAM;IACZC,QAAOP,OAAOJ;;;AAGlB,SAAA,cAAA,OAAA,aAAA;AAEO,QAAA,UAASY,cAAiDC;AAC/D,QAAMC,UAAWD,cAAc;AAC/B,QAAME,UAAWF,aAAW,KAAkB;AAC9C,QAAMxB,KAAAA,QAAUH,GAAAA,WAAaE,QAAM,GAAA;AAEnC,QAAM4B,KAAK3B,QAAQ,GAAGyB,WAAWzB,QAAQ,GAAGyB;AAC5C,SAAMG,MAAK5B,IAAAA,EAAQ;AAEnB;AACF,SAAA,WAAA,OAAA,aAAA;AAEO,QAAA,UAAS6B,cAA8CL;AAC5D,QAAMC,UAAWD,cAAc;AAC/B,QAAME,UAAWF,aAAW,KAAkB;AAC9C,QAAMxB,KAAAA,QAAUH,GAAAA,WAAaE,QAAM,GAAA;AACnC,QAAM4B,KAAK3B,QAAQ,GAAGyB,WAAWzB,QAAQ,GAAGyB;AAC5C,QAAMG,QAAK5B,MAAS,KAAE0B,MAAQ,IAAG1B,EAAAA,IAAQ,KAAG0B;AAC5C,SAAMI;AAEN;AACF,SAAA,eAAA,SAAA;AAEO,SAASC,GAAAA,OAAAA,QAAejD,WAAuE,IAAA,QAAA,cAAA,GAAA,OAAA,QAAA,WAAA,IAAA,CAAA,QAAA,QAAA,SAAA,OAAA,OAAA,EAAA,QAAA,eAM9F,QAAA,KAAA,QAAA,QAAA,EAAA,KAAA,mBAAA,WAAA,QAAA,UAAA;AACA;AAKR,SAAA,gBAAA,OAAA;AACO,QAAA,OAASkD,GAAAA,KAAAA,MAAgBjC,YAAc,IAAA,MAAA,aAAA,IAAA,MAAA;AAC5C,SAAMkC,CAAAA,iBAAelC,OAAMmC,KAAAA,KAAa,MAC9B,MAACA,GAAAA,iBACmCD,MAAI,aAAA,CAAA;;AAMpD,SAAA,YAAA;AAEO,SAASE;IACd,MAAO;MACLlE,GAAI;MAAIC,GAAG;IAAGiB;YAAM;MACpBhB,GAAAA;MAAUD,GAAG;IAAGiB;eAAM;EACtBT;;;;;AC1MJ,MAAA;AAA+B,QAAA0D,UAAAA,CAAAA;AAC7B,QAAMC,kBAGC,CAAA;AAEP,QAAMC,YAAAA,CAAAA;AAON,QAAMC,gBAA0B;IAEhC;IACEC;IACAC;IAEAC;IACAC;IAEAC;IACAC;IACAP;IACAC;IAEAF,iBAAO;IAEPS,iBAAiB;EACjBC;AAGF,GAAA,kBAAAC,OAAA,aAAA,OAAA,SAAA,gBAAA,cAAA,KAAA,EAAA,iBAAA,QAAA,MAAA;IACAZ,IAAAA,UAAA;AACE,aAAIa,cAAU,kBAAA;IACZ;QACD,UAAA;AACD,aAAIC,cAAU,kBAAA;IACZ;EACF,CAAA;AACF,EAAAF,OAAE,SAAA;AAEFA,WAAMG,IAAM,aAAGC,MAAa,UAAA,aAAA;AAE5B,QAAA,CAAA,YACEC;AAEAC;AAGA,UAAKD,UAAW,WAACE,WAAkB;AAEnC,QAAA,SAAgBC,KAAAA,SAAWC,OAAAA,EAAW,gBAAC,WAAA;AACvC,QAAIC,CAAAA,QAASC;AAEb,eAAW;QACTD;QACEL,QAAAA,CAAAA;MACAF;cACD,KAAA,MAAA;IAEDd;AACF,QAAA,CAAA,OAAA,OAAA,OAAA;AAEA,aAAKqB,OAAOP,QAAY,CAAA;IACtBO;AACF,QAAA,CAAA,KAAA,OAAA,OAAA,OAAA,OAAA,EAAA,SAAA,YAAA,aAAA,EAAA,SAAA,OAAA,CAAA,GAAA;AAEA,kBAAcA,iBAAcE,MAAS,UAAW,cAAa,kBAAmBC,UAASA,QAAS,OAAE;AAClGR,aAAAA,OAAYE,MAAAA,KAAAA;QAKZG,MAAOP;QAAoBW;MAAgBD,CAAAA;IAAQ;EACrD;AACF,WAAA,OAAA,aAAA,MAAA,UAAA,aAAA;AAEA,QAAA,CAAA,YACER,oBAEAC,CAAAA,YACAG;AACA;AACA,UAAKJ,cAAYE,UAAgB,SAAKF,OAAAA,EAAYU,gBAAAA,WAAqB;AAEvE,UAAMC,SAAAA,QAAiB;AACvB,QAAA,CAAA,UAAe3B,CAAAA,OAAQ2B,QAAAA;AAEvB;IACE;AACF,QAAA,SAAA,OAAA;AAEA,WAAIJ,QAAS,OAAO,QAAA;AAClB,YAAKA,OAAQF,OAAOP,eAAQ,IAAA,GAAA;AAC1B,iBAAIO,aAAcO,MAAAA,KAAeL;QAC/BnB;MACF;AACF;IACA;AACF,QAAA,cAAA;AAEA,UAAIyB,gBAAc,OAAK,OAAA;AACvB,QAAA,eAAmB;AAEnB,UAAIC,aAAe,OAAA;AACjB,iBAAIb,IAAQ,cAAY,SAAA,GAAA,KAAA,GAAA,KAAA;AACtB,gBAAK,QAAQa,cAAcC;AACzB,iBAAMC,aAAQF,MAAAA,MAAgB,MAAA,MAAA,OAAA;QAC9B1B;AACF;MACA,OAAA;AACD,cAAM,UAAA,WAAA,WAAA;AACL,iBAAMoB,IAAO,GAAGL,IAAAA,cAAWC,QAAY,KAAA;AAEvC,gBAAK,QAAWa,cAAIH;AAClB,cAAA,MAAME,SAAQF,YAAgB,aAAA,MAAA,SAAA,OAAA,GAAA;AAC9B,wBAAc,oBAAiBI,MAAAA,UAAmBV,cAASA,kBAAU,UAAA,QAAA,OAAA;AACnER,0BAAYU,OAAAA,GAAAA,CAAAA;AAKZI,gBAAAA,cAAcK,WAAY,GAAA;AAE1B,qBAAIL,OAAAA,OAAcC;AAChB,4BAAcjB;YACde;AACF;UAEA;QACF;MACF;IACF;AACF,QAAA,eAAA,CAAA,OAAA,KAAA,OAAA,MAAA,EAAA,QAAA;AAEA,cAAIA,OAAW,aAAYO,CAAI;IAC7BpC;EACF;AACF,WAAA,YAAA,UAAA,SAAA,MAAA,UAAA,aAAA;AAEA,UAAA,UAASK,WACS,WAEhBkB;AAIA,QAAA,CAAA,gBAAgBJ,OAAWC;AAC3B,sBAAKnB,QAAqB,CAAA;AAGxB,iBAAA,OAAA,WAAA;AACA,YAAK,KAAMoC,MAAG,gBAAe;AAC3BlC,YAAIkC,KAAKd,MAAMhB,oBAAiB,IAAA;;IAElC;AACF,UAAA,YAAA,gBAAA;AAEA,QAAA,WAAkBN,KAAAA,WAAgBsB,OAAK,EAAA,aAAA,YAAA,EAAA,YAAA,OAAA;AACvC,QAAIe,CAAAA,UAAWhB;AAEf,iBAAa;QACXgB;QAAaC;QAAUC,WAAO,CAAA;MAAEC;gBAAe,KAAA,QAAA;IAC/CC;AACF,aAAA,UAAA,KAAA;MAEAJ,MAAQ;MAAkBb;IAAgBD,CAAAA;EAAQ;AACpD,WAAA,eAAA,UAAA,SAAA,MAAA,UAAA,aAAA;AAEA,UAAA,UAASlB,WACPiC,WACAC;AAKA,UAAMhB,YAAUL,gBAAWC;AAC3B,QAAA,aAAe;AACf,QAAIuB;AACJ,QAAIC,CAAAA;AAAa;AAIjB,SAAA,QAAA,UAAA,SAAA,GAAA,SAAA,GAAA,SAAA;AACA,YAAKA,MAAQF,UAAUX;AAErB,UAAA,IAAA,aAAA,YAAA,IAAA,YAAA,SAAA;AACA,cAAQQ;UACN;QAAQE,IAAAA;AAER,iBAAA,IAAA,UAAA,SAAA,GAAA,KAAA,GAAA,KAAA;AACA,gBAAK,QAAQA,UAAUV;AAGrB,cAAA,MAAA,SAAA,YAAA,aAAA,MAAA,SAAA,OAAA,GAAA;AAEE,sBAAA,OAAA,GAAA,CAAA;AAIA,gBAAA,CAAA,UAAA,QAAA;AACA,wBAAKU,OAAUV,OAAQ,CAAA;AAGrB,qBAAA,SAAA,MAAA,gBAAA;AACA3B,qBAAOoC,SAASjB,MAAMhB,oBAAiB,IAAA;;AAIzC,yBAAA;AACAoC;UACA;QACF;AACF,YAAA,YAAA;AAEA;QACE;MACF;IACF;EACF;AAIF,WAAA,iBAAA,OAAA,aAAA;AACA,UAAA,UAASpC,WAAiBsC,WAA0BzB;AAClD,UAAMI,YAAUL,IAAAA,UAAWC,KAAAA;AAC3B,UAAM0B,YAAY,gBAAcD,MAAe;AAC/C,UAAMH,CAAAA,WAAYzC,IAAgB4C,gBAAW,KAAA;AAC7C,QAAA,UAAO7B;AAGP,WAAA,GAAA,QAAA,OAAA,GAAA;AACA,eAAU+B,IAAAA,GAAQA,IAAAA,UAAU,QAAA,KAAA;AAC1B,cAAK,MAAS,UAAML;AAClB,cAAMM;UACN;UAAQT;QAAUC,IAAAA;AAAQ,YAAO,gBAAA,SAAA,QAAA,KAAA,aAAA,SAAA,WAAA,KAAA,aAAA,SAAA,OAAA,GAAA;AAEjC,gBACES;YAIA;UAAQR,IAAAA;AAAU,oBAAO,gBAAA;AAEzBK,qBAAUI,SAAAA,WAAgBH;AAE1B,gBAAK,aAAW,MAAIN,SAAW,OAAA,GAAA;AAC7B,oBAAIP,KAAAA,SAAkB;YACpBF;UACF;QACF;MACF;AACF,gBAAA,WAAA,OAAA;IAEAe;EACF;AACF,WAAA,mBAAA,OAAA;AAEA,WAASvC,iBAAAA,KAAkCqC,MAA0B,OAAA,IAAA;;AAIrE,SAAA;AACA;AACF,IAAA,YAAA,MAAA;EAEA,YAAMM,eAAoC;AACxCD,SAAAA,gBAAa;AACbE,SAAAA,gBAAa;AACb7B,SAAI,OAAA;AAEJ8B,SAAAA,gBAAYD;AAEV,kBAAA,MAAA,aAAA;EACAE;EACF,yBAAA;AAEAC,SAAAA,cAAAA,eAAyB;EACvB;EACF,kBAAA;AAEAC,SAAAA,cAAkB,gBAAA;EAChB;EACF,2BAAA;AAEAC,SAAAA,cAAAA,yBAA2B;EACzB;AACF;AACF,SAAA,WAAA,OAAA;AAEA,MAAA,CAAA,GAAStC,OAAAA,KAAWuC,GAAyC;AAC3D,WAAQC;MACN,SAAO,CAAA,CAAA;MAAE/C,SAAS;IAASC;;AAC7B,SAAA;IAEA,SAAO,CAAA,CAAA,MAAA;IACLD,SAAS,CAAC,CAAC8C,MAAM9C;EACjBC;;AAEJ,SAAA,aAAA,GAAA,GAAA;AAEA,MAAA,MAASqB;AAAAA,WAAa0B;AACpB,MAAIA,OAAO,MAAE;AAAW,WAAA,CAAA,CAAA,EAAA,YAAA,KAAA,CAAA,CAAA,EAAA,YAAA;AAExB,SAAI,CAAA,CAAA,EAAOA,YAAM,CAAA,CAAA,EAAS,WAAY,CAAChD,CAAAA,EAAAA,YAAa,CAAA,CAAI,EAAEiD;;AAG5D,IAAA,SAAA;EAEA,IAAA;EACEC;AACAC;;;;ACrTF,MAAMC,wBAAiB,KAASA,QAAAA,GAAcA;AAC5C,SAAI,QAAA,iBAA4B;AAC9B,WAAKC;EACL;AACF,MAAA,GAAA,KAAA,QAAA,GAAA;AAEA,SAAOC,QAAKC,iBAAW,WAAA,WAAA;AACrB,WAAKF;EACL;AACF,SAAA,KAAA,QAAA;AAEA;AACF,SAAmC,uBAAA,cAAAG,QAAA,OAAA;AAEnC,QAAA,UAASC,aAAsBA,QAACC;AAC9B,MAAA,YAAgBA;AAAAA;AAEhB,MAAIC,YAAY,UAAS;AAEzB,UAAIA,eAAY;AACdC;EACA;AAOF,MAAAJ,OAAA,OAAA,mBAAA,sBAAA,KAAA,MAAA,IAAA,GAAA;AACA,UAAIA,MAAMK,UAAOC,MAAAA,MAAmB,EAAA;AAClC,UAAMC,aAAMC,OAAUJ,cAAcK,GAAAA;AACpC,QAAA,EAAMC,cAAaV,WAAMW,WAAiB,WAAC,OAAA,YAAA,OAAA;AAE3C;IACE;EACF;AAGF,MAAA,uCAAA,KAAA,MAAA,IAAA,GAAA;AACA;EACE;AAGF,MAAA,GAAA,QAAA,MAAA,MAAA,KAAA,gBAAA,MAAA,QAAA,uEAAA,GAAA;AACA;EAIE;AACF,QAAA,eAAA;;AAGF,SAAA,mBAAA,MAAA;AAEA,MAAA;IAA2G;IAA7EC;EAAaR,IAAAA;AAA6D,MAACS,YAAA,cAAA;AACvG,gBAAID,aAAYV,uBAAc,KAAA;EAC5BU;AACF;AACF,SAAAE,SAAAd,QAAA;AAEO,QAAA;IACL,cAAAe;EAAQA,IAAAA;AAAa,EAAAA,cAAS,UAAA,iBAAA;AAE9BA,EAAAA,cAAaC,UAAUpB,yBAAiBA,SAAc,OAAA;AAEtDmB,WAAAA,uBAAuBd,MAAAA,QAAsB,KAAG;EAC9C;AAGF,EAAAD,OAAA,aAAA,UAAA,KAAA;IACAA,MAAMiB;IACJC,SAAM,OAAA;AACNC,iBAASf,eAAOJ,OAAA,aAAA,MAAA;AACd,YAAK,YAAMY,YAAeZ,YAAMiB,YAAmB,MAAA,UAAA,aAAA,YAAA,SAAA,MAAA,MAAA,IAAA;AACjD,sBACEL,aAAmB,uBACC,KAAKR;AAEzBQ;QACA;MACF;IACF;EACF,CAAA;AACF;AACF,IAAA,6BAAA;EAEA,IAAA;EACEQ,SAAAA;EACAN,WAAO,CAAA,QAAA,QAAA,MAAA,QAAA,EAAA,OAAA,CAAA,KAAA,cAAA;AACPO,QAAAA,gBAAoB,eAAc;AAChCC,WAAoBC;EACpB,GAAA,CAAA,CAAA;;;;;ACrHG,MAAA,SAASC;AACd,SAAIC,WAAc;AAElB,QAAA,CAAO,QAAA;AACL,UAAKA,QAAQ,KAAA,OAAA;AACTC,eAAeC;IACjBF;AACF,WAAA,OAAA,MAAA,MAAA,SAAA;EAEA;;AAEJ,SAAA,WAAA,MAAA,KAAA;AAEO,OAAA,OAASG,IAAAA;AACdC,OAAKC,OAAOC,IAAID;AAChBD,OAAKG,QAAOD,IAAIC;AAChBH,SAAKI;AAEL;;;;ACRK,MAAA,UAASC,UAAAA;AACd,WAAS,WAAK,OAAU;;AAExB,MAAA,UAAA,QAAA;AAEA,WAAS,OAAK,QAAQ,OAAA;EACpB;AACF,SAAA,QAAA,SAAA,KAAA;AAEA;AACF,SAAA,gBAAA,OAAA,QAAA,SAAA,cAAA;AAEO,MAAA,cAASC;AAMd,MAAIC,GAAAA,OAAAA,WAAwB,GAAA;AAC5B,kBAAcA,sBAAc,aAAA,QAAA,OAAA;aAC1BA,GAAW,KAAGF,WAAAA,GAAAA;AACf,kBAAaG,YAAKD,GAAY,YAAE;EAC/BA;AACF,MAAA,GAAA,QAAA,WAAA,GAAA;AAEA,kBAAeA,eAAc,WAAA;EAC3BA;AACF,SAAA;AAEA;AASF,SAAA,SAAA,MAAA;AAEO,SAASE,QAAQA;IACtB,GAAA,OACM,OAAI,KAAA,IAAA,KAAA;IACNC,GAAG,OAAOC,OAAOA,KAAKD,IAAIC,KAAKC;;;AAIrC,SAAA,WAAA,MAAA;AAEO,MAAA,QAASC,EAAAA,UAAqD,QAAA,SAAA,OAAA;AACnE,WAAQ,OAAM,CAAA,GAAM,IAAIF;AACtBA,SAAI,OAAGG,KAAS,KAAM;AAEtBH,SAAKC,MAAI,KAAO,KAAE;AAClBD,SAAKI,QAAMJ,KAAM,SAAK,KAAA,OAAA,KAAA;AACtBA,SAAKK,SAAQL,KAAKK,UAASL,KAAKC,MAAOD,KAAKM;EAC5CN;AACF,SAAA;AAEA;AACF,SAAA,WAAA,MAAA;AAEO,MAAA,QAASO,EAAAA,OAAWP,QAA6B,OAAA,OAAA;AACtD,WAAQ,OAAM,CAAG,GAAA,IAAIA;AACnBA,SAAI,IAAGG,KAAO,QAAQ;AAEtBH,SAAKD,IAAIC,KAAKC,OAAI;AAClBD,SAAKQ,QAAQ,KAAI,UAAK,KAAA,SAAA,KAAA,KAAA;AACtBR,SAAKM,SAAQN,KAAKM,WAAUN,KAAKK,UAAU,KAAIL,KAAM;EACrDA;AACF,SAAA;AAEA;AACF,SAAA,SAAA,OAAA,MAAA,OAAA;AAEO,MAAA,MAASS,MAASC;AACvB,SAAIA,QAAU,MAAE;EACdV;AACF,MAAA,MAAA,OAAA;AACA,SAAIU,SAAW,MAAE;EACfV;AACF,MAAA,MAAA,KAAA;AACA,SAAIU,OAAS,MAAE;EACbV;AACF,MAAA,MAAA,QAAA;AACA,SAAIU,UAAY,MAAE;EAChBV;AACF,OAAA,QAAA,KAAA,QAAA,KAAA;AAEAA,OAAKM,SAAQN,KAAKK,SAAQL,KAAKC;;;;;AClGlB,QAAA,gBACbU,cAEAC,OAAAA,QACA;AACA,QAAMC,eAAa,iBAAkBF,cAAuBC;AAC5D,QAAME,SAAAA,gBAAeD,OAAiBA,QAAAA;AACtC,QAAME,aAASD,gBAAgBH,QAAOK,QAAQD,SAAM,CAAA,UAAA,OAAA,CAAA;AAEpD,SAAME,SAAU,UAAGC,KAAAA;IAEnB,GAAA;IAAiCC,GAAG;EAAGC;;;;ACZlC,IAAMC,YAAN,MAAqD;EAK1D,YAAA,aAAA;AAGAC,SAAAA,8BAAmC;AACnCC,SAAAA,qBAA0B;AAE1BC,SAAAA,eAAYC;;EAEZ,iBAAA;EAAA;EAMF,kBAAA;AACEC,SAAAA,qBAAkB;;EAMpB,2BAAA;AACEC,SAAAA,8BAA2B,KAAA,qBAAA;EACzB;AACF;AAUF,OAAA,eAAA,UAAA,WAAA,eAAA;EACAC,MAAOC;AACLC,WAAqB,KAAA,aAAA;EACnB;QACD;EAAA;;;;ACdI,IAAMC,WAAqB;EAChCC,MAAM;IACJC,gBAAgB;IAChBC,aAAa;;EAGfC,WAAW;IACTC,SAAS;IACTC,QAAQ;MAAEC,GAAG;MAAGC,GAAG;IAAE;;EAGvBC,SAAS,CAAA;AACX;;;ACXO,IAAMC,gBAAN,cAGGC,UAAa;EAGrBC,YAAAA,aAAoC,OAAA,YAAA,OAAA,SAAA,QAAA,MAAA;AACpCC,UAAO,WAAA;AACPC,SAAO,gBAAA;AACPC,SAAM,UAAA;AACNC,SAAO,UAAA;AACPC,SAAO,SAAA;AACPC,SAAAA,UAAQ;AACRC,SAAM,UAAA;AACNC,SAAO,WAAA;AACPC,SAAI,SAAA;AACJC,SAAM,UAAA;AACNC,SAAK,OAAA;AACLC,SAAI,SAAA;AACF,SAAA,QAAA;AACA,SAAA,OAAA;AACA,SAAA,KAAA;AACA,SAAA,KAAA;AACFC,SAAAA,KAAQ;AACRC,SAAAA,KAAQ;AACRC,SAAAA,WAAQ;AACRC,SAAAA,WAAQ;AACRC,SAAK,WAAA;AACLC,SAAK,WAAA;AACL,SAAA,QAAA;AACAC,SAAI,QAAA;AAEJC,SAAM,OAAA;AAWJ,SAAK,SAACC;AAENC,cAAUA,WAAWD,YAAYC;AAEjC,UAAMC,SAASF,YAAYG;AAC3B,UAAMC,eAAiBF,UAAUA,OAAOG,WAAYC,UAAkBF;AACtE,UAAMG,SAASC,YAAYN,QAAQD,SAASQ,UAAU;AACtD,UAAMC,WAAWC,UAAU;AAC3B,UAAMC,SAASD,UAAU;AACzB,UAAME,YAAYH,WAAW,OAAOV,YAAYa;AAChD,UAAMC,SAASJ,WACXV,YAAYc,OAAOC,QACnBH,SACE;MAAExB,MAAMyB,UAAUzB;MAAMC,QAAQwB,UAAUxB;MAAQ2B,WAAWhB,YAAYc,OAAOG,IAAID;IAAU,IAC9FhB,YAAYc,OAAOG;AAEzB,SAAK7B,OAAO8B,OAAO,CAAA,GAAIJ,OAAO1B,IAAI;AAClC,SAAKC,SAAS6B,OAAO,CAAA,GAAIJ,OAAOzB,MAAM;AACtC,SAAKE,OAAO2B,OAAO,CAAA,GAAIlB,YAAYT,IAAI;AACvC,SAAKyB,YAAYF,OAAOE;AAExB,QAAI,CAACJ,QAAQ;AACX,WAAKxB,KAAK+B,KAAKZ,OAAOY;AACtB,WAAK/B,KAAKgC,KAAKb,OAAOa;AAEtB,WAAK/B,OAAO8B,KAAKZ,OAAOY;AACxB,WAAK9B,OAAO+B,KAAKb,OAAOa;IAC1B;AAEA,SAAKpC,UAAUqC,MAAMrC;AACrB,SAAKE,SAASmC,MAAMnC;AACpB,SAAKD,WAAWoC,MAAMpC;AACtB,SAAKE,UAAUkC,MAAMlC;AACrB,SAAKL,SAAUuC,MAAqBvC;AACpC,SAAKC,UAAWsC,MAAqBtC;AACrC,SAAKmB,SAASD;AACd,SAAKqB,gBAAgBrB;AACrB,SAAKF,SAASA;AACd,SAAKwB,OAAOA,QAAQd,cAAcE,SAAS;AAC3C,SAAKR,eAAeD;AAEpB,SAAKsB,KAAKd,WAAWV,YAAYyB,SAASzB,YAAYyB,SAASC,SAAS,GAAGC,WAAWd,UAAUW;AAEhG,SAAKI,KAAK5B,YAAYc,OAAOC,MAAM3B,KAAK+B,IAAIZ,OAAOY;AACnD,SAAKU,KAAK7B,YAAYc,OAAOC,MAAM3B,KAAKgC,IAAIb,OAAOa;AACnD,SAAK3B,WAAWO,YAAYc,OAAOC,MAAM1B,OAAO8B,IAAIZ,OAAOY;AAC3D,SAAKzB,WAAWM,YAAYc,OAAOC,MAAM1B,OAAO+B,IAAIb,OAAOa;AAE3D,QAAIV,YAAYE,QAAQ;AACtB,WAAKtB,QAAQ;QAAE6B,GAAG;QAAGC,GAAG;;IAC1B,OAAO;AACL,WAAK9B,QAAQ;QACX6B,GAAG,KAAKf,aAAae,IAAIN,UAAUT,aAAae;QAChDC,GAAG,KAAKhB,aAAagB,IAAIP,UAAUT,aAAagB;;IAEpD;AAEA,SAAKU,KAAK9B,YAAYc,OAAOxB,MAAM0B;AACnC,SAAKxB,WAAW,KAAKwB,YAAY,KAAKQ;AAGtC,SAAK7B,WAAWuB,OAAO,CAAA,GAAIlB,YAAYc,OAAOnB,SAASS,YAAY;AACnE,SAAKR,QAAQmC,MAAM,KAAKpC,SAASwB,GAAG,KAAKxB,SAASyB,CAAC;AAEnD,SAAKvB,QAAQe,UAAUD,UAAU,iBAAiB,KAAKqB,SAAQ,IAAK;EACtE;EAEAA,WAAW;AACT,UAAMhC,cAAc,KAAKiC;AAEzB,QAAIjC,YAAYa,UAAUjB,QAAQ,OAAO,KAAKoB,YAAYhB,YAAYa,UAAUG,YAAY,KAAK;AAC/F,aAAO;IACT;AAEA,QAAIkB,QAAS,MAAMC,KAAKC,MAAMpC,YAAYa,UAAUwB,WAAWrC,YAAYa,UAAUyB,SAAS,IAAKH,KAAKI;AACxG,UAAMC,UAAU;AAEhB,QAAIN,QAAQ,GAAG;AACbA,eAAS;IACX;AAEA,UAAMO,OAAO,MAAMD,WAAWN,SAASA,QAAQ,MAAMM;AACrD,UAAME,KAAK,MAAMF,WAAWN,SAASA,QAAQ,MAAMM;AAEnD,UAAMG,QAAQ,CAACF,SAAS,MAAMD,WAAWN,SAASA,QAAQ,KAAKM;AAC/D,UAAMI,OAAO,CAACF,MAAM,KAAKF,WAAWN,SAASA,QAAQ,MAAMM;AAE3D,WAAO;MACLE;MACAE;MACAH;MACAE;MACAT;MACAtC,OAAOI,YAAYa,UAAUjB;MAC7BD,UAAU;QACRwB,GAAGnB,YAAYa,UAAUyB;QACzBlB,GAAGpB,YAAYa,UAAUwB;MAC3B;;EAEJ;EAEAQ,iBAAiB;EAAA;EAKjBC,2BAA2B;AACzB,SAAKC,8BAA8B,KAAKC,qBAAqB;EAC/D;EAKAC,kBAAkB;AAChB,SAAKD,qBAAqB;EAC5B;AACF;AAIAE,OAAOC,iBAAiB1E,cAAc2E,WAAW;EAC/CC,OAAO;IACLC,MAAM;AACJ,aAAO,KAAKlE,KAAK+B;;IAEnBoC,IAAIC,OAAO;AACT,WAAKpE,KAAK+B,IAAIqC;IAChB;;EAEFC,OAAO;IACLH,MAAM;AACJ,aAAO,KAAKlE,KAAKgC;;IAEnBmC,IAAIC,OAAO;AACT,WAAKpE,KAAKgC,IAAIoC;IAChB;;EAGFE,SAAS;IACPJ,MAAM;AACJ,aAAO,KAAKjE,OAAO8B;;IAErBoC,IAAIC,OAAO;AACT,WAAKnE,OAAO8B,IAAIqC;IAClB;;EAEFG,SAAS;IACPL,MAAM;AACJ,aAAO,KAAKjE,OAAO+B;;IAErBmC,IAAIC,OAAO;AACT,WAAKnE,OAAO+B,IAAIoC;IAClB;;EAGFI,IAAI;IACFN,MAAM;AACJ,aAAO,KAAKhE,MAAM6B;;IAEpBoC,IAAIC,OAAO;AACT,WAAKlE,MAAM6B,IAAIqC;IACjB;;EAEFK,IAAI;IACFP,MAAM;AACJ,aAAO,KAAKhE,MAAM8B;;IAEpBmC,IAAIC,OAAO;AACT,WAAKlE,MAAM8B,IAAIoC;IACjB;;EAGFlB,WAAW;IACTgB,MAAM;AACJ,aAAO,KAAK3D,SAASwB;;IAEvBoC,IAAIC,OAAO;AACT,WAAK7D,SAASwB,IAAIqC;IACpB;;EAEFnB,WAAW;IACTiB,MAAM;AACJ,aAAO,KAAK3D,SAASyB;;IAEvBmC,IAAIC,OAAO;AACT,WAAK7D,SAASyB,IAAIoC;IACpB;EACF;AACF,CAAC;;;ACvQM,IAAMM,cAAN,MAAkB;EACvBC,YAAE,IAAA,SAAA,OAAA,UAAA,YAAA;AACFC,SAAO,KAAA;AACPC,SAAK,UAAA;AACLC,SAAAA,QAAQ;AACRC,SAAAA,WAAU;AAEVC,SAAAA,aAAwBJ;AACtB,SAAKD,KAAKA;AACV,SAAKC,UAAUA;AACf,SAAKC,QAAQA;AACb,SAAKC,WAAWA;AAChB,SAAKC,aAAaA;EACpB;AACF;;;;ACSYE,EAAAA,cAAAA,kBAAY;AAAZA,EAAAA,cAAY,aAAA;AAAZA,EAAAA,cAAY,cAAA;AAAZA,EAAAA,cAAY,mBAAA;AAAZA,EAAAA,cAAY,qBAAA;AAAZA,EAAAA,cAAY,YAAA;AAAZA,SAAAA;AAAY,EAAA,CAAA,CAAA;AAAA,IAAA,gBAAA,SAAAC,gBAAA;AASZA,EAAAA,eAAAA,WAAa;AAAbA,EAAAA,eAAa,UAAA;AAAbA,EAAAA,eAAa,SAAA;AAAbA,EAAAA,eAAa,UAAA;AAAbA,EAAAA,eAAa,iBAAA;AAAbA,SAAAA;AAAa,EAAA,CAAA,CAAA;AAAA,IAAA,YAAA;AAuEzB,IAAIC,cAAJ,MAAiB;EAGf,IAAA,uBAAA;AACAC,WAAAA;;EAEA,YAAA,MAAA;AAEAC,SAAwB,eAAI;AAE5BC,SAAM,UAAA;AAMN,SAAA,OAAA;;AAIAC,SAAAA,QAAU;AAEV,SAAA,aAAA;AAEEC,SAAI,WAAM;MACVC,MAAM;MACNC,MAAO;MACR,OAAA;IAEDC;;AAGAC,SAAAA,WAA4B,CAAA;AAE5B,SAAA,YAAA;;AAGiBC,SAAAA,iBAA6B;;MAE9C,OAAA;MACAC,aAII;IACFC;AAEAC,SAAAA,YAAa;AACd,SAAA,gBAAA;;AAEgBC,SAAAA,eAA8C;AAG/DC,SAAAA,UAAe;AACEC,SAAAA,WAAe;AACfC,SAAO,SAAQ;AACfC,SAAAA,aAAe;AAChC,SAAA,SAAA,SAAA,SAAA,WAAA;AAAiBC,WAAM,KAAA,SAAA;;AAEvB,SAAA,SAAA;;MAEqBC,MAAAA,UAAuB;MAE5C,KAAA,UAAA;MAGE,OAAoB,UAAA;MAGtBC,UAAoB,UAAA;IAClB;AAEA,SAAA,MAAA;AACAC,QAAI;MACJ;MACAC;IACA,IAAA;AACAC,SAAK,aAAEC;AACP,SAAA,cAAA;AACAC,UAAAA,OAAUD;AACX,SAAA,SAAA,CAAA;;AAED,aAAA,eAAA,KAAA,QAAA,KAAA;QAAwCzB,MAAAA;AAExC2B,iBAAWC,KAAiF;QAAhF;MAAEpB,CAAAA;IAAaqB;AAA8D,eAAC,OAAA,eAAA;AACxF,aAAKzB,eAAayB,KAAS,QAAA,KAAA;QACvB,OAACrB,WAAcA;AAEbsB,iBAAO,KAAI,KAAA,GAAA,SAAA;QAEb;MAEJ,CAAA;;AAEIC,SAAAA,WAAM,oBAAA;mBACGD;IACT,CAAA;EACF;EACF,YAAA,SAAA,OAAA,aAAA;AAEA,UAAK,eAAa/B,KAAAA,cAAe,SAAA,OAAA,aAAA,IAAA;UAC/BiC,cAAOC,KAAe,SAAKd;SACzBe,WAAO,qBAAA;MAAA;MAAsC;MAC/C;MACF;MAEA;MAAsCC,MAAAA;MAAoB,aAAA;IAC5D,CAAA;EAEAC;EAkCF,MAAA,QAAA,cAAA,SAAA;AACA,QAAA,KAAA,YAAA,KAAA,CAAA,KAAA,iBAAA,KAAA,SAAA,UAAA,OAAA,SAAA,YAAA,IAAA,MAAA,CAAA,aAAA,QAAA,OAAA,MAAA,SAAA;AACA,aAAA;IACA;AACA,eAAA,KAAA,UAAA,MAAA;AACA,SAAA,eAAA;AACA,SAAA,UAAA;AACA,SAAA,OAAA,aAAA,QAAA,OAAA;AACA,SAAA,QAAA,KAAA,SAAA,QAAA,OAAA,CAAA,GAAA,KAAA,SAAA,KAAA,IAAA;MACA,MAAA;MACA,OAAA;MACA,KAAA;MACEC,QAAkD;IAChD;AAME,SAAA,WAAY;AACd,SAAA,eAAA,KAAA,SAAA;MAEAC,aAAe;MAEf,OAAKrC,KAAAA;MACL,OAAKsC;IACL,CAAA,KAAKrC,CAAAA,KAAOD;AACZ,WAAKM,KAAK;EAEJiC;EAAYC,YAAO,SAAI,OAAA,aAAA;AAAEC,QAAAA,CAAG,KAAE,cAAI,EAAA,KAAA,gBAAA,KAAA,aAAA,YAAA;AAAEC,WAAAA,cAAQ,SAAA,OAAA,aAAA,KAAA;;AAClD,UAAKzB,gBAAgB,KAAA,OAAA,IAAA,KAAA,MAAA,KAAA,OAAA,KAAA,KAAA,KAAA,KAAA,OAAA,IAAA,KAAA,MAAA,KAAA,OAAA,KAAA,KAAA,KAAA,KAAA,OAAA,IAAA,OAAA,MAAA,KAAA,OAAA,KAAA,OAAA,KAAA,KAAA,OAAA,IAAA,OAAA,MAAA,KAAA,OAAA,KAAA,OAAA;AACrB,QAAI;AAEAiB,QAAAA;AAGF,QAAE,KAAK,iBAAa,CAAA,KAAA,iBAAA;AAEtB,WAAO,KAAKnB,OAAAA,IAAAA,OAAY,IAAA,KAAA,OAAA,MAAA,OAAA;AAC1B,WAAA,KAAA,OAAA,IAAA,OAAA,IAAA,KAAA,OAAA,MAAA,OAAA;AAEA4B,WAAAA,kBAAyD,MAAE/B,IAAAA,EAAiB,IAAE,KAAA;IAC5E;UACM,eAAeD,KAAAA,gBAAgBC,OAAW;AAChD,UAAA,YAAA;MAEA;MAMA;MACA,aAAc,KAAA,SAAA;;MAEd,MAAA;MACA;MACEgC;MACAC;MAEA,WAAK/B;MACP,aAAA;IAEA;AACA,QAAA,CAAA,eAAkB;AAEhBgC,MAAY,iBAAA,KAAA,OAAA,UAAA,KAAA,OAAA,KAAA;IACZC;SACAC,WAAK,qBAAA,SAAA;AACLC,QAAAA,CAAAA,iBAAqB,CAAA,KAAA,YAAA;AAErBL,UAAE,KAAA,YAAA,GAAA;AACA,kBAAA,OAAA;AACFM,aAAAA,KAAWC,SAAAA;MACXjB;AACD,UAAA,KAAA,iBAAA;AAEG,QAACiB,WAAe,KAAA,OAAA,MAAA,KAAA,OAAA,GAAA;MAClB;IACA3B;EACF;EAuBJ,KAAA,WAAA;AACA,QAAA,CAAA,aAAA,CAAA,UAAA,OAAA;AACA,MAAA,cAAA,KAAA,OAAA,KAAA;IACA;AACA,gBAAA,OAAA;MACA,SAAA,KAAA,eAAA;MACA,OAAA,KAAA,eAAA;MACA,aAAA,KAAA,eAAA;MACA,aAAA;IACA,GAAA,aAAA,CAAA,CAAA;AACA,cAAA,QAAA;AACA,SAAA,SAAA,SAAA;EACE4B;EAQMJ,UAAK,SAAOtC,OAAAA,aAAoB,gBAAA;AAChCE,QAAAA,eAAiB,KAACF,gBAAeE,OAAW;AAC5CsB,QAAAA,iBAAa,IAAA;AACd,qBACY,KACd,cAAA,SAAA,OAAA,aAAA,KAAA;IAEDmB;AAEA,UAAKC,OAAQ,WAAW,KAAA,MAAA,IAAA,IAAA,WAAA;AAC1B,SAAA,WAAA,gBAAA,QAAA;;MAEA;MACF,aAAA,KAAA,SAAA;MACA;MACA;MACEC;MACE;MAEA,aAAIT;IACFA,CAAAA;AACF,QAAA,CAAA,KAAA,YAAA;AAEA,WAAMG,IAAI,KAAG;IAEb;SACEtC,cAAO,SAAA,KAAA;;eAIPC,OAAW;AACXqC,SAAAA,IAAMA,KAAW;SACjBO,WAAc,qBAAA;MACdtB;MACA,MAAA;MAEF,aAAUuB;IACR,CAAA;EACF;EAiBJ,IAAA,OAAA;AACA,SAAA,UAAA;AACA,YAAA,SAAA,KAAA,eAAA;AACA,QAAA;AACA,QAAA,KAAA,YAAA,GAAA;AACA,uBAAA,KAAA,SAAA;QACA;QACA,aAAA;QACA,OAAA;MACA,CAAA;IACA;AACA,SAAA,UAAA;AACEC,QAAIV,mBAA0B,MAAA;AAC5B,WAAKhC,KAAO;IACZgC;EACA;EAEA,gBAASW;AACPC,WAAAA,KAAAA,eAAsBN,KAAQ,SAAC,OAAA;;EAE7BpB,cAAAA;AACA2B,WAAAA,KAAO;EACT;EACF,OAAA;AAEA,SAAK7C,WAAU,qBAAK;MAEpB,aAAI4C;;AAEJ,SAAA,eAAA,KAAA,UAAA;AACF,SAAA,eAAA;AAEAE,SAAAA,WAAgB;AACd,SAAA,SAAY/C,OAAAA,KAAY,YAAQgD;EAClC;EAIA,gBAAA,SAAA;AAEAC,UAAO,YAAA,aAAA,OAAA;AACoD,WAAE,KAAA,gBAAA,WAAA,KAAA,gBAAA,QAAA,KAAA,SAAA,SAAA,IAAA,UAAA,KAAA,UAAA,gBAAA,WAAA,OAAA,SAAA;EAE3D;iBAIa,SAAQ;AACvB,WAAA,KAAA,SAAA,KAAA,gBAAA,OAAA;;EAIE,cAAMC,SAAYzC,OAAAA,aAAa0C,MAAavD;;AAE5C,QAAA,eAAA,KAAA,gBAAA,OAAA;AACA,QAAA,cAAYJ,KAAW,SAAK;AAG9B,WAAA,SAAA,QAAA,QAAA,QAAA,iBAAA,KAAA,MAAA,IAAA;;AAEA,oBAAA,IAAA,YAAA,IAAA,SAAA,OAAA,MAAA,IAAA;AACA4D,qBAAexD,KAAc,SAAA;AAC3B,WAAO,SAAKH,KAAS,WAAK4D;IAC5B,OAAA;;IAEA;AACAC,IAAc1D,UAAsBqC,KAAyBpC,OAAAA,KAAiB,KAAgB,SAAE,IAAA,OAAA,EAAA,OAAA,GAAA,KAAA,KAAA,CAAA;AAC9F,IAAWY,eAAa0C,KAAAA,OAAavD,OAAQ,KAAA,OAAA,MAAA,KAAA,OAAA,GAAA;AAC7C,QAAImC,MAAAA;AACJ,WAAIC,gBAAmBvC;AAEvB8D,kBAAW,WAAa,KAAK,OAAO,IAAI;AAExC,kBAAKvB,aAAa;AAChBA,MAAW,cAAOwB,KAAc,aAAWvB,OAAO;AAElDF,UAAAA,CAAAA,KAAAA,YAAoBtC,GAAAA;AACpB,QAAcgE,WAAKzB,KAAY,OAAA,OAAA,KAAA,OAAA,GAAA;AAChC,QAAM,WAAA,KAAA,OAAA,MAAA,KAAA,OAAA,GAAA;AACLA,aAAAA,YAAmB;AACrB,aAAA,kBAAA;MAEAvB;IAKAA;AAEA,SAAI8C,qBAAM,SAAA,OAAA,WAAA;SACR,WAAKG,+BAAoB;MAEzB1B;MACAA;MACAvB;MAEA;MACEA;MACAA;mBAEKkD;;AAEP,WAAA;EACF;gBAKS,SAAA,OAAA;UACP1B,eAAK,KAAA,gBAAA,OAAA;QACLpC,iBAAW;AAAA;UACP,cAAA,KAAA,SAAA;SACJmC,WAAW,+BAAA;MACXD;MACAZ;MACA,aAAA;MAEF;MACF;;IAEA,CAAA;AACAyC,SAAAA,SAAchE,OAAsBqC,cAAyB,CAAA;AAC3D,SAAA,gBAAqB;EAErB;uBAKS,SAAA,OAAA,aAAA;SACPA,eAAK,UAAA;AACLpC,SAAAA,eAAiB,QAAA;SACjBkC,eAAY,cAAA;;EAEZZ,UAAAA;AACF,SAAE,eAAA,UAAA;AAEF,SAAK1B,eAAe,QAACsC;AACrB,SAAK2B,eAAa,cAAQ;EAC5B;EAGAG,qBAAqBjE,OAAoB,OAAyB,QAAEC,MAAiB;AACnF,WAAKF,IAAAA,cAAeC,MAAUA,OAAO,KAAA,SAAA,MAAA,OAAA,KAAA,SAAA,QAAA,IAAA;EACrC;EAIFkE,WAAU,QAAA;AACR,QAAI;AACJ,KAAA,qBAAoB7B,KAAK,iBAAO,OAAA,SAAA,mBAAA,KAAA,MAAA;AAChC,QAAI,CAACtC,KAAAA,aAAeE,OAAAA,aAAkB,KAAA,UAAA,WAAA;AACxC,WAAA,YAAA;;EAEA;EAQA,SAAA,WAAA;;MAEA;MACAkE;MAA8D;MAC5DC;IAEA,IAAI;UACE;MACN;IACF,IAAA;;AAGAzB,MACED,SACA,KAAA,OAAA,MAAA,KAAA,OAAA,MAAA,KAAA,aAAA,QAAA,YAAA;AACA,WAAM,QAAA,KAAA,QAAA,KAAA;AAAEL,WAAK,SAAA,KAAA,SAAA,KAAA;;UAASgC,eAAM,KAAA,WAAA,8BAAA,SAAA,SAAA;AAAE/B,QAAAA,iBAAAA,OAAAA;AAAM,aAAGI;IACvC;AAAQpD,UAAAA,SAAAA,UAAAA,SAAAA,KAAAA,qBAAAA,OAAAA,OAAAA,QAAAA,IAAAA;AAAK,SAAI,WAAI,uBAAA,SAAA,SAAA;AAErB,QAAIA,UAAQ4D,SAAU;AACpB,WAAA,YAAA;;SAGA5D,WAAaA,MAAKuC;SAClBvC,WAAcA,6BAAsB,SAAA,SAAA;AACtC,WAAA;;EAMA,OAAA;AAEA,WAAMgF,KAAM,IAAI5B;;;;;;EC5lBpB,aAAe,CAAA,oBAAA,cAAA,cAAA,MAAA;EACb6B,OAAAA,SAAc;AAEdC,eAAOC,UAAwB,OAAA,aAAA;AAC7B,YAAK,cAAgBC,OAAOH,QAAAA,OAAa;AACvC,UAAA,aAAiB;AAEjB,eAAII;MACF;IACF;AACF,WAAA;EAEA;EAGF,iBAAA,MAAA;AACAC,QAAAA;MAAgF;MAA7DC;MAAaC;MAAWC,OAAAA;IAAaC,IAAAA;AAAqB,QAACC,CAAAA,cAAA,KAAA,SAAA,GAAA;AAC5E,aAAK;IACH;AACF,eAAA,eAAAD,OAAA,aAAA,MAAA;AAEA,UAAK,UAAML;AACT,UAAIO,YAAUH,cAAmB,YAAA,WAAA,eAAA,YAAA,gBAAA,aAAA;AAEjC,eACEJ,SAAYQ;AAKV,cAAA,YAAA,YAAA,SAAA;AACA,mBAAID;UACF;AACF,oBAAA,WAAA,OAAA;QACAA;MACF;IACF;AACF,WAAA;EAEA;EAGF,WAAA,OAAA;AACAE,QAAAA;MAAwE;MAA3DC;MAAWR;MAAaC,OAAAA;IAAWE,IAAAA;AAAqB,QAACM,gBAAA,WAAA,gBAAA,OAAA;AACpE,aAAIT;IACF;AACF,QAAA;AAEA,eAAIU,eAAcP,OAAA,aAAA,MAAA;AAElB,UAAK,YAAML,gBAAqBa,aAAaC;AAEzC,YAAA,YAAA,cAAA,CAAA,aAAA,aAAA,SAAA,GAAA;AACA;QACE;AAGF,YAAA,YAAA,YAAA,GAAA;AACA,iBAAId;QACF,WAEF,CAAA,gBAAA;2BACUY;QACRA;MACF;IACF;AAIF,QAAA,gBAAA;AACA,aAAIA;IACF;AAKF,eAAA,eAAAP,OAAA,aAAA,MAAA;AACA,UAAK,YAAML,gBAAqBa,eAAiB,EAAE,QAAA,KAAA,SAAA,KAAA,YAAA,aAAA;AACjD,eAAIb;MACF;IACF;AACF,WAAA;EAEA;EAGF,WAAA,OAAA;AACAe,QAAAA;MAAgD;MAAnCL,OAAAA;IAAWL,IAAAA;AAAqB,eAAC,eAAAA,OAAA,aAAA,MAAA;AAC5C,UAAK,aAAML,aAAqBa,SAAAA,GAAY;AAC1C,eAAIG;MACF;IACF;AACF,WAAA;EAEA;EAGF,KAAA,OAAA;AACAC,QAAIC;MAAwC;MAArChB,OAAAA;IAAaG,IAAAA;AAAqB,eAAC,eAAAA,OAAA,aAAA,MAAA;AAEtC,UAAA,YAAA,SAAA,WAAA,GAAA;AACA,cAAIL,SAAYmB,YAASC;AAGvB,YAAA,UAAA,EAAA,OAAA,QAAA,WAAA,OAAA,QAAA,QAAA,UAAA;AACA;QACE;MACF,WAEF,YAAA,SAAA,UAAA,GAAA;;MAEE;AACF,UAAA,CAAA,YAAA,YAAA,KAAA,gBAAA,YAAA,aAAA;AAEA,eAAKpB;MACH;IACF;AACF,WAAA;EAEA;AACF;AACF,SAAC,aAAA,aAAA,WAAA;AAED,SAASgB,YAAYA,SAAChB,KAA0BU,WAAiB;AAC/D,QAAA;MAAiC;IAAGW,IAAAA;AAAG,WAACC,OAAA;;;;;;ACvG1C,SAAMC,SAAWC,QACf;AAQF,QAAA,YAAiBA,CAAAA;AACf,aAAMC,UAAqB,aAAA;AAE3B,cAAWC,UAAUH,iBAAa,QAAAC,MAAA;;AAElC,QAAA,cAAA,QAAA;AAEA,MAAA;AACA,MAAIG,WAA8C,cAAA;AAElD,gBAAc,CAACC;MACbD,MAAAA,YACE;MAAEE,UAAMC;IAAkBC,GAAAA;MAAuC,MACjE,YAAA;MAAEF,UAAMC,UAAYE;OAAMD;MAAiC,MAC3D,YAAA;MAAEF,UAAMC,UAAYG;OAAMF;MAAiC,MAC3D,YAAA;MAAEF,UAAMC,UAAc;OAAEC;MAA+B,MACvD,YAAA;MAAEF,UAAMC,UAAYI;;EAAsC,OAC3D;AACF,gBAAM,CAAA;MACLP,MAAAA;MACIE,UAAM,UAAW;OAAEE;MAAiC,MACtD;MAAEF,UAAM,UAAW;OAAEE;MAAiC,MACtD;MAAEF,UAAM,UAAS;OAAEE;MAA+B,MAElD;MAAEF,UAAM;IAAcE,GAAAA;MAAuC,MAC7D;MAAEF,UAAM,UAAY;OAAEE;MAAiC,MACvD;MAAEF,UAAM,UAAW;OAAEE;MAAiC,MACtD;MAAEF,UAAM,UAAU;OAAEE;MAA+B,MACnD;MAAEF,UAAM,UAAa;;EAAgC;AAEzD,YAAA,KAAA;IAEAF,MAAAA;IACEE,SAAM,OAAM;AACZE,iBAASI,eAAOX,OAAA,aAAA,MAAA;AACd,oBAAWY,aAAeZ,KAAMa;MAC9BD;IACF;EACF,CAAA;AAGF,EAAAZ,OAAA,gBAAA;AACAA,EAAAA,OAAMc,cAAa,cAAI,YAAA;IAEvBd,IAAMe,uBAAc;AAClB,aAAIC,OAAAA,aAAuB;IACzB;IACF,IAAA,qBAAA,OAAA;AAEA,MAAAhB,OAAIgB,aAAAA,uBAA4B;IAC9BhB;IACF,OAAA;AAEAiB,aAAOjB,OAAA,IAAA;IACL;EACF;SACD,eAAA;IAGC,MAAA,CAAA;IACAkB,IAAI,SAAI;AACRC,cAA0BC,YAA8D,CAAA,MAAA,QAAApB,OAAA,KAAA,MAAA,GAAA;AACtFoB,YAAAA,cAAoB,IAACC,OAAS,YAAWC,OAAKD;AAE9C,MAAArB,OAAMY,aAAW,KAAOZ,KAAK,WAACe;AAE9Bf,aAAMa;IACN;;IAEFZ;IACAE,sBAAS;EACTa;WACD,8BAAA;AAGC,eAAA,eAAAhB,OAAA,aAAA,MAAA;AACA,UAAK,CAAA,YAAMY,iBAAqBC,YAAaK,gBAAM,WAAA,YAAA,cAAA;AACjD;MACE;AAGF,iBAAA,WAAA,YAAA,UAAA;AACA,YAAK,CAAAlB,OAAMuB,UAAWX,KAAAA,UAAYY;AAChC,cAAKxB;YAAqB;UAAGyB,IAAAA;AAAI,iBAACC,aAAA,KAAA,QAAA,UAAA;QAAA,CAAA,GAAA;AAChC,sBAAA,cAAA,QAAA,SAAA,QAAA,KAAA;;MAEF;IACF;EACF;AACF,EAAA1B,OAAA,UAAA,0BAAA;AAEAA;AACF,SAAA,iBAAA,QAAAA,QAAA;AAEA,SAAS2B,SAAAA,OAAiBzB;AACxB,UAAOW,gBAAsBb,OAAE,aAAA;AAC7B,UAAMa,cAAqBA,eAAiB,KAAA;AAE5C,UAAMe,CAAAA,aAAcC,cAAaC,IAAenB,gBAAM,KAAA;AACtD,UAAM,UAACoB,CAAAA;;AAGP,MAAA/B,OAAI,gBAAoBK,OAAK,IAAE;AAG7B,iBAAA,gBAAA,MAAA,gBAAA;AACA,cAAK,UAAM2B;AACT,cAAMT,YAAsB,aAAA,OAAA;AAC5B,cAAMU,gBAAYJ;UAClB;UACEN;UACAU;UACAL,WAAW,MAAA;UACXM;UACAH;UACAI,OAAAA;QACAnC;cACD,cAAA,eAAA,aAAA;AACD,gBAAMY,KAAAA,CAAAA,cAAcwB,SAAeC,cAAc,aAAA,cAAA,gBAAA,WAAA,CAAA;MAEjDC;IAMF,OAAA;AACD,UAAA,iBAAM;AACL,UAAIC,CAAAA,QAAAA,wBAAsB,QAAA,KAAA,MAAA,IAAA,GAAA;AAGxB,iBAAA,IAAA,GAAA,IAAA1B,cAAA,UAAA,CAAA,gBAAA,KAAA;AACA,2BAAiBA,cAAe,GAAC2B,gBAAWD,WAAiB1B,cAAI,GAAA;QAC/D0B;AAIF,yBAAA,kBAAAvC,OAAA,IAAA,IAAAA,OAAA,gBAAA,OAIE,MAAA,cAAA;;AAEJ,UAAA,CAAA,gBAAA;AAEA,cAAKuC,gBAAgB;UACnB,SAAMF;UACJd,WAA8B,aAAA,KAAA;UAC9BU;UACAL,WAAW,MAAA;UACXM;UACAC;UACAJ,OAAAA;QACA/B;cACD,cAAA,eAAA,aAAA;AAED,gBAAMY,KAAAA,CAAAA,cAAcwB,SAAeC,cAAc,aAAA,cAAA,gBAAA,WAAA,CAAA;MAEjDC;IAMF;AAGF,eAAA,CAAA,SAAAP,cAAAI,iBAAA,WAAA,KAAA,SAAA;AACA,kBAAYZ,QAASQ,SAAAA,OAAaI,cAAgBvB,eAAY;;EAE9D;;AAEJ,SAAA,eAAA,eAAA;AAEA,QAAA;IACE;IAAQgB,OAAAA;EAAa5B,IAAAA;AAAM,QAAIqC,mBAAa,OAAA,OAAA,aAAA;AAE5C,QAAMI,YAAAA;IACN,aAAe;IAAK7B;EAA+ByB;SAAe,KAAA,qBAAA,SAAA;AAElErC,SAAMsB,UAAK,eAAqBoB,OAAAA,aAAU,IAAA;IAE1C;EAAyDd,CAAAA;AAAY;AACvE,SAAA,YAAA,OAAA,iBAAA;AAEA,MAAA;IAGE;IAFEH,OAAAA;IAAKzB;EAAOoB,IAAAA;AAAuB,QAACuB;IAGtC,cAAM;MACJ9B;IAAgBV;;EAChByC,IAAAA;AACF,QAAI5C,cAAK4C,QAAA;AACT,MAAA5C,OAAM6C,QAAW,SAAUC,CAAAA,QAAAA,QAAgB;AAE3C,YAAUC,SAAQC;MAChB5B,SAAQwB;IAAWK;;AAGrB,aAAA,aAAAL,QAAA,iBAAA;AACA,gBAAWV,KAAAA,WAAmBU,QAACM,gBAAiB;AAC9CL,gBAAYpB,KAAKS,WAAWU,QAAOO,oBAAiB,IAAA;;AAEtD,QAAA,eAAA,WAAA,QAAA;AAEA,aAAMC;IAEN;IAAa/C;EAAME,KAAAA,WAAAA;AAAU,gBAAa,KAAE,MAAA,UAAA,YAAA;;AAE5C;AACF,IAAA,eAAA;EAEA,IAAMM;EACJwC,SAAAA;EACAC,WAAO;IACPrD,sBAAW,SAAA,YAAA,KAAA,KAAA;IACT,yBAA0B,SAAKsD,YAAe,KAAE,QAAM;IACtD,sBAAA,CAAuB,OAAMvD,WAAKuD;AAClC,UAAA;QAAmD;MAA1BC,IAAAA;AACvB,eAAA,IAAAxD,OAAA,aAAA,KAAA,SAAA,GAAA,KAAA,GAAA,KAAA;AACA,cAAK,cAAca,OAAAA,aAAkB2B,KAAS;AAC5C,YAAA,YAAM5B,iBAAoBC,cAAoB;AAE9C;QACE;AACF,oBAAA,KAAA;AAEAD,QAAAA,OAAAA,KAAW,wBAAO;UAClBZ;QAAqCY,CAAAA;AAAY,oBAAE,QAAA;AACnDA,YAAAA,OAAAA,aAAqB,KAAA,SAAA,GAAA;AAErB,UAAAZ,OAAIA,aAAMa,KAAaK,OAAKsB,GAAM,CAAG;;MAErC;IACF;EACF;;EAEFe;EACA5B;AACA5B;;;;ECxQK,YAAM0D,QAAe;AAE1BC,SAAuB,OAAE,CAAA;AAEzBC,SAAAA,cAEM,CAAA;AAENC,SAAK,QAAA;AAELC,SAAAA,QAAYD;AACV,IAAAA,OAAKA,aAAa;MAClBA,sBAAmB,UAAA;AACjB,YAAA;UAA4C;QAAnBE,IAAAA;AAAa,cAACC;UACrC;QAAQC,IAAAA;AAAO,cAAIF,wBAAY,GAAA,OAAA,MAAA,IAAA,KAAA,YAAA,UAAA,OAAA,KAAA,MAAA;AAC/B,cAAMG,cAAAA,UAA2CC,uBACxCP,OAAAA,MAAYK,YAChBA;AAEL,8BAAoBG,OAAIC,aAAUH,CAAAA;MAClCA;IACF,CAAA;EACF;EACF,IAAA,QAAA,SAAA;AAEAI,cAAoBC,OAAa,WAAgB,CAAA,GAAA;MAC/CA,SAAUC,KAAM,MAACD;IACfE,CAAAA;AACF,UAAE,eAAA,IAAA,KAAA,MAAA,aAAA,QAAA,SAAA,KAAA,MAAA,UAAA,KAAA,MAAA,MAAA;AACF,SAAA,MAAMV,YAAe,aAAeW,IAAAA;AAEpC,SAAKb,KAAK,KAACc,YAAYZ;AACvB,QAAI,GAACJ,OAAS,MAACI,GAAAA;AAEf,UAAM,CAACI,KAAAA,YAAgB,SAAA;AACrB,aAAK,YAAKP,UAAmB,CAAA;MAC3B;AACF,WAAA,YAAA,QAAA,KAAA,YAAA;WACKA;AACN,UAAA,CAAM,aAAA,OAAA,KAAA,MAAA,KAAA;AACL,eAAMG,eAAmB,QAAcF,KAAMe,MAAK,IAAA;UAChDC,OAAOC,CAAAA;UACLC,cAAS;QACTC,CAAAA;MACF;AACF,aAAA,KAAA,MAAA,IAAA,KAAA,YAAA;;AAGF,SAAA,MAAA,KAAA,oBAAA;MAEA;MACEf;MACAM;MACAR,KAAAA,KAAAA,MAAY;IACZkB,CAAAA;AACF,WAAE;EAEF;EACF,YAAA,QAAA,SAAA;AAEAC,UAAAA,UAA0B,WAAqB,QAAA,WAAA,KAAA,MAAA;AAC7C,UAAMC,aAAWZ,GAAAA,OAAWA,MAAQY;AACpC,UAAMC,wBAAuBnB,aAAO,KAAA,YAAA,UAAA,OAAA,KAAA,MAAA;AACpC,QAAA,CAAA;AAA2C,aAAGmB;AAI9C,WAAKlB,KAAAA,uBAA8BmB,kBAAS,aAAA,aAAA,YAAA,cAAA,aAAA,UAAA,MAAA,EAAA;;EAO9C,aAAA,MAAA,UAAA;AAEAC,eAAgBC,gBAAmE,KAAA,MAAA;AACjF,UAAK;AACH,WAAIC,GAAM,OAAA,aAAA,MAAA,IAIJ,GAAA,QAAA,IAAA,KAAA,gBAAA,MAAA,aAAA,MAAA,IAEA,SAAA,aAAA,WAEJ,aAAA,UAAA,IAAA,GAAA;AACAzB,cAAAA,SAAa0B,YAAe;MAE5BD;AACF,UAAA,QAAA,QAAA;AAEA,eAAO;MACL;IACF;EACF;AACF;;;ACpBK,SAASE,qBAAqBC,QAA8B;AACjE,QAAMC,YAAYA,CAACC,QAAgBC,YAAqB;AACtD,QAAIC,eAAeJ,OAAMK,cAAcC,YAAYJ,QAAQC,OAAO;AAElE,QAAI,CAACC,cAAc;AACjBA,qBAAeJ,OAAMK,cAAcE,IAAIL,QAAQC,OAAO;AACtDC,mBAAaI,OAAOC,SAASR,UAASS;IACxC;AAEA,WAAON;;AAITH,EAAAA,UAASU,oBAAiCC;AAC1CX,EAAAA,UAASY,eAA4BC;AACrCb,EAAAA,UAASc,mBAAgCC;AACzCf,EAAAA,UAASgB,gBAA6BC;AAEtCjB,EAAAA,UAASkB,iBAA0BA;AACnClB,EAAAA,UAASmB,uBAAgCA;AACzCnB,EAAAA,UAASoB,kBAA2BA;AACpCpB,EAAAA,UAASqB,UAAmBA;AAE5BrB,EAAAA,UAASS,eAAe,CAAA;AAGxBT,EAAAA,UAASsB,UAAUC;AACnBvB,EAAAA,UAASD,QAAQA;AACjBC,EAAAA,UAASwB,MAAM,SAAUC,QAAQvB,SAAS;AACxC,SAAKH,MAAM2B,UAAUD,QAAQvB,OAAO;AAEpC,WAAO;;AAGTF,EAAAA,UAAS2B,QAAQ,SAAU1B,QAAgBC,SAA0C;AACnF,WAAO,CAAC,CAAC,KAAKH,MAAMK,cAAcwB,IAAI3B,QAAQC,WAAWA,QAAQ2B,OAAO;;AAG1E7B,EAAAA,UAAS8B,KAAKC,SAAS,SAASD,GAAGE,MAA2BC,UAAwB/B,SAAkB;AACtG,QAAIgC,GAAGC,OAAOH,IAAI,KAAKA,KAAKI,OAAO,GAAG,MAAM,IAAI;AAC9CJ,aAAOA,KAAKK,KAAI,EAAGC,MAAM,IAAI;IAC/B;AAEA,QAAIJ,GAAGK,MAAMP,IAAI,GAAG;AAClB,iBAAWQ,aAAaR,MAAe;AACrC,aAAKF,GAAGU,WAAWP,UAAU/B,OAAO;MACtC;AAEA,aAAO;IACT;AAEA,QAAIgC,GAAGO,OAAOT,IAAI,GAAG;AACnB,iBAAWU,QAAQV,MAAM;AACvB,aAAKF,GAAGY,MAAOV,KAAaU,OAAOT,QAAQ;MAC7C;AAEA,aAAO;IACT;AAGA,QAAIU,iBAAiBX,MAAM,KAAKjC,MAAM6C,OAAO,GAAG;AAE9C,UAAI,CAAC,KAAKnC,aAAauB,OAAO;AAC5B,aAAKvB,aAAauB,QAAQ,CAACC,QAAQ;MACrC,OAAO;AACL,aAAKxB,aAAauB,MAAMa,KAAKZ,QAAQ;MACvC;IACF,OAEK;AACH,WAAKlC,MAAMQ,OAAOuC,IAAI,KAAK/C,MAAMgD,UAAUf,MAAMC,UAAsB;QAAE/B;MAAQ,CAAC;IACpF;AAEA,WAAO;KACN,8CAA8C;AAEjDF,EAAAA,UAASgD,MAAMjB,SAAS,SAASiB,IAAIhB,MAAkBC,UAAe/B,SAAkB;AACtF,QAAIgC,GAAGC,OAAOH,IAAI,KAAKA,KAAKI,OAAO,GAAG,MAAM,IAAI;AAC9CJ,aAAOA,KAAKK,KAAI,EAAGC,MAAM,IAAI;IAC/B;AAEA,QAAIJ,GAAGK,MAAMP,IAAI,GAAG;AAClB,iBAAWQ,aAAaR,MAAM;AAC5B,aAAKgB,IAAIR,WAAWP,UAAU/B,OAAO;MACvC;AAEA,aAAO;IACT;AAEA,QAAIgC,GAAGO,OAAOT,IAAI,GAAG;AACnB,iBAAWU,QAAQV,MAAM;AACvB,aAAKgB,IAAIN,MAAMV,KAAKU,OAAOT,QAAQ;MACrC;AAEA,aAAO;IACT;AAEA,QAAIU,iBAAiBX,MAAM,KAAKjC,MAAM6C,OAAO,GAAG;AAC9C,UAAIK;AAEJ,UAAIjB,QAAQ,KAAKvB,iBAAiBwC,QAAQ,KAAKxC,aAAauB,MAAMkB,QAAQjB,QAAQ,OAAO,IAAI;AAC3F,aAAKxB,aAAauB,MAAMmB,OAAOF,OAAO,CAAC;MACzC;IACF,OAAO;AACL,WAAKlD,MAAMQ,OAAO6C,OAAO,KAAKrD,MAAMgD,UAAUf,MAAMC,UAAU/B,OAAO;IACvE;AAEA,WAAO;KACN,+CAA+C;AAElDF,EAAAA,UAASqD,QAAQ,WAAY;AAC3B,WAAO,KAAKtD;;AAGdC,EAAAA,UAASsD,gBAAgB,WAAY;AACnC,WAAOC,QAAQD;;AAGjBtD,EAAAA,UAASwD,uBAAuB,WAAY;AAC1C,WAAOD,QAAQC;;AAGjBxD,EAAAA,UAASyD,OAAO,WAAY;AAC1B,eAAWC,eAAe,KAAK3D,MAAM4D,aAAaC,MAAM;AACtDF,kBAAYD,KAAI;IAClB;AAEA,WAAO;;AAGTzD,EAAAA,UAAS6D,uBAAuB,SAAUC,UAAmB;AAC3D,QAAI5B,GAAG6B,OAAOD,QAAQ,GAAG;AACvB,WAAK/D,MAAM4D,aAAaE,uBAAuBC;AAE/C,aAAO;IACT;AAEA,WAAO,KAAK/D,MAAM4D,aAAaE;;AAGjC7D,EAAAA,UAASgE,cAAc,SAAUC,KAAe/D,SAAkB;AAChE,SAAKH,MAAMiE,YAAYC,KAAK/D,OAAO;;AAGrCF,EAAAA,UAASkE,iBAAiB,SAAUD,KAAe;AACjD,SAAKlE,MAAMmE,eAAeD,GAAG;;AAG/B,SAAOjE;AACT;;;AC/LO,IAAMmE,QAAN,MAAY;EACjBC,cAAM;AACNC,SAAAA,KAAAA,oBAAqB,KAAA,MAAA,KAAA,OAAA,IAAA,GAAA;AACrBC,SAAAA,gBAGO;AAEPC,SAAO,eAAU,CAAA;AACjBC,SAAAA,UAAiBA;AACjBC,SAAAA,WAAYA,MAAS,QAAA;AACrBC,SAAO,YAAY;AACjBC,SAAK,UAAE;MACPC,KAAM,CAAE;MACNC,QAAO;QACPC,OAAM;QACNC,MAAK;QACN,KAAA;MACDC;MACAC,YAAc,CAAA;MACf,gBAAA,CAAA;IAEDC;AACAC,SAAAA,iBAAgBA,qBAAa,IAAA;AAC7BC,SAAAA,gBAAY;AACZC,SAAAA,eAAoBC;;AAGpBC,SAAI,OAAA;AAEJ,SAAA,WAAA;;AAIAC,SAAM,YAAA,CAAA;;MAEN,MAAA,CAAA;MACAC,KAAS,CAAA;IAETC;AAIEC,SAAI,iBAAI,WAAA,KAAA,eAAA,MAAA,MAAA;AACRhB,UAAKiB,SAAC;AACP,SAAA,eAAA,cAAA,aAAA;MAEDC,IAAAA,YAAc;AACZ,eAAWD,OAAG;MAEd;MACE,IAAIE,SAASA;AACX,cAAA,IAAOF,OAAMpB;AACf,QAAAoB,OAAA,KAAA,oBAAA;UAEyCG;UACvC,cAAUA;QAEVH,CAAAA;eACEG;MACAC;MACF,QAAE;AAEF,cAAA,MAAW;AACb,cAAA,QAAAJ,OAAA,cAAA,KAAA,QAAA,IAAA;AAEAK,YAAKA,QAAyB;AAAA;AAC5B,QAAAL,OAAMK,cAAO,KAAA,OAAA,OAAA,CAAA;AAEb,QAAAL,OAAMM,KAAK,sBAAsB;UACjC,cAAe;QAEfN,CAAAA;MACAA;IAAmCI;EAAmB;EACxD,aAAA,KAAA,IAAA;SACD,aAAA,KAAA;MACH;MAEAG;IACE,CAAA;;EAA6BxB,KAAAA,MAAAA,KAAAA;AAAI,eAAE;MACrC,KAAA;SAE6ByB,OAA2B;MACtD;IACEzB,KAAG,KAAE,cAAA;AAAE,UAACyB,CAAAA,CAAAA,YAAOC,SAAAA,KAAAA,MAAAA,IAAAA,MAAAA,OAAAA;AAAS,eAAA;MACzB;IACC;EACE;EACF,KAAAb,SAAA;AACF,WAAA,KAAA,gBAAA,OAAA,UAAA,MAAAA,OAAA;EACF;EAEAc,kBAAkBC,QAA6B;AAE/CC,UAAKhB;MACH;IACF,IAAA;AAEAiB,WAAAA,KAAAA,CAAAA,CAAAA,KAAkBC,SAAgB,IAAA,MAAA,KAAA,SAAA,KAAA,QAAA,MAAA,MAAA;;EACxBtC,UAAAA,QAAAA,SAAAA;AAAG,QAAIsC,CAAAA,KAAM,eAAA;AACrB,aAAS;IACX;AAEAC,QAAAA,KAAUD,kBAAkD,MAAA,GAAA;AAC1D,aAAS;IACP;AACF,QAAA,OAAA,IAAA;AAEA,WAAI,SAAKD,IAAAA,OAAkBC,MAAM;IAC/B;AACF,SAAA,SAAA,KAAA,KAAA,MAAA;AAEA,QAAIA,OAAOtC,SAAI;AACb,aAAKsB,QAASf,MAAI+B,OAAU;IAC9B;AACA,QAAI,OAAChB,aAAmBgB,OAAO,QAAA;AAE/B,UAAIA,QAAOE;AACTF,YAAM,MAACE,KAAQ,aAAc;AAC/B,YAAA,SAAA,OAAA,OAAA,OAAA,CAAA,KAAA,OAAA;AAEIF,YAAAA,MAAOG;AACT,YAAIX,aAAS,EAAA,KAAA;AACb,eAAS;MACT,GAAA,CAAA,CAAA;AACEY,aAAI1C,QAAM,KAAI,SAAA;AACd0C,cAAIC,UAAY,KAAK,aAAO,OAAA;AAC5B,YAAA,YAAU,OAAA,YAAA,OAAA,aAAA,OAAA,KAAA;AACT;QAEH;;AAGE,WAAA,aAAgBC,OAAOC,OAAO,GAAC;QAC7B,IAAA,OAAA;QACF,KAAA,OAAA;MACF,CAAA;eAEK3C,OAAAA,WAAoB4B;WAAc,aAAW,KAAA;QAAEvB,IAAG,OAAQ;QAAa,KAAA,OAAA;MAC7E,CAAA;IACC;WAA2B;;EAAmC,YAAE,KAAA,SAAA;AAGlE,QAAA,KAAO,YAAI,GAAA,MAAA,IAAA;AACb,aAAA;IAEAuC;AACE,UAAA1B,UAAA,UAAA,GAAA;AACA,cAAS2B,UAAW,OAAK,CAAA,GAAM,OAAG,IAAA,CAAA;AAChC,SAAA,UAAY,KAAA;MACd;MAEA;IAEApB,CAAAA;AAEA,SAAKN,OAAAA,UAAe,KAAA,GAAA;AACpB,QAAI,QAAQA,KAAAA,UAAe2B;;IAE3B;AACA,SAAA,KAAA,sBAAA;MACA;MACE,QAAA5B;MACF,OAAA;MAEA;;;EAA+CI,eAAW,KAAA;AAAEG,UAAAA,QAAAA,KAAAA,YAAAA,GAAAA;AAAQ,UAAEP,UAAA,UAAA,GAAA;AACxE,UAAA,UAAA,KAAA,UAAA,OAAA;AAEA6B,SAAAA,OAAcA,OAAgB7B,SAAA,UAAA,KAAA,cAAA;AAC5B,SAAA,UAAc,OAAK2B,OAAAA,CAAW;AAE9B,SAAA,OAAY,UAAOG,OAAUF,OAAI,CAAA;AACjC,SAAA,KAAMrB,yBAAyBG;MAE/B;MAEA,QAAAV;MACA,OAAK+B;MAEL;;;EAAkD3B,YAAO,KAAI;AAAEG,aAAAA,IAAAA,GAAAA,IAAAA,KAAAA,UAAAA,QAAAA,KAAAA;AAAU,UAAA,KAAA,UAAA,GAAA,QAAA,KAAA;AAC3E,eAAA;MAEAoB;IACE;WACM;EACF;EACF,cAAA,KAAA;AACF,UAAA,WAAA,KAAA,YAAA,GAAA;AAEA,WAAO,aAAE,KAAA,OAAA,KAAA,UAAA,UAAA;EACX;EAEAK,MAAAA;AACE,YAAMC,KAAAA,OAAW,QAAKN,MAAYC,IAAI;EAEtC;AACF;;AAOF,EAAAxB,OAAA,gBAAA;;AAKA,IAAA,KAAAJ,OAAA;EACO;AACLI,aAAMvB,KAAAA,OAAgB;AAEtB,UAAOmB,KAAMA,OAACA;AACZkC,MAAAA,KAAIlB,OAAKhB;AAIXjB,EAAAA,OAAAA,SAAaiB;AACbmC,EAAAA,OAAInB,WAAYhB,QAAA;;AAEhB,EAAAI,OAAA,UAAA,MAAA;AACAA,SAAMJ;AACNI;AAEAA,SAAMe,aAAUiB,IAAAA;AAChBhC,SAAMe,MAAAA,GAAUY,QAAO,SAAA,EAAA;AAEvB;;;;ACxRF,IAAMM,WAAQ,MAAS;AAEvB,IAAMC,UAAQ,OAASC,eAAc,cAAA,aAAA,OAAA,WAAA,cAAA,SAAA;AAIrC,MAAMC,KAAAA,OAAU;",
  "names": ["lastTime", "request", "cancel", "init", "global", "requestAnimationFrame", "cancelAnimationFrame", "vendors", "vendor", "bind", "callback", "currTime", "Date", "now", "timeToCall", "Math", "max", "token", "setTimeout", "clearTimeout", "VENDOR_PREFIXES", "pointerExtend", "dest", "source", "__set", "prop", "some", "prefix", "indexOf", "Object", "defineProperty", "get", "set", "value", "configurable", "y", "copyCoords", "src", "dest", "page", "x", "client", "setCoordDeltas", "targetObj", "cur", "prev", "setCoordVelocity", "delta", "timeStamp", "dt", "setZeroCoords", "isNativePointer", "pointer", "getXY", "xy", "type", "getPageXY", "y", "browser", "isOperaMobile", "window", "scrollX", "getClientXY", "getPointerId", "setCoords", "pointers", "length", "getTouchPair", "array", "event", "touches", "changedTouches", "pointerAverage", "average", "pageX", "pageY", "clientX", "clientY", "screenX", "screenY", "touchBBox", "minX", "Math", "min", "minY", "maxX", "max", "maxY", "left", "top", "right", "bottom", "width", "touchDistance", "deltaSource", "sourceX", "sourceY", "dx", "dy", "touchAngle", "angle", "getPointerType", "getEventTargets", "path", "composedPath", "newCoords", "_scope$document", "targets", "delegatedEvents", "documents", "add", "remove", "addDelegate", "removeDelegate", "delegateListener", "delegateUseCapture", "supportsOptions", "supportsPassive", "scope", "capture", "passive", "events", "eventsMethods", "eventTarget", "listener", "addEventListener", "getOptions", "optionalArg", "target", "arr", "type", "options", "func", "removeEventListener", "targetIndex", "hasOwnProperty", "typeIsEmpty", "typeListeners", "length", "entry", "i", "optionsMatch", "splice", "keys", "doc", "delegate", "selector", "context", "listeners", "delegates", "matchFound", "index", "event", "fakeEvent", "element", "cur", "domUtils", "currentTarget", "FakeEvent", "originalEvent", "constructor", "pExtend", "preventOriginalDefault", "stopPropagation", "stopImmediatePropagation", "param", "object", "a", "b", "id", "install", "preventDefault", "options", "bool", "newValue", "scope", "checkAndPreventDefault", "interactable", "setting", "event", "events", "supportsPassive", "doc", "getWindow", "document", "docOptions", "getDocOptions", "interaction", "_ref", "install", "Interactable", "prototype", "interactions", "type", "listener", "id", "listeners", "acc", "eventType", "warnOnce", "warned", "window", "console", "copyAction", "dest", "name", "src", "axis", "edges", "getStringOptionResult", "resolveRectLike", "returnValue", "func", "rectToXY", "x", "rect", "left", "xywhToTlbr", "extend", "top", "right", "width", "tlbrToXywh", "y", "addEdges", "edges", "target", "actionName", "actionOptions", "actionOrigin", "origin", "options", "originRect", "resolveRectLike", "x", "y", "BaseEvent", "immediatePropagationStopped", "propagationStopped", "constructor", "interaction", "stopPropagation", "stopImmediatePropagation", "Object", "defineProperty", "get", "defaults", "base", "preventDefault", "deltaSource", "perAction", "enabled", "origin", "x", "y", "actions", "InteractEvent", "BaseEvent", "relatedTarget", "screenX", "screenY", "button", "buttons", "ctrlKey", "shiftKey", "altKey", "metaKey", "page", "client", "delta", "rect", "duration", "clientX0", "clientY0", "velocity", "speed", "swipe", "axes", "preEnd", "interaction", "element", "target", "interactable", "deltaSource", "options", "defaults", "origin", "getOriginXY", "actionName", "starting", "phase", "ending", "prevEvent", "coords", "start", "timeStamp", "cur", "extend", "x", "y", "event", "currentTarget", "type", "t0", "pointers", "length", "downTime", "x0", "y0", "dt", "hypot", "getSwipe", "_interaction", "angle", "Math", "atan2", "velocityY", "velocityX", "PI", "overlap", "left", "up", "right", "down", "preventDefault", "stopImmediatePropagation", "immediatePropagationStopped", "propagationStopped", "stopPropagation", "Object", "defineProperties", "prototype", "pageX", "get", "set", "value", "pageY", "clientX", "clientY", "dx", "dy", "PointerInfo", "id", "pointer", "event", "downTime", "downTarget", "constructor", "_ProxyValues", "_ProxyMethods", "idCounter", "interactable", "rect", "_rects", "_scopeFire", "name", "axis", "edges", "pointerType", "pointers", "downPointer", "_latestPointer", "pointer", "eventTarget", "prevEvent", "pointerWasMoved", "_interacting", "_ending", "_stopped", "_proxy", "pointerMoveTolerance", "coords", "prev", "cur", "delta", "pointerUtils", "velocity", "constructor", "_ref", "scopeFire", "that", "get", "Object", "defineProperty", "value", "interaction", "pointerDown", "start", "copyAction", "element", "left", "right", "top", "bottom", "pointerMove", "dx", "dy", "pointerIndex", "pointerInfo", "event", "type", "duplicate", "duplicateMove", "move", "signalArg", "_doPhase", "pointerUp", "curEventTarget", "simulation", "end", "interacting", "endPhaseResult", "phase", "currentAction", "prepared", "stop", "pointerId", "getPointerId", "getPointerInfo", "getPointerIndex", "updatePointer", "down", "PointerInfo", "push", "pointerIsDown", "downEvent", "removePointer", "_updateLatestPointer", "destroy", "_fireEvent", "_this$interactable", "preEnd", "iEvent", "methodOrder", "search", "details", "finder", "interaction", "simulationResume", "pointerType", "eventType", "eventTarget", "scope", "_ref", "element", "simulation", "mouseOrPen", "pointerId", "_ref2", "firstNonActive", "interactions", "list", "hasPointer", "hasPointerId", "idle", "_ref4", "pointers", "length", "id", "_ref5", "methodNames", "scope", "listeners", "method", "docEvents", "PointerEvent", "type", "pEventTypes", "listener", "down", "move", "cancel", "event", "interaction", "interactions", "prevTouchTime", "Interaction", "pointerMoveTolerance", "_now", "list", "new", "options", "name", "fire", "pointer", "pointers", "doc", "_ref", "doOnInteractions", "pointerType", "pointerUtils", "getPointerType", "eventTarget", "changedTouch", "pointerId", "eventType", "curEventTarget", "getInteraction", "searchDetails", "matches", "invalidPointer", "length", "foundInteraction", "signalArg", "_ref2", "events", "eventMethod", "eventMethodName", "browser", "isIOS", "passive", "delegatedEvents", "delegateListener", "eventOptions", "id", "install", "onDocSignal", "interactable", "InteractableSet", "list", "selectorMap", "scope", "constructor", "interactable", "_ref", "target", "interactablesOnTarget", "string", "arr", "findIndex", "new", "options", "extend", "actions", "Interactable", "addDocument", "id", "Object", "defineProperty", "value", "configurable", "win", "getExisting", "context", "isSelector", "undefined", "forEachMatch", "node", "ret", "inContext", "createInteractStatic", "scope", "interact", "target", "options", "interactable", "interactables", "getExisting", "new", "events", "global", "globalEvents", "getPointerAverage", "pointerAverage", "getTouchBBox", "touchBBox", "getTouchDistance", "touchDistance", "getTouchAngle", "touchAngle", "getElementRect", "getElementClientRect", "matchesSelector", "closest", "version", "process", "use", "plugin", "usePlugin", "isSet", "get", "context", "on", "warnOnce", "type", "listener", "is", "string", "search", "trim", "split", "array", "eventType", "object", "prop", "isNonNativeEvent", "actions", "push", "add", "document", "off", "index", "indexOf", "splice", "remove", "debug", "supportsTouch", "browser", "supportsPointerEvent", "stop", "interaction", "interactions", "list", "pointerMoveTolerance", "newValue", "number", "addDocument", "doc", "removeDocument", "Scope", "id", "isInitialized", "listenerMaps", "browser", "defaults", "Eventable", "actions", "map", "phases", "start", "move", "end", "methodDict", "phaselessTypes", "interactStatic", "InteractEvent", "Interactable", "interactables", "InteractableSet", "_win", "window", "documents", "_plugins", "list", "scope", "constructor", "_defaults", "options", "interactable", "unset", "index", "addListeners", "name", "listener", "onWindowUnload", "event", "init", "pluginIsInstalled", "plugin", "usePlugin", "install", "listeners", "acc", "pluginIdRoot", "before", "otherId", "addDocument", "getDocIndex", "doc", "removeDocument", "getWindow", "events", "getDocOptions", "docIndex", "win", "raf", "interactions", "scope", "interact", "interactStatic", "_global"]
}
