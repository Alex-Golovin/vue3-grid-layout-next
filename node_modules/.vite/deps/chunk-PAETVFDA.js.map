{
  "version": 3,
  "sources": ["../../.pnpm/@interactjs+utils@1.10.27/node_modules/@interactjs/utils/arr.ts", "../../.pnpm/@interactjs+utils@1.10.27/node_modules/@interactjs/utils/domObjects.ts", "../../.pnpm/@interactjs+utils@1.10.27/node_modules/@interactjs/utils/isWindow.ts", "../../.pnpm/@interactjs+utils@1.10.27/node_modules/@interactjs/utils/window.ts", "../../.pnpm/@interactjs+utils@1.10.27/node_modules/@interactjs/utils/is.ts", "../../.pnpm/@interactjs+utils@1.10.27/node_modules/@interactjs/utils/browser.ts", "../../.pnpm/@interactjs+utils@1.10.27/node_modules/@interactjs/utils/clone.ts", "../../.pnpm/@interactjs+utils@1.10.27/node_modules/@interactjs/utils/domUtils.ts", "../../.pnpm/@interactjs+utils@1.10.27/node_modules/@interactjs/utils/extend.ts", "../../.pnpm/@interactjs+utils@1.10.27/node_modules/@interactjs/utils/isNonNativeEvent.ts", "../../.pnpm/@interactjs+utils@1.10.27/node_modules/@interactjs/utils/normalizeListeners.ts", "../../.pnpm/@interactjs+core@1.10.27_@interactjs+utils@1.10.27/node_modules/@interactjs/core/Eventable.ts", "../../.pnpm/@interactjs+core@1.10.27_@interactjs+utils@1.10.27/node_modules/@interactjs/core/Interactable.ts"],
  "sourcesContent": ["type Filter<T> = (element: T, index: number, array: T[]) => boolean\n\nexport const contains = <T>(array: T[], target: T) => array.indexOf(target) !== -1\n\nexport const remove = <T>(array: T[], target: T) => array.splice(array.indexOf(target), 1)\n\nexport const merge = <T, U>(target: Array<T | U>, source: U[]) => {\n  for (const item of source) {\n    target.push(item)\n  }\n\n  return target\n}\n\nexport const from = <T = any>(source: ArrayLike<T>) => merge([] as T[], source as T[])\n\nexport const findIndex = <T>(array: T[], func: Filter<T>) => {\n  for (let i = 0; i < array.length; i++) {\n    if (func(array[i], i, array)) {\n      return i\n    }\n  }\n\n  return -1\n}\n\nexport const find = <T = any>(array: T[], func: Filter<T>): T | undefined => array[findIndex(array, func)]\n", "const domObjects: {\n  init: any\n  document: Document\n  DocumentFragment: typeof DocumentFragment\n  SVGElement: typeof SVGElement\n  SVGSVGElement: typeof SVGSVGElement\n  SVGElementInstance: any\n  Element: typeof Element\n  HTMLElement: typeof HTMLElement\n  Event: typeof Event\n  Touch: typeof Touch\n  PointerEvent: typeof PointerEvent\n} = {\n  init,\n  document: null,\n  DocumentFragment: null,\n  SVGElement: null,\n  SVGSVGElement: null,\n  SVGElementInstance: null,\n  Element: null,\n  HTMLElement: null,\n  Event: null,\n  Touch: null,\n  PointerEvent: null,\n}\n\nfunction blank() {}\n\nexport default domObjects\n\nfunction init(window: Window) {\n  const win = window as any\n\n  domObjects.document = win.document\n  domObjects.DocumentFragment = win.DocumentFragment || blank\n  domObjects.SVGElement = win.SVGElement || blank\n  domObjects.SVGSVGElement = win.SVGSVGElement || blank\n  domObjects.SVGElementInstance = win.SVGElementInstance || blank\n  domObjects.Element = win.Element || blank\n  domObjects.HTMLElement = win.HTMLElement || domObjects.Element\n\n  domObjects.Event = win.Event\n  domObjects.Touch = win.Touch || blank\n  domObjects.PointerEvent = win.PointerEvent || win.MSPointerEvent\n}\n", "export default (thing: any) => !!(thing && thing.Window) && thing instanceof thing.Window\n", "import isWindow from './isWindow'\n\nexport let realWindow = undefined as Window\n\nlet win = undefined as Window\nexport { win as window }\n\nexport function init(window: Window & { wrap?: (...args: any[]) => any }) {\n  // get wrapped window if using Shadow DOM polyfill\n\n  realWindow = window\n\n  // create a TextNode\n  const el = window.document.createTextNode('')\n\n  // check if it's wrapped by a polyfill\n  if (el.ownerDocument !== window.document && typeof window.wrap === 'function' && window.wrap(el) === el) {\n    // use wrapped window\n    window = window.wrap(window)\n  }\n\n  win = window\n}\n\nif (typeof window !== 'undefined' && !!window) {\n  init(window)\n}\n\nexport function getWindow(node: any) {\n  if (isWindow(node)) {\n    return node\n  }\n\n  const rootNode = node.ownerDocument || node\n\n  return rootNode.defaultView || win.window\n}\n", "import isWindow from './isWindow'\nimport * as win from './window'\n\nconst window = (thing: any): thing is Window => thing === win.window || isWindow(thing)\n\nconst docFrag = (thing: any): thing is DocumentFragment => object(thing) && thing.nodeType === 11\n\nconst object = (thing: any): thing is { [index: string]: any } => !!thing && typeof thing === 'object'\n\nconst func = (thing: any): thing is (...args: any[]) => any => typeof thing === 'function'\n\nconst number = (thing: any): thing is number => typeof thing === 'number'\n\nconst bool = (thing: any): thing is boolean => typeof thing === 'boolean'\n\nconst string = (thing: any): thing is string => typeof thing === 'string'\n\nconst element = (thing: any): thing is HTMLElement | SVGElement => {\n  if (!thing || typeof thing !== 'object') {\n    return false\n  }\n\n  const _window = win.getWindow(thing) || win.window\n\n  return /object|function/.test(typeof Element)\n    ? thing instanceof Element || thing instanceof _window.Element\n    : thing.nodeType === 1 && typeof thing.nodeName === 'string'\n}\n\nconst plainObject: typeof object = (thing: any): thing is { [index: string]: any } =>\n  object(thing) && !!thing.constructor && /function Object\\b/.test(thing.constructor.toString())\n\nconst array = <T extends unknown>(thing: any): thing is T[] =>\n  object(thing) && typeof thing.length !== 'undefined' && func(thing.splice)\n\nexport default {\n  window,\n  docFrag,\n  object,\n  func,\n  number,\n  bool,\n  string,\n  element,\n  plainObject,\n  array,\n}\n", "import domObjects from './domObjects'\nimport is from './is'\n\nconst browser = {\n  init,\n  supportsTouch: null as boolean,\n  supportsPointerEvent: null as boolean,\n  isIOS7: null as boolean,\n  isIOS: null as boolean,\n  isIe9: null as boolean,\n  isOperaMobile: null as boolean,\n  prefixedMatchesSelector: null as 'matches',\n  pEventTypes: null as {\n    up: string\n    down: string\n    over: string\n    out: string\n    move: string\n    cancel: string\n  },\n  wheelEvent: null as string,\n}\n\nfunction init(window: any) {\n  const Element = domObjects.Element\n  const navigator: Partial<Navigator> = window.navigator || {}\n\n  // Does the browser support touch input?\n  browser.supportsTouch =\n    'ontouchstart' in window ||\n    (is.func(window.DocumentTouch) && domObjects.document instanceof window.DocumentTouch)\n\n  // Does the browser support PointerEvents\n  // https://github.com/taye/interact.js/issues/703#issuecomment-471570492\n  browser.supportsPointerEvent = (navigator as any).pointerEnabled !== false && !!domObjects.PointerEvent\n\n  browser.isIOS = /iP(hone|od|ad)/.test(navigator.platform)\n\n  // scrolling doesn't change the result of getClientRects on iOS 7\n  browser.isIOS7 = /iP(hone|od|ad)/.test(navigator.platform) && /OS 7[^\\d]/.test(navigator.appVersion)\n\n  browser.isIe9 = /MSIE 9/.test(navigator.userAgent)\n\n  // Opera Mobile must be handled differently\n  browser.isOperaMobile =\n    navigator.appName === 'Opera' && browser.supportsTouch && /Presto/.test(navigator.userAgent)\n\n  // prefix matchesSelector\n  browser.prefixedMatchesSelector = (\n    'matches' in Element.prototype\n      ? 'matches'\n      : 'webkitMatchesSelector' in Element.prototype\n        ? 'webkitMatchesSelector'\n        : 'mozMatchesSelector' in Element.prototype\n          ? 'mozMatchesSelector'\n          : 'oMatchesSelector' in Element.prototype\n            ? 'oMatchesSelector'\n            : 'msMatchesSelector'\n  ) as 'matches'\n\n  browser.pEventTypes = browser.supportsPointerEvent\n    ? domObjects.PointerEvent === window.MSPointerEvent\n      ? {\n          up: 'MSPointerUp',\n          down: 'MSPointerDown',\n          over: 'mouseover',\n          out: 'mouseout',\n          move: 'MSPointerMove',\n          cancel: 'MSPointerCancel',\n        }\n      : {\n          up: 'pointerup',\n          down: 'pointerdown',\n          over: 'pointerover',\n          out: 'pointerout',\n          move: 'pointermove',\n          cancel: 'pointercancel',\n        }\n    : null\n\n  // because Webkit and Opera still use 'mousewheel' event type\n  browser.wheelEvent = domObjects.document && 'onmousewheel' in domObjects.document ? 'mousewheel' : 'wheel'\n}\n\nexport default browser\n", "import * as arr from './arr'\nimport is from './is'\n\n// tslint:disable-next-line ban-types\nexport default function clone<T extends Object>(source: T): Partial<T> {\n  const dest = {} as Partial<T>\n\n  for (const prop in source) {\n    const value = source[prop]\n\n    if (is.plainObject(value)) {\n      dest[prop] = clone(value) as any\n    } else if (is.array(value)) {\n      dest[prop] = arr.from(value) as typeof value\n    } else {\n      dest[prop] = value\n    }\n  }\n\n  return dest\n}\n", "import type { Rect, Target, Element } from '@interactjs/core/types'\n\nimport browser from './browser'\nimport domObjects from './domObjects'\nimport is from './is'\nimport * as win from './window'\n\nexport function nodeContains(parent: Node, child: Node) {\n  if (parent.contains) {\n    return parent.contains(child as Node)\n  }\n\n  while (child) {\n    if (child === parent) {\n      return true\n    }\n\n    child = (child as Node).parentNode\n  }\n\n  return false\n}\n\nexport function closest(element: Node, selector: string) {\n  while (is.element(element)) {\n    if (matchesSelector(element, selector)) {\n      return element\n    }\n\n    element = parentNode(element)\n  }\n\n  return null\n}\n\nexport function parentNode(node: Node | Document) {\n  let parent = node.parentNode\n\n  if (is.docFrag(parent)) {\n    // skip past #shado-root fragments\n    // tslint:disable-next-line\n    while ((parent = (parent as any).host) && is.docFrag(parent)) {\n      continue\n    }\n\n    return parent\n  }\n\n  return parent\n}\n\nexport function matchesSelector(element: Element, selector: string) {\n  // remove /deep/ from selectors if shadowDOM polyfill is used\n  if (win.window !== win.realWindow) {\n    selector = selector.replace(/\\/deep\\//g, ' ')\n  }\n\n  return element[browser.prefixedMatchesSelector](selector)\n}\n\nconst getParent = (el: Node | Document | ShadowRoot) => el.parentNode || (el as ShadowRoot).host\n\n// Test for the element that's \"above\" all other qualifiers\nexport function indexOfDeepestElement(elements: Element[] | NodeListOf<globalThis.Element>) {\n  let deepestNodeParents: Node[] = []\n  let deepestNodeIndex: number\n\n  for (let i = 0; i < elements.length; i++) {\n    const currentNode = elements[i]\n    const deepestNode: Node = elements[deepestNodeIndex]\n\n    // node may appear in elements array multiple times\n    if (!currentNode || i === deepestNodeIndex) {\n      continue\n    }\n\n    if (!deepestNode) {\n      deepestNodeIndex = i\n      continue\n    }\n\n    const currentNodeParent = getParent(currentNode)\n    const deepestNodeParent = getParent(deepestNode)\n\n    // check if the deepest or current are document.documentElement/rootElement\n    // - if the current node is, do nothing and continue\n    if (currentNodeParent === currentNode.ownerDocument) {\n      continue\n    }\n    // - if deepest is, update with the current node and continue to next\n    else if (deepestNodeParent === currentNode.ownerDocument) {\n      deepestNodeIndex = i\n      continue\n    }\n\n    // compare zIndex of siblings\n    if (currentNodeParent === deepestNodeParent) {\n      if (zIndexIsHigherThan(currentNode, deepestNode)) {\n        deepestNodeIndex = i\n      }\n\n      continue\n    }\n\n    // populate the ancestry array for the latest deepest node\n    deepestNodeParents = deepestNodeParents.length ? deepestNodeParents : getNodeParents(deepestNode)\n\n    let ancestryStart: Node\n\n    // if the deepest node is an HTMLElement and the current node is a non root svg element\n    if (\n      deepestNode instanceof domObjects.HTMLElement &&\n      currentNode instanceof domObjects.SVGElement &&\n      !(currentNode instanceof domObjects.SVGSVGElement)\n    ) {\n      // TODO: is this check necessary? Was this for HTML elements embedded in SVG?\n      if (currentNode === deepestNodeParent) {\n        continue\n      }\n\n      ancestryStart = currentNode.ownerSVGElement\n    } else {\n      ancestryStart = currentNode\n    }\n\n    const currentNodeParents = getNodeParents(ancestryStart, deepestNode.ownerDocument)\n    let commonIndex = 0\n\n    // get (position of closest common ancestor) + 1\n    while (\n      currentNodeParents[commonIndex] &&\n      currentNodeParents[commonIndex] === deepestNodeParents[commonIndex]\n    ) {\n      commonIndex++\n    }\n\n    const parents = [\n      currentNodeParents[commonIndex - 1],\n      currentNodeParents[commonIndex],\n      deepestNodeParents[commonIndex],\n    ]\n\n    if (parents[0]) {\n      let child = parents[0].lastChild\n\n      while (child) {\n        if (child === parents[1]) {\n          deepestNodeIndex = i\n          deepestNodeParents = currentNodeParents\n\n          break\n        } else if (child === parents[2]) {\n          break\n        }\n\n        child = child.previousSibling\n      }\n    }\n  }\n\n  return deepestNodeIndex\n}\n\nfunction getNodeParents(node: Node, limit?: Node) {\n  const parents: Node[] = []\n  let parent: Node = node\n  let parentParent: Node\n\n  while ((parentParent = getParent(parent)) && parent !== limit && parentParent !== parent.ownerDocument) {\n    parents.unshift(parent)\n    parent = parentParent\n  }\n\n  return parents\n}\n\nfunction zIndexIsHigherThan(higherNode: Node, lowerNode: Node) {\n  const higherIndex = parseInt(win.getWindow(higherNode).getComputedStyle(higherNode).zIndex, 10) || 0\n  const lowerIndex = parseInt(win.getWindow(lowerNode).getComputedStyle(lowerNode).zIndex, 10) || 0\n\n  return higherIndex >= lowerIndex\n}\n\nexport function matchesUpTo(element: Element, selector: string, limit: Node) {\n  while (is.element(element)) {\n    if (matchesSelector(element, selector)) {\n      return true\n    }\n\n    element = parentNode(element) as Element\n\n    if (element === limit) {\n      return matchesSelector(element, selector)\n    }\n  }\n\n  return false\n}\n\nexport function getActualElement(element: Element) {\n  return (element as any).correspondingUseElement || element\n}\n\nexport function getScrollXY(relevantWindow?: Window) {\n  relevantWindow = relevantWindow || win.window\n  return {\n    x: relevantWindow.scrollX || relevantWindow.document.documentElement.scrollLeft,\n    y: relevantWindow.scrollY || relevantWindow.document.documentElement.scrollTop,\n  }\n}\n\nexport function getElementClientRect(element: Element): Required<Rect> {\n  const clientRect =\n    element instanceof domObjects.SVGElement ? element.getBoundingClientRect() : element.getClientRects()[0]\n\n  return (\n    clientRect && {\n      left: clientRect.left,\n      right: clientRect.right,\n      top: clientRect.top,\n      bottom: clientRect.bottom,\n      width: clientRect.width || clientRect.right - clientRect.left,\n      height: clientRect.height || clientRect.bottom - clientRect.top,\n    }\n  )\n}\n\nexport function getElementRect(element: Element) {\n  const clientRect = getElementClientRect(element)\n\n  if (!browser.isIOS7 && clientRect) {\n    const scroll = getScrollXY(win.getWindow(element))\n\n    clientRect.left += scroll.x\n    clientRect.right += scroll.x\n    clientRect.top += scroll.y\n    clientRect.bottom += scroll.y\n  }\n\n  return clientRect\n}\n\nexport function getPath(node: Node | Document) {\n  const path = []\n\n  while (node) {\n    path.push(node)\n    node = parentNode(node)\n  }\n\n  return path\n}\n\nexport function trySelector(value: Target) {\n  if (!is.string(value)) {\n    return false\n  }\n\n  // an exception will be raised if it is invalid\n  domObjects.document.querySelector(value)\n  return true\n}\n", "export default function extend<T, U extends object>(dest: U & Partial<T>, source: T): T & U {\n  for (const prop in source) {\n    ;(dest as unknown as T)[prop] = source[prop]\n  }\n\n  const ret = dest as T & U\n\n  return ret\n}\n", "import type { Actions } from '@interactjs/core/types'\n\nexport default function isNonNativeEvent(type: string, actions: Actions) {\n  if (actions.phaselessTypes[type]) {\n    return true\n  }\n\n  for (const name in actions.map) {\n    if (type.indexOf(name) === 0 && type.substr(name.length) in actions.phases) {\n      return true\n    }\n  }\n\n  return false\n}\n", "import type { EventTypes, Listener, ListenersArg } from '@interactjs/core/types'\n\nimport is from './is'\n\nexport interface NormalizedListeners {\n  [type: string]: Listener[]\n}\n\nexport default function normalize(\n  type: EventTypes,\n  listeners?: ListenersArg | ListenersArg[] | null,\n  filter = (_typeOrPrefix: string) => true,\n  result?: NormalizedListeners,\n): NormalizedListeners {\n  result = result || {}\n\n  if (is.string(type) && type.search(' ') !== -1) {\n    type = split(type)\n  }\n\n  if (is.array(type)) {\n    type.forEach((t) => normalize(t, listeners, filter, result))\n    return result\n  }\n\n  // before:  type = [{ drag: () => {} }], listeners = undefined\n  // after:   type = ''                  , listeners = [{ drag: () => {} }]\n  if (is.object(type)) {\n    listeners = type\n    type = ''\n  }\n\n  if (is.func(listeners) && filter(type)) {\n    result[type] = result[type] || []\n    result[type].push(listeners)\n  } else if (is.array(listeners)) {\n    for (const l of listeners) {\n      normalize(type, l, filter, result)\n    }\n  } else if (is.object(listeners)) {\n    for (const prefix in listeners) {\n      const combinedTypes = split(prefix).map((p) => `${type}${p}`)\n\n      normalize(combinedTypes, listeners[prefix], filter, result)\n    }\n  }\n\n  return result as NormalizedListeners\n}\n\nfunction split(type: string) {\n  return type.trim().split(/ +/)\n}\n", "import * as arr from '@interactjs/utils/arr'\nimport extend from '@interactjs/utils/extend'\nimport type { NormalizedListeners } from '@interactjs/utils/normalizeListeners'\nimport normalize from '@interactjs/utils/normalizeListeners'\n\nimport type { Listener, ListenersArg, Rect } from '@interactjs/core/types'\n\nfunction fireUntilImmediateStopped(event: any, listeners: Listener[]) {\n  for (const listener of listeners) {\n    if (event.immediatePropagationStopped) {\n      break\n    }\n\n    listener(event)\n  }\n}\n\nexport class Eventable {\n  options: any\n  types: NormalizedListeners = {}\n  propagationStopped = false\n  immediatePropagationStopped = false\n  global: any\n\n  constructor(options?: { [index: string]: any }) {\n    this.options = extend({}, options || {})\n  }\n\n  fire<T extends { type: string; propagationStopped?: boolean }>(event: T) {\n    let listeners: Listener[]\n    const global = this.global\n\n    // Interactable#on() listeners\n    // tslint:disable no-conditional-assignment\n    if ((listeners = this.types[event.type])) {\n      fireUntilImmediateStopped(event, listeners)\n    }\n\n    // interact.on() listeners\n    if (!event.propagationStopped && global && (listeners = global[event.type])) {\n      fireUntilImmediateStopped(event, listeners)\n    }\n  }\n\n  on(type: string, listener: ListenersArg) {\n    const listeners = normalize(type, listener)\n\n    for (type in listeners) {\n      this.types[type] = arr.merge(this.types[type] || [], listeners[type])\n    }\n  }\n\n  off(type: string, listener: ListenersArg) {\n    const listeners = normalize(type, listener)\n\n    for (type in listeners) {\n      const eventList = this.types[type]\n\n      if (!eventList || !eventList.length) {\n        continue\n      }\n\n      for (const subListener of listeners[type]) {\n        const index = eventList.indexOf(subListener)\n\n        if (index !== -1) {\n          eventList.splice(index, 1)\n        }\n      }\n    }\n  }\n\n  getRect(_element: Element): Rect {\n    return null\n  }\n}\n", "/* eslint-disable no-dupe-class-members */\nimport * as arr from '@interactjs/utils/arr'\nimport browser from '@interactjs/utils/browser'\nimport clone from '@interactjs/utils/clone'\nimport { getElementRect, matchesUpTo, nodeContains, trySelector } from '@interactjs/utils/domUtils'\nimport extend from '@interactjs/utils/extend'\nimport is from '@interactjs/utils/is'\nimport isNonNativeEvent from '@interactjs/utils/isNonNativeEvent'\nimport normalizeListeners from '@interactjs/utils/normalizeListeners'\nimport { getWindow } from '@interactjs/utils/window'\n\nimport type { Scope } from '@interactjs/core/scope'\nimport type {\n  ActionMap,\n  ActionMethod,\n  ActionName,\n  Actions,\n  Context,\n  Element,\n  EventTypes,\n  Listeners,\n  ListenersArg,\n  OrBoolean,\n  Target,\n} from '@interactjs/core/types'\n\nimport { Eventable } from './Eventable'\nimport type { ActionDefaults, Defaults, OptionsArg, PerActionDefaults, Options } from './options'\n\ntype IgnoreValue = string | Element | boolean\ntype DeltaSource = 'page' | 'client'\n\nconst enum OnOffMethod {\n  On,\n  Off,\n}\n\n/**\n * ```ts\n * const interactable = interact('.cards')\n *   .draggable({\n *     listeners: { move: event => console.log(event.type, event.pageX, event.pageY) }\n *   })\n *   .resizable({\n *     listeners: { move: event => console.log(event.rect) },\n *     modifiers: [interact.modifiers.restrictEdges({ outer: 'parent' })]\n *   })\n * ```\n */\nexport class Interactable implements Partial<Eventable> {\n  /** @internal */ get _defaults(): Defaults {\n    return {\n      base: {},\n      perAction: {},\n      actions: {} as ActionDefaults,\n    }\n  }\n\n  readonly target: Target\n  /** @internal */ readonly options!: Required<Options>\n  /** @internal */ readonly _actions: Actions\n  /** @internal */ readonly events = new Eventable()\n  /** @internal */ readonly _context: Context\n  /** @internal */ readonly _win: Window\n  /** @internal */ readonly _doc: Document\n  /** @internal */ readonly _scopeEvents: Scope['events']\n\n  constructor(\n    target: Target,\n    options: any,\n    defaultContext: Document | Element,\n    scopeEvents: Scope['events'],\n  ) {\n    this._actions = options.actions\n    this.target = target\n    this._context = options.context || defaultContext\n    this._win = getWindow(trySelector(target) ? this._context : target)\n    this._doc = this._win.document\n    this._scopeEvents = scopeEvents\n\n    this.set(options)\n  }\n\n  setOnEvents(actionName: ActionName, phases: NonNullable<any>) {\n    if (is.func(phases.onstart)) {\n      this.on(`${actionName}start`, phases.onstart)\n    }\n    if (is.func(phases.onmove)) {\n      this.on(`${actionName}move`, phases.onmove)\n    }\n    if (is.func(phases.onend)) {\n      this.on(`${actionName}end`, phases.onend)\n    }\n    if (is.func(phases.oninertiastart)) {\n      this.on(`${actionName}inertiastart`, phases.oninertiastart)\n    }\n\n    return this\n  }\n\n  updatePerActionListeners(actionName: ActionName, prev: Listeners | undefined, cur: Listeners | undefined) {\n    const actionFilter = (this._actions.map[actionName] as { filterEventType?: (type: string) => boolean })\n      ?.filterEventType\n    const filter = (type: string) =>\n      (actionFilter == null || actionFilter(type)) && isNonNativeEvent(type, this._actions)\n\n    if (is.array(prev) || is.object(prev)) {\n      this._onOff(OnOffMethod.Off, actionName, prev, undefined, filter)\n    }\n\n    if (is.array(cur) || is.object(cur)) {\n      this._onOff(OnOffMethod.On, actionName, cur, undefined, filter)\n    }\n  }\n\n  setPerAction(actionName: ActionName, options: OrBoolean<Options>) {\n    const defaults = this._defaults\n\n    // for all the default per-action options\n    for (const optionName_ in options) {\n      const optionName = optionName_ as keyof PerActionDefaults\n      const actionOptions = this.options[actionName]\n      const optionValue: any = options[optionName]\n\n      // remove old event listeners and add new ones\n      if (optionName === 'listeners') {\n        this.updatePerActionListeners(actionName, actionOptions.listeners, optionValue as Listeners)\n      }\n\n      // if the option value is an array\n      if (is.array(optionValue)) {\n        ;(actionOptions[optionName] as any) = arr.from(optionValue)\n      }\n      // if the option value is an object\n      else if (is.plainObject(optionValue)) {\n        // copy the object\n        ;(actionOptions[optionName] as any) = extend(\n          actionOptions[optionName] || ({} as any),\n          clone(optionValue),\n        )\n\n        // set anabled field to true if it exists in the defaults\n        if (\n          is.object(defaults.perAction[optionName]) &&\n          'enabled' in (defaults.perAction[optionName] as any)\n        ) {\n          ;(actionOptions[optionName] as any).enabled = optionValue.enabled !== false\n        }\n      }\n      // if the option value is a boolean and the default is an object\n      else if (is.bool(optionValue) && is.object(defaults.perAction[optionName])) {\n        ;(actionOptions[optionName] as any).enabled = optionValue\n      }\n      // if it's anything else, do a plain assignment\n      else {\n        ;(actionOptions[optionName] as any) = optionValue\n      }\n    }\n  }\n\n  /**\n   * The default function to get an Interactables bounding rect. Can be\n   * overridden using {@link Interactable.rectChecker}.\n   *\n   * @param {Element} [element] The element to measure.\n   * @return {Rect} The object's bounding rectangle.\n   */\n  getRect(element: Element) {\n    element = element || (is.element(this.target) ? this.target : null)\n\n    if (is.string(this.target)) {\n      element = element || this._context.querySelector(this.target)\n    }\n\n    return getElementRect(element)\n  }\n\n  /**\n   * Returns or sets the function used to calculate the interactable's\n   * element's rectangle\n   *\n   * @param {function} [checker] A function which returns this Interactable's\n   * bounding rectangle. See {@link Interactable.getRect}\n   * @return {function | object} The checker function or this Interactable\n   */\n  rectChecker(): (element: Element) => any | null\n  rectChecker(checker: (element: Element) => any): this\n  rectChecker(checker?: (element: Element) => any) {\n    if (is.func(checker)) {\n      this.getRect = (element) => {\n        const rect = extend({}, checker.apply(this, element))\n\n        if (!(('width' in rect) as unknown)) {\n          rect.width = rect.right - rect.left\n          rect.height = rect.bottom - rect.top\n        }\n\n        return rect\n      }\n\n      return this\n    }\n\n    if (checker === null) {\n      delete (this as Partial<typeof this>).getRect\n\n      return this\n    }\n\n    return this.getRect\n  }\n\n  /** @internal */\n  _backCompatOption(optionName: keyof Options, newValue: any) {\n    if (trySelector(newValue) || is.object(newValue)) {\n      ;(this.options[optionName] as any) = newValue\n\n      for (const action in this._actions.map) {\n        ;(this.options[action as keyof ActionMap] as any)[optionName] = newValue\n      }\n\n      return this\n    }\n\n    return this.options[optionName]\n  }\n\n  /**\n   * Gets or sets the origin of the Interactable's element.  The x and y\n   * of the origin will be subtracted from action event coordinates.\n   *\n   * @param {Element | object | string} [origin] An HTML or SVG Element whose\n   * rect will be used, an object eg. { x: 0, y: 0 } or string 'parent', 'self'\n   * or any CSS selector\n   *\n   * @return {object} The current origin or this Interactable\n   */\n  origin(newValue: any) {\n    return this._backCompatOption('origin', newValue)\n  }\n\n  /**\n   * Returns or sets the mouse coordinate types used to calculate the\n   * movement of the pointer.\n   *\n   * @param {string} [newValue] Use 'client' if you will be scrolling while\n   * interacting; Use 'page' if you want autoScroll to work\n   * @return {string | object} The current deltaSource or this Interactable\n   */\n  deltaSource(): DeltaSource\n  deltaSource(newValue: DeltaSource): this\n  deltaSource(newValue?: DeltaSource) {\n    if (newValue === 'page' || newValue === 'client') {\n      this.options.deltaSource = newValue\n\n      return this\n    }\n\n    return this.options.deltaSource\n  }\n\n  /** @internal */\n  getAllElements(): Element[] {\n    const { target } = this\n\n    if (is.string(target)) {\n      return Array.from(this._context.querySelectorAll(target))\n    }\n\n    if (is.func(target) && (target as any).getAllElements) {\n      return (target as any).getAllElements()\n    }\n\n    return is.element(target) ? [target] : []\n  }\n\n  /**\n   * Gets the selector context Node of the Interactable. The default is\n   * `window.document`.\n   *\n   * @return {Node} The context Node of this Interactable\n   */\n  context() {\n    return this._context\n  }\n\n  inContext(element: Document | Node) {\n    return this._context === element.ownerDocument || nodeContains(this._context, element)\n  }\n\n  /** @internal */\n  testIgnoreAllow(\n    this: Interactable,\n    options: { ignoreFrom?: IgnoreValue; allowFrom?: IgnoreValue },\n    targetNode: Node,\n    eventTarget: Node,\n  ) {\n    return (\n      !this.testIgnore(options.ignoreFrom, targetNode, eventTarget) &&\n      this.testAllow(options.allowFrom, targetNode, eventTarget)\n    )\n  }\n\n  /** @internal */\n  testAllow(this: Interactable, allowFrom: IgnoreValue | undefined, targetNode: Node, element: Node) {\n    if (!allowFrom) {\n      return true\n    }\n\n    if (!is.element(element)) {\n      return false\n    }\n\n    if (is.string(allowFrom)) {\n      return matchesUpTo(element, allowFrom, targetNode)\n    } else if (is.element(allowFrom)) {\n      return nodeContains(allowFrom, element)\n    }\n\n    return false\n  }\n\n  /** @internal */\n  testIgnore(this: Interactable, ignoreFrom: IgnoreValue | undefined, targetNode: Node, element: Node) {\n    if (!ignoreFrom || !is.element(element)) {\n      return false\n    }\n\n    if (is.string(ignoreFrom)) {\n      return matchesUpTo(element, ignoreFrom, targetNode)\n    } else if (is.element(ignoreFrom)) {\n      return nodeContains(ignoreFrom, element)\n    }\n\n    return false\n  }\n\n  /**\n   * Calls listeners for the given InteractEvent type bound globally\n   * and directly to this Interactable\n   *\n   * @param {InteractEvent} iEvent The InteractEvent object to be fired on this\n   * Interactable\n   * @return {Interactable} this Interactable\n   */\n  fire<E extends { type: string }>(iEvent: E) {\n    this.events.fire(iEvent)\n\n    return this\n  }\n\n  /** @internal */\n  _onOff(\n    method: OnOffMethod,\n    typeArg: EventTypes,\n    listenerArg?: ListenersArg | null,\n    options?: any,\n    filter?: (type: string) => boolean,\n  ) {\n    if (is.object(typeArg) && !is.array(typeArg)) {\n      options = listenerArg\n      listenerArg = null\n    }\n\n    const listeners = normalizeListeners(typeArg, listenerArg, filter)\n\n    for (let type in listeners) {\n      if (type === 'wheel') {\n        type = browser.wheelEvent\n      }\n\n      for (const listener of listeners[type]) {\n        // if it is an action event type\n        if (isNonNativeEvent(type, this._actions)) {\n          this.events[method === OnOffMethod.On ? 'on' : 'off'](type, listener)\n        }\n        // delegated event\n        else if (is.string(this.target)) {\n          this._scopeEvents[method === OnOffMethod.On ? 'addDelegate' : 'removeDelegate'](\n            this.target,\n            this._context,\n            type,\n            listener,\n            options,\n          )\n        }\n        // remove listener from this Interactable's element\n        else {\n          this._scopeEvents[method === OnOffMethod.On ? 'add' : 'remove'](\n            this.target,\n            type,\n            listener,\n            options,\n          )\n        }\n      }\n    }\n\n    return this\n  }\n\n  /**\n   * Binds a listener for an InteractEvent, pointerEvent or DOM event.\n   *\n   * @param {string | array | object} types The types of events to listen\n   * for\n   * @param {function | array | object} [listener] The event listener function(s)\n   * @param {object | boolean} [options] options object or useCapture flag for\n   * addEventListener\n   * @return {Interactable} This Interactable\n   */\n  on(types: EventTypes, listener?: ListenersArg, options?: any) {\n    return this._onOff(OnOffMethod.On, types, listener, options)\n  }\n\n  /**\n   * Removes an InteractEvent, pointerEvent or DOM event listener.\n   *\n   * @param {string | array | object} types The types of events that were\n   * listened for\n   * @param {function | array | object} [listener] The event listener function(s)\n   * @param {object | boolean} [options] options object or useCapture flag for\n   * removeEventListener\n   * @return {Interactable} This Interactable\n   */\n  off(types: string | string[] | EventTypes, listener?: ListenersArg, options?: any) {\n    return this._onOff(OnOffMethod.Off, types, listener, options)\n  }\n\n  /**\n   * Reset the options of this Interactable\n   *\n   * @param {object} options The new settings to apply\n   * @return {object} This Interactable\n   */\n  set(options: OptionsArg) {\n    const defaults = this._defaults\n\n    if (!is.object(options)) {\n      options = {}\n    }\n\n    ;(this.options as Required<Options>) = clone(defaults.base) as Required<Options>\n\n    for (const actionName_ in this._actions.methodDict) {\n      const actionName = actionName_ as ActionName\n      const methodName = this._actions.methodDict[actionName]\n\n      this.options[actionName] = {}\n      this.setPerAction(actionName, extend(extend({}, defaults.perAction), defaults.actions[actionName]))\n      ;(this[methodName] as ActionMethod<unknown>)(options[actionName])\n    }\n\n    for (const setting in options) {\n      if (setting === 'getRect') {\n        this.rectChecker(options.getRect)\n        continue\n      }\n\n      if (is.func((this as any)[setting])) {\n        ;(this as any)[setting](options[setting as keyof typeof options])\n      }\n    }\n\n    return this\n  }\n\n  /**\n   * Remove this interactable from the list of interactables and remove it's\n   * action capabilities and event listeners\n   */\n  unset() {\n    if (is.string(this.target)) {\n      // remove delegated events\n      for (const type in this._scopeEvents.delegatedEvents) {\n        const delegated = this._scopeEvents.delegatedEvents[type]\n\n        for (let i = delegated.length - 1; i >= 0; i--) {\n          const { selector, context, listeners } = delegated[i]\n\n          if (selector === this.target && context === this._context) {\n            delegated.splice(i, 1)\n          }\n\n          for (let l = listeners.length - 1; l >= 0; l--) {\n            this._scopeEvents.removeDelegate(\n              this.target,\n              this._context,\n              type,\n              listeners[l][0],\n              listeners[l][1],\n            )\n          }\n        }\n      }\n    } else {\n      this._scopeEvents.remove(this.target, 'all')\n    }\n  }\n}\n"],
  "mappings": "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",
  "names": ["merge", "target", "source", "item", "push", "from", "findIndex", "array", "func", "i", "length", "find", "domObjects", "init", "document", "DocumentFragment", "SVGElement", "SVGSVGElement", "SVGElementInstance", "Element", "HTMLElement", "Event", "Touch", "PointerEvent", "blank", "window", "win", "MSPointerEvent", "realWindow", "win", "init", "undefined", "window", "getWindow", "node", "isWindow", "rootNode", "ownerDocument", "window", "thing", "isWindow", "docFrag", "object", "nodeType", "func", "number", "bool", "string", "element", "_window", "win", "plainObject", "constructor", "test", "array", "init", "supportsTouch", "supportsPointerEvent", "isIOS7", "isIOS", "isIe9", "isOperaMobile", "prefixedMatchesSelector", "pEventTypes", "wheelEvent", "window", "Element", "domObjects", "browser", "navigator", "pointerEnabled", "platform", "up", "down", "over", "out", "move", "cancel", "clone", "source", "dest", "prop", "value", "is", "plainObject", "array", "arr", "nodeContains", "parent", "contains", "element", "closest", "selector", "matchesSelector", "parentNode", "node", "win", "element", "matchesUpTo", "selector", "matchesSelector", "parentNode", "getActualElement", "getScrollXY", "relevantWindow", "x", "scrollX", "document", "documentElement", "scrollLeft", "getElementClientRect", "clientRect", "left", "right", "top", "bottom", "width", "getElementRect", "browser", "isIOS7", "scroll", "trySelector", "value", "string", "domObjects", "extend", "dest", "source", "prop", "ret", "isNonNativeEvent", "type", "actions", "phaselessTypes", "name", "map", "indexOf", "substr", "length", "phases", "normalize", "listeners", "filter", "arguments", "length", "undefined", "result", "string", "type", "array", "forEach", "func", "combinedTypes", "split", "fireUntilImmediateStopped", "event", "listener", "Eventable", "options", "types", "propagationStopped", "immediatePropagationStopped", "global", "constructor", "fire", "listeners", "type", "on", "normalize", "off", "subListener", "eventList", "getRect", "_element", "OnOffMethod", "Interactable", "_defaults", "base", "perAction", "actions", "target", "constructor", "options", "_actions", "_context", "context", "defaultContext", "_win", "getWindow", "trySelector", "_doc", "document", "_scopeEvents", "scopeEvents", "set", "setOnEvents", "actionName", "phases", "is", "func", "onstart", "on", "onmove", "onend", "oninertiastart", "updatePerActionListeners", "prev", "cur", "_this$_actions$map$ac", "actionFilter", "map", "filterEventType", "filter", "type", "isNonNativeEvent", "array", "object", "_onOff", "Off", "undefined", "On", "setPerAction", "defaults", "optionName_", "optionName", "actionOptions", "optionValue", "listeners", "from", "plainObject", "extend", "clone", "enabled", "bool", "getRect", "element", "string", "querySelector", "getElementRect", "rectChecker", "checker", "rect", "apply", "width", "right", "left", "height", "bottom", "top", "_backCompatOption", "newValue", "action", "origin", "deltaSource", "getAllElements", "Array", "querySelectorAll", "inContext", "ownerDocument", "nodeContains", "testIgnoreAllow", "targetNode", "eventTarget", "testIgnore", "ignoreFrom", "testAllow", "allowFrom", "matchesUpTo", "fire", "iEvent", "events", "method", "typeArg", "listenerArg", "normalizeListeners", "browser", "wheelEvent", "listener", "types", "off", "actionName_", "methodDict", "methodName", "setting", "unset", "delegatedEvents", "delegated", "i", "length", "selector", "splice", "l", "removeDelegate", "remove"]
}
