import {
  Eventable,
  Interactable,
  browser,
  clone,
  closest,
  domObjects,
  extend,
  find,
  findIndex,
  getActualElement,
  getElementClientRect,
  getElementRect,
  getWindow,
  init,
  is,
  isNonNativeEvent,
  matchesSelector,
  nodeContains,
  parentNode,
  win
} from "./chunk-PAETVFDA.js";

// node_modules/.pnpm/@interactjs+utils@1.10.27/node_modules/@interactjs/utils/raf.js
var lastTime = 0;
var request;
var cancel;
function init2(global) {
  request = global.requestAnimationFrame;
  cancel = global.cancelAnimationFrame;
  if (!request) {
    const vendors = ["ms", "moz", "webkit", "o"];
    for (const vendor of vendors) {
      request = global[`${vendor}RequestAnimationFrame`];
      cancel = global[`${vendor}CancelAnimationFrame`] || global[`${vendor}CancelRequestAnimationFrame`];
    }
  }
  request = request && request.bind(global);
  cancel = cancel && cancel.bind(global);
  if (!request) {
    request = (callback) => {
      const currTime = Date.now();
      const timeToCall = Math.max(0, 16 - (currTime - lastTime));
      const token = global.setTimeout(() => {
        callback(currTime + timeToCall);
      }, timeToCall);
      lastTime = currTime + timeToCall;
      return token;
    };
    cancel = (token) => clearTimeout(token);
  }
}
var raf = {
  request: (callback) => request(callback),
  cancel: (token) => cancel(token),
  init: init2
};

// node_modules/.pnpm/@interactjs+utils@1.10.27/node_modules/@interactjs/utils/pointerExtend.js
var VENDOR_PREFIXES = ["webkit", "moz"];
function pointerExtend(dest, source) {
  dest.__set || (dest.__set = {});
  for (const prop in source) {
    if (VENDOR_PREFIXES.some((prefix) => prop.indexOf(prefix) === 0))
      continue;
    if (typeof dest[prop] !== "function" && prop !== "__set") {
      Object.defineProperty(dest, prop, {
        get() {
          if (prop in dest.__set)
            return dest.__set[prop];
          return dest.__set[prop] = source[prop];
        },
        set(value) {
          dest.__set[prop] = value;
        },
        configurable: true
      });
    }
  }
  return dest;
}

// node_modules/.pnpm/@interactjs+utils@1.10.27/node_modules/@interactjs/utils/hypot.js
var hypot = (x, y) => Math.sqrt(x * x + y * y);

// node_modules/.pnpm/@interactjs+utils@1.10.27/node_modules/@interactjs/utils/pointerUtils.js
function copyCoords(dest, src) {
  dest.page = dest.page || {};
  dest.page.x = src.page.x;
  dest.page.y = src.page.y;
  dest.client = dest.client || {};
  dest.client.x = src.client.x;
  dest.client.y = src.client.y;
  dest.timeStamp = src.timeStamp;
}
function setCoordDeltas(targetObj, prev, cur) {
  targetObj.page.x = cur.page.x - prev.page.x;
  targetObj.page.y = cur.page.y - prev.page.y;
  targetObj.client.x = cur.client.x - prev.client.x;
  targetObj.client.y = cur.client.y - prev.client.y;
  targetObj.timeStamp = cur.timeStamp - prev.timeStamp;
}
function setCoordVelocity(targetObj, delta) {
  const dt = Math.max(delta.timeStamp / 1e3, 1e-3);
  targetObj.page.x = delta.page.x / dt;
  targetObj.page.y = delta.page.y / dt;
  targetObj.client.x = delta.client.x / dt;
  targetObj.client.y = delta.client.y / dt;
  targetObj.timeStamp = dt;
}
function setZeroCoords(targetObj) {
  targetObj.page.x = 0;
  targetObj.page.y = 0;
  targetObj.client.x = 0;
  targetObj.client.y = 0;
}
function isNativePointer(pointer) {
  return pointer instanceof domObjects.Event || pointer instanceof domObjects.Touch;
}
function getXY(type, pointer, xy) {
  xy = xy || {};
  type = type || "page";
  xy.x = pointer[type + "X"];
  xy.y = pointer[type + "Y"];
  return xy;
}
function getPageXY(pointer, page) {
  page = page || {
    x: 0,
    y: 0
  };
  if (browser.isOperaMobile && isNativePointer(pointer)) {
    getXY("screen", pointer, page);
    page.x += window.scrollX;
    page.y += window.scrollY;
  } else {
    getXY("page", pointer, page);
  }
  return page;
}
function getClientXY(pointer, client) {
  client = client || {};
  if (browser.isOperaMobile && isNativePointer(pointer)) {
    getXY("screen", pointer, client);
  } else {
    getXY("client", pointer, client);
  }
  return client;
}
function getPointerId(pointer) {
  return is.number(pointer.pointerId) ? pointer.pointerId : pointer.identifier;
}
function setCoords(dest, pointers, timeStamp) {
  const pointer = pointers.length > 1 ? pointerAverage(pointers) : pointers[0];
  getPageXY(pointer, dest.page);
  getClientXY(pointer, dest.client);
  dest.timeStamp = timeStamp;
}
function getTouchPair(event) {
  const touches = [];
  if (is.array(event)) {
    touches[0] = event[0];
    touches[1] = event[1];
  } else {
    if (event.type === "touchend") {
      if (event.touches.length === 1) {
        touches[0] = event.touches[0];
        touches[1] = event.changedTouches[0];
      } else if (event.touches.length === 0) {
        touches[0] = event.changedTouches[0];
        touches[1] = event.changedTouches[1];
      }
    } else {
      touches[0] = event.touches[0];
      touches[1] = event.touches[1];
    }
  }
  return touches;
}
function pointerAverage(pointers) {
  const average = {
    pageX: 0,
    pageY: 0,
    clientX: 0,
    clientY: 0,
    screenX: 0,
    screenY: 0
  };
  for (const pointer of pointers) {
    for (const prop in average) {
      average[prop] += pointer[prop];
    }
  }
  for (const prop in average) {
    average[prop] /= pointers.length;
  }
  return average;
}
function touchBBox(event) {
  if (!event.length) {
    return null;
  }
  const touches = getTouchPair(event);
  const minX = Math.min(touches[0].pageX, touches[1].pageX);
  const minY = Math.min(touches[0].pageY, touches[1].pageY);
  const maxX = Math.max(touches[0].pageX, touches[1].pageX);
  const maxY = Math.max(touches[0].pageY, touches[1].pageY);
  return {
    x: minX,
    y: minY,
    left: minX,
    top: minY,
    right: maxX,
    bottom: maxY,
    width: maxX - minX,
    height: maxY - minY
  };
}
function touchDistance(event, deltaSource) {
  const sourceX = deltaSource + "X";
  const sourceY = deltaSource + "Y";
  const touches = getTouchPair(event);
  const dx = touches[0][sourceX] - touches[1][sourceX];
  const dy = touches[0][sourceY] - touches[1][sourceY];
  return hypot(dx, dy);
}
function touchAngle(event, deltaSource) {
  const sourceX = deltaSource + "X";
  const sourceY = deltaSource + "Y";
  const touches = getTouchPair(event);
  const dx = touches[1][sourceX] - touches[0][sourceX];
  const dy = touches[1][sourceY] - touches[0][sourceY];
  const angle = 180 * Math.atan2(dy, dx) / Math.PI;
  return angle;
}
function getPointerType(pointer) {
  return is.string(pointer.pointerType) ? pointer.pointerType : is.number(pointer.pointerType) ? [void 0, void 0, "touch", "pen", "mouse"][pointer.pointerType] : /touch/.test(pointer.type || "") || pointer instanceof domObjects.Touch ? "touch" : "mouse";
}
function getEventTargets(event) {
  const path = is.func(event.composedPath) ? event.composedPath() : event.path;
  return [getActualElement(path ? path[0] : event.target), getActualElement(event.currentTarget)];
}
function newCoords() {
  return {
    page: {
      x: 0,
      y: 0
    },
    client: {
      x: 0,
      y: 0
    },
    timeStamp: 0
  };
}

// node_modules/.pnpm/@interactjs+core@1.10.27_@interactjs+utils@1.10.27/node_modules/@interactjs/core/events.js
function install(scope2) {
  var _scope$document;
  const targets = [];
  const delegatedEvents = {};
  const documents = [];
  const eventsMethods = {
    add,
    remove,
    addDelegate,
    removeDelegate,
    delegateListener,
    delegateUseCapture,
    delegatedEvents,
    documents,
    targets,
    supportsOptions: false,
    supportsPassive: false
  };
  (_scope$document = scope2.document) == null ? void 0 : _scope$document.createElement("div").addEventListener("test", null, {
    get capture() {
      return eventsMethods.supportsOptions = true;
    },
    get passive() {
      return eventsMethods.supportsPassive = true;
    }
  });
  scope2.events = eventsMethods;
  function add(eventTarget, type, listener, optionalArg) {
    if (!eventTarget.addEventListener)
      return;
    const options = getOptions(optionalArg);
    let target = find(targets, (t) => t.eventTarget === eventTarget);
    if (!target) {
      target = {
        eventTarget,
        events: {}
      };
      targets.push(target);
    }
    if (!target.events[type]) {
      target.events[type] = [];
    }
    if (!find(target.events[type], (l) => l.func === listener && optionsMatch(l.options, options))) {
      eventTarget.addEventListener(type, listener, eventsMethods.supportsOptions ? options : options.capture);
      target.events[type].push({
        func: listener,
        options
      });
    }
  }
  function remove(eventTarget, type, listener, optionalArg) {
    if (!eventTarget.addEventListener || !eventTarget.removeEventListener)
      return;
    const targetIndex = findIndex(targets, (t) => t.eventTarget === eventTarget);
    const target = targets[targetIndex];
    if (!target || !target.events) {
      return;
    }
    if (type === "all") {
      for (type in target.events) {
        if (target.events.hasOwnProperty(type)) {
          remove(eventTarget, type, "all");
        }
      }
      return;
    }
    let typeIsEmpty = false;
    const typeListeners = target.events[type];
    if (typeListeners) {
      if (listener === "all") {
        for (let i = typeListeners.length - 1; i >= 0; i--) {
          const entry = typeListeners[i];
          remove(eventTarget, type, entry.func, entry.options);
        }
        return;
      } else {
        const options = getOptions(optionalArg);
        for (let i = 0; i < typeListeners.length; i++) {
          const entry = typeListeners[i];
          if (entry.func === listener && optionsMatch(entry.options, options)) {
            eventTarget.removeEventListener(type, listener, eventsMethods.supportsOptions ? options : options.capture);
            typeListeners.splice(i, 1);
            if (typeListeners.length === 0) {
              delete target.events[type];
              typeIsEmpty = true;
            }
            break;
          }
        }
      }
    }
    if (typeIsEmpty && !Object.keys(target.events).length) {
      targets.splice(targetIndex, 1);
    }
  }
  function addDelegate(selector, context, type, listener, optionalArg) {
    const options = getOptions(optionalArg);
    if (!delegatedEvents[type]) {
      delegatedEvents[type] = [];
      for (const doc of documents) {
        add(doc, type, delegateListener);
        add(doc, type, delegateUseCapture, true);
      }
    }
    const delegates = delegatedEvents[type];
    let delegate = find(delegates, (d) => d.selector === selector && d.context === context);
    if (!delegate) {
      delegate = {
        selector,
        context,
        listeners: []
      };
      delegates.push(delegate);
    }
    delegate.listeners.push({
      func: listener,
      options
    });
  }
  function removeDelegate(selector, context, type, listener, optionalArg) {
    const options = getOptions(optionalArg);
    const delegates = delegatedEvents[type];
    let matchFound = false;
    let index;
    if (!delegates)
      return;
    for (index = delegates.length - 1; index >= 0; index--) {
      const cur = delegates[index];
      if (cur.selector === selector && cur.context === context) {
        const {
          listeners
        } = cur;
        for (let i = listeners.length - 1; i >= 0; i--) {
          const entry = listeners[i];
          if (entry.func === listener && optionsMatch(entry.options, options)) {
            listeners.splice(i, 1);
            if (!listeners.length) {
              delegates.splice(index, 1);
              remove(context, type, delegateListener);
              remove(context, type, delegateUseCapture, true);
            }
            matchFound = true;
            break;
          }
        }
        if (matchFound) {
          break;
        }
      }
    }
  }
  function delegateListener(event, optionalArg) {
    const options = getOptions(optionalArg);
    const fakeEvent = new FakeEvent(event);
    const delegates = delegatedEvents[event.type];
    const [eventTarget] = getEventTargets(event);
    let element = eventTarget;
    while (is.element(element)) {
      for (let i = 0; i < delegates.length; i++) {
        const cur = delegates[i];
        const {
          selector,
          context
        } = cur;
        if (matchesSelector(element, selector) && nodeContains(context, eventTarget) && nodeContains(context, element)) {
          const {
            listeners
          } = cur;
          fakeEvent.currentTarget = element;
          for (const entry of listeners) {
            if (optionsMatch(entry.options, options)) {
              entry.func(fakeEvent);
            }
          }
        }
      }
      element = parentNode(element);
    }
  }
  function delegateUseCapture(event) {
    return delegateListener.call(this, event, true);
  }
  return eventsMethods;
}
var FakeEvent = class {
  constructor(originalEvent) {
    this.currentTarget = void 0;
    this.originalEvent = void 0;
    this.type = void 0;
    this.originalEvent = originalEvent;
    pointerExtend(this, originalEvent);
  }
  preventOriginalDefault() {
    this.originalEvent.preventDefault();
  }
  stopPropagation() {
    this.originalEvent.stopPropagation();
  }
  stopImmediatePropagation() {
    this.originalEvent.stopImmediatePropagation();
  }
};
function getOptions(param) {
  if (!is.object(param)) {
    return {
      capture: !!param,
      passive: false
    };
  }
  return {
    capture: !!param.capture,
    passive: !!param.passive
  };
}
function optionsMatch(a, b) {
  if (a === b)
    return true;
  if (typeof a === "boolean")
    return !!b.capture === a && !!b.passive === false;
  return !!a.capture === !!b.capture && !!a.passive === !!b.passive;
}
var events = {
  id: "events",
  install
};

// node_modules/.pnpm/@interactjs+core@1.10.27_@interactjs+utils@1.10.27/node_modules/@interactjs/core/interactablePreventDefault.js
var preventDefault = function preventDefault2(newValue) {
  if (/^(always|never|auto)$/.test(newValue)) {
    this.options.preventDefault = newValue;
    return this;
  }
  if (is.bool(newValue)) {
    this.options.preventDefault = newValue ? "always" : "never";
    return this;
  }
  return this.options.preventDefault;
};
function checkAndPreventDefault(interactable, scope2, event) {
  const setting = interactable.options.preventDefault;
  if (setting === "never")
    return;
  if (setting === "always") {
    event.preventDefault();
    return;
  }
  if (scope2.events.supportsPassive && /^touch(start|move)$/.test(event.type)) {
    const doc = getWindow(event.target).document;
    const docOptions = scope2.getDocOptions(doc);
    if (!(docOptions && docOptions.events) || docOptions.events.passive !== false) {
      return;
    }
  }
  if (/^(mouse|pointer|touch)*(down|start)/i.test(event.type)) {
    return;
  }
  if (is.element(event.target) && matchesSelector(event.target, "input,select,textarea,[contenteditable=true],[contenteditable=true] *")) {
    return;
  }
  event.preventDefault();
}
function onInteractionEvent(_ref) {
  let {
    interaction,
    event
  } = _ref;
  if (interaction.interactable) {
    interaction.interactable.checkAndPreventDefault(event);
  }
}
function install2(scope2) {
  const {
    Interactable: Interactable2
  } = scope2;
  Interactable2.prototype.preventDefault = preventDefault;
  Interactable2.prototype.checkAndPreventDefault = function(event) {
    return checkAndPreventDefault(this, scope2, event);
  };
  scope2.interactions.docEvents.push({
    type: "dragstart",
    listener(event) {
      for (const interaction of scope2.interactions.list) {
        if (interaction.element && (interaction.element === event.target || nodeContains(interaction.element, event.target))) {
          interaction.interactable.checkAndPreventDefault(event);
          return;
        }
      }
    }
  });
}
var interactablePreventDefault = {
  id: "core/interactablePreventDefault",
  install: install2,
  listeners: ["down", "move", "up", "cancel"].reduce((acc, eventType) => {
    acc[`interactions:${eventType}`] = onInteractionEvent;
    return acc;
  }, {})
};

// node_modules/.pnpm/@interactjs+utils@1.10.27/node_modules/@interactjs/utils/misc.js
function warnOnce(method, message) {
  let warned = false;
  return function() {
    if (!warned) {
      win.console.warn(message);
      warned = true;
    }
    return method.apply(this, arguments);
  };
}
function copyAction(dest, src) {
  dest.name = src.name;
  dest.axis = src.axis;
  dest.edges = src.edges;
  return dest;
}

// node_modules/.pnpm/@interactjs+utils@1.10.27/node_modules/@interactjs/utils/rect.js
function getStringOptionResult(value, target, element) {
  if (value === "parent") {
    return parentNode(element);
  }
  if (value === "self") {
    return target.getRect(element);
  }
  return closest(element, value);
}
function resolveRectLike(value, target, element, functionArgs) {
  let returnValue = value;
  if (is.string(returnValue)) {
    returnValue = getStringOptionResult(returnValue, target, element);
  } else if (is.func(returnValue)) {
    returnValue = returnValue(...functionArgs);
  }
  if (is.element(returnValue)) {
    returnValue = getElementRect(returnValue);
  }
  return returnValue;
}
function rectToXY(rect) {
  return rect && {
    x: "x" in rect ? rect.x : rect.left,
    y: "y" in rect ? rect.y : rect.top
  };
}
function xywhToTlbr(rect) {
  if (rect && !("left" in rect && "top" in rect)) {
    rect = extend({}, rect);
    rect.left = rect.x || 0;
    rect.top = rect.y || 0;
    rect.right = rect.right || rect.left + rect.width;
    rect.bottom = rect.bottom || rect.top + rect.height;
  }
  return rect;
}
function tlbrToXywh(rect) {
  if (rect && !("x" in rect && "y" in rect)) {
    rect = extend({}, rect);
    rect.x = rect.left || 0;
    rect.y = rect.top || 0;
    rect.width = rect.width || (rect.right || 0) - rect.x;
    rect.height = rect.height || (rect.bottom || 0) - rect.y;
  }
  return rect;
}
function addEdges(edges, rect, delta) {
  if (edges.left) {
    rect.left += delta.x;
  }
  if (edges.right) {
    rect.right += delta.x;
  }
  if (edges.top) {
    rect.top += delta.y;
  }
  if (edges.bottom) {
    rect.bottom += delta.y;
  }
  rect.width = rect.right - rect.left;
  rect.height = rect.bottom - rect.top;
}

// node_modules/.pnpm/@interactjs+utils@1.10.27/node_modules/@interactjs/utils/getOriginXY.js
function getOriginXY(target, element, actionName) {
  const actionOptions = actionName && target.options[actionName];
  const actionOrigin = actionOptions && actionOptions.origin;
  const origin = actionOrigin || target.options.origin;
  const originRect = resolveRectLike(origin, target, element, [target && element]);
  return rectToXY(originRect) || {
    x: 0,
    y: 0
  };
}

// node_modules/.pnpm/@interactjs+core@1.10.27_@interactjs+utils@1.10.27/node_modules/@interactjs/core/BaseEvent.js
var BaseEvent = class {
  constructor(interaction) {
    this.immediatePropagationStopped = false;
    this.propagationStopped = false;
    this._interaction = interaction;
  }
  preventDefault() {
  }
  stopPropagation() {
    this.propagationStopped = true;
  }
  stopImmediatePropagation() {
    this.immediatePropagationStopped = this.propagationStopped = true;
  }
};
Object.defineProperty(BaseEvent.prototype, "interaction", {
  get() {
    return this._interaction._proxy;
  },
  set() {
  }
});

// node_modules/.pnpm/@interactjs+core@1.10.27_@interactjs+utils@1.10.27/node_modules/@interactjs/core/options.js
var defaults = {
  base: {
    preventDefault: "auto",
    deltaSource: "page"
  },
  perAction: {
    enabled: false,
    origin: {
      x: 0,
      y: 0
    }
  },
  actions: {}
};

// node_modules/.pnpm/@interactjs+core@1.10.27_@interactjs+utils@1.10.27/node_modules/@interactjs/core/InteractEvent.js
var InteractEvent = class extends BaseEvent {
  constructor(interaction, event, actionName, phase, element, preEnd, type) {
    super(interaction);
    this.relatedTarget = null;
    this.screenX = void 0;
    this.screenY = void 0;
    this.button = void 0;
    this.buttons = void 0;
    this.ctrlKey = void 0;
    this.shiftKey = void 0;
    this.altKey = void 0;
    this.metaKey = void 0;
    this.page = void 0;
    this.client = void 0;
    this.delta = void 0;
    this.rect = void 0;
    this.x0 = void 0;
    this.y0 = void 0;
    this.t0 = void 0;
    this.dt = void 0;
    this.duration = void 0;
    this.clientX0 = void 0;
    this.clientY0 = void 0;
    this.velocity = void 0;
    this.speed = void 0;
    this.swipe = void 0;
    this.axes = void 0;
    this.preEnd = void 0;
    element = element || interaction.element;
    const target = interaction.interactable;
    const deltaSource = (target && target.options || defaults).deltaSource;
    const origin = getOriginXY(target, element, actionName);
    const starting = phase === "start";
    const ending = phase === "end";
    const prevEvent = starting ? this : interaction.prevEvent;
    const coords = starting ? interaction.coords.start : ending ? {
      page: prevEvent.page,
      client: prevEvent.client,
      timeStamp: interaction.coords.cur.timeStamp
    } : interaction.coords.cur;
    this.page = extend({}, coords.page);
    this.client = extend({}, coords.client);
    this.rect = extend({}, interaction.rect);
    this.timeStamp = coords.timeStamp;
    if (!ending) {
      this.page.x -= origin.x;
      this.page.y -= origin.y;
      this.client.x -= origin.x;
      this.client.y -= origin.y;
    }
    this.ctrlKey = event.ctrlKey;
    this.altKey = event.altKey;
    this.shiftKey = event.shiftKey;
    this.metaKey = event.metaKey;
    this.button = event.button;
    this.buttons = event.buttons;
    this.target = element;
    this.currentTarget = element;
    this.preEnd = preEnd;
    this.type = type || actionName + (phase || "");
    this.interactable = target;
    this.t0 = starting ? interaction.pointers[interaction.pointers.length - 1].downTime : prevEvent.t0;
    this.x0 = interaction.coords.start.page.x - origin.x;
    this.y0 = interaction.coords.start.page.y - origin.y;
    this.clientX0 = interaction.coords.start.client.x - origin.x;
    this.clientY0 = interaction.coords.start.client.y - origin.y;
    if (starting || ending) {
      this.delta = {
        x: 0,
        y: 0
      };
    } else {
      this.delta = {
        x: this[deltaSource].x - prevEvent[deltaSource].x,
        y: this[deltaSource].y - prevEvent[deltaSource].y
      };
    }
    this.dt = interaction.coords.delta.timeStamp;
    this.duration = this.timeStamp - this.t0;
    this.velocity = extend({}, interaction.coords.velocity[deltaSource]);
    this.speed = hypot(this.velocity.x, this.velocity.y);
    this.swipe = ending || phase === "inertiastart" ? this.getSwipe() : null;
  }
  getSwipe() {
    const interaction = this._interaction;
    if (interaction.prevEvent.speed < 600 || this.timeStamp - interaction.prevEvent.timeStamp > 150) {
      return null;
    }
    let angle = 180 * Math.atan2(interaction.prevEvent.velocityY, interaction.prevEvent.velocityX) / Math.PI;
    const overlap = 22.5;
    if (angle < 0) {
      angle += 360;
    }
    const left = 135 - overlap <= angle && angle < 225 + overlap;
    const up = 225 - overlap <= angle && angle < 315 + overlap;
    const right = !left && (315 - overlap <= angle || angle < 45 + overlap);
    const down = !up && 45 - overlap <= angle && angle < 135 + overlap;
    return {
      up,
      down,
      left,
      right,
      angle,
      speed: interaction.prevEvent.speed,
      velocity: {
        x: interaction.prevEvent.velocityX,
        y: interaction.prevEvent.velocityY
      }
    };
  }
  preventDefault() {
  }
  stopImmediatePropagation() {
    this.immediatePropagationStopped = this.propagationStopped = true;
  }
  stopPropagation() {
    this.propagationStopped = true;
  }
};
Object.defineProperties(InteractEvent.prototype, {
  pageX: {
    get() {
      return this.page.x;
    },
    set(value) {
      this.page.x = value;
    }
  },
  pageY: {
    get() {
      return this.page.y;
    },
    set(value) {
      this.page.y = value;
    }
  },
  clientX: {
    get() {
      return this.client.x;
    },
    set(value) {
      this.client.x = value;
    }
  },
  clientY: {
    get() {
      return this.client.y;
    },
    set(value) {
      this.client.y = value;
    }
  },
  dx: {
    get() {
      return this.delta.x;
    },
    set(value) {
      this.delta.x = value;
    }
  },
  dy: {
    get() {
      return this.delta.y;
    },
    set(value) {
      this.delta.y = value;
    }
  },
  velocityX: {
    get() {
      return this.velocity.x;
    },
    set(value) {
      this.velocity.x = value;
    }
  },
  velocityY: {
    get() {
      return this.velocity.y;
    },
    set(value) {
      this.velocity.y = value;
    }
  }
});

// node_modules/.pnpm/@interactjs+core@1.10.27_@interactjs+utils@1.10.27/node_modules/@interactjs/core/PointerInfo.js
var PointerInfo = class {
  constructor(id, pointer, event, downTime, downTarget) {
    this.id = void 0;
    this.pointer = void 0;
    this.event = void 0;
    this.downTime = void 0;
    this.downTarget = void 0;
    this.id = id;
    this.pointer = pointer;
    this.event = event;
    this.downTime = downTime;
    this.downTarget = downTarget;
  }
};

// node_modules/.pnpm/@interactjs+core@1.10.27_@interactjs+utils@1.10.27/node_modules/@interactjs/core/Interaction.js
var _ProxyValues = function(_ProxyValues2) {
  _ProxyValues2["interactable"] = "";
  _ProxyValues2["element"] = "";
  _ProxyValues2["prepared"] = "";
  _ProxyValues2["pointerIsDown"] = "";
  _ProxyValues2["pointerWasMoved"] = "";
  _ProxyValues2["_proxy"] = "";
  return _ProxyValues2;
}({});
var _ProxyMethods = function(_ProxyMethods2) {
  _ProxyMethods2["start"] = "";
  _ProxyMethods2["move"] = "";
  _ProxyMethods2["end"] = "";
  _ProxyMethods2["stop"] = "";
  _ProxyMethods2["interacting"] = "";
  return _ProxyMethods2;
}({});
var idCounter = 0;
var Interaction = class {
  get pointerMoveTolerance() {
    return 1;
  }
  constructor(_ref) {
    this.interactable = null;
    this.element = null;
    this.rect = null;
    this._rects = void 0;
    this.edges = null;
    this._scopeFire = void 0;
    this.prepared = {
      name: null,
      axis: null,
      edges: null
    };
    this.pointerType = void 0;
    this.pointers = [];
    this.downEvent = null;
    this.downPointer = {};
    this._latestPointer = {
      pointer: null,
      event: null,
      eventTarget: null
    };
    this.prevEvent = null;
    this.pointerIsDown = false;
    this.pointerWasMoved = false;
    this._interacting = false;
    this._ending = false;
    this._stopped = true;
    this._proxy = void 0;
    this.simulation = null;
    this.doMove = warnOnce(function(signalArg) {
      this.move(signalArg);
    }, "The interaction.doMove() method has been renamed to interaction.move()");
    this.coords = {
      start: newCoords(),
      prev: newCoords(),
      cur: newCoords(),
      delta: newCoords(),
      velocity: newCoords()
    };
    this._id = idCounter++;
    let {
      pointerType,
      scopeFire
    } = _ref;
    this._scopeFire = scopeFire;
    this.pointerType = pointerType;
    const that = this;
    this._proxy = {};
    for (const key in _ProxyValues) {
      Object.defineProperty(this._proxy, key, {
        get() {
          return that[key];
        }
      });
    }
    for (const key in _ProxyMethods) {
      Object.defineProperty(this._proxy, key, {
        value: function() {
          return that[key](...arguments);
        }
      });
    }
    this._scopeFire("interactions:new", {
      interaction: this
    });
  }
  pointerDown(pointer, event, eventTarget) {
    const pointerIndex = this.updatePointer(pointer, event, eventTarget, true);
    const pointerInfo = this.pointers[pointerIndex];
    this._scopeFire("interactions:down", {
      pointer,
      event,
      eventTarget,
      pointerIndex,
      pointerInfo,
      type: "down",
      interaction: this
    });
  }
  start(action, interactable, element) {
    if (this.interacting() || !this.pointerIsDown || this.pointers.length < (action.name === "gesture" ? 2 : 1) || !interactable.options[action.name].enabled) {
      return false;
    }
    copyAction(this.prepared, action);
    this.interactable = interactable;
    this.element = element;
    this.rect = interactable.getRect(element);
    this.edges = this.prepared.edges ? extend({}, this.prepared.edges) : {
      left: true,
      right: true,
      top: true,
      bottom: true
    };
    this._stopped = false;
    this._interacting = this._doPhase({
      interaction: this,
      event: this.downEvent,
      phase: "start"
    }) && !this._stopped;
    return this._interacting;
  }
  pointerMove(pointer, event, eventTarget) {
    if (!this.simulation && !(this.modification && this.modification.endResult)) {
      this.updatePointer(pointer, event, eventTarget, false);
    }
    const duplicateMove = this.coords.cur.page.x === this.coords.prev.page.x && this.coords.cur.page.y === this.coords.prev.page.y && this.coords.cur.client.x === this.coords.prev.client.x && this.coords.cur.client.y === this.coords.prev.client.y;
    let dx;
    let dy;
    if (this.pointerIsDown && !this.pointerWasMoved) {
      dx = this.coords.cur.client.x - this.coords.start.client.x;
      dy = this.coords.cur.client.y - this.coords.start.client.y;
      this.pointerWasMoved = hypot(dx, dy) > this.pointerMoveTolerance;
    }
    const pointerIndex = this.getPointerIndex(pointer);
    const signalArg = {
      pointer,
      pointerIndex,
      pointerInfo: this.pointers[pointerIndex],
      event,
      type: "move",
      eventTarget,
      dx,
      dy,
      duplicate: duplicateMove,
      interaction: this
    };
    if (!duplicateMove) {
      setCoordVelocity(this.coords.velocity, this.coords.delta);
    }
    this._scopeFire("interactions:move", signalArg);
    if (!duplicateMove && !this.simulation) {
      if (this.interacting()) {
        signalArg.type = null;
        this.move(signalArg);
      }
      if (this.pointerWasMoved) {
        copyCoords(this.coords.prev, this.coords.cur);
      }
    }
  }
  move(signalArg) {
    if (!signalArg || !signalArg.event) {
      setZeroCoords(this.coords.delta);
    }
    signalArg = extend({
      pointer: this._latestPointer.pointer,
      event: this._latestPointer.event,
      eventTarget: this._latestPointer.eventTarget,
      interaction: this
    }, signalArg || {});
    signalArg.phase = "move";
    this._doPhase(signalArg);
  }
  pointerUp(pointer, event, eventTarget, curEventTarget) {
    let pointerIndex = this.getPointerIndex(pointer);
    if (pointerIndex === -1) {
      pointerIndex = this.updatePointer(pointer, event, eventTarget, false);
    }
    const type = /cancel$/i.test(event.type) ? "cancel" : "up";
    this._scopeFire(`interactions:${type}`, {
      pointer,
      pointerIndex,
      pointerInfo: this.pointers[pointerIndex],
      event,
      eventTarget,
      type,
      curEventTarget,
      interaction: this
    });
    if (!this.simulation) {
      this.end(event);
    }
    this.removePointer(pointer, event);
  }
  documentBlur(event) {
    this.end(event);
    this._scopeFire("interactions:blur", {
      event,
      type: "blur",
      interaction: this
    });
  }
  end(event) {
    this._ending = true;
    event = event || this._latestPointer.event;
    let endPhaseResult;
    if (this.interacting()) {
      endPhaseResult = this._doPhase({
        event,
        interaction: this,
        phase: "end"
      });
    }
    this._ending = false;
    if (endPhaseResult === true) {
      this.stop();
    }
  }
  currentAction() {
    return this._interacting ? this.prepared.name : null;
  }
  interacting() {
    return this._interacting;
  }
  stop() {
    this._scopeFire("interactions:stop", {
      interaction: this
    });
    this.interactable = this.element = null;
    this._interacting = false;
    this._stopped = true;
    this.prepared.name = this.prevEvent = null;
  }
  getPointerIndex(pointer) {
    const pointerId = getPointerId(pointer);
    return this.pointerType === "mouse" || this.pointerType === "pen" ? this.pointers.length - 1 : findIndex(this.pointers, (curPointer) => curPointer.id === pointerId);
  }
  getPointerInfo(pointer) {
    return this.pointers[this.getPointerIndex(pointer)];
  }
  updatePointer(pointer, event, eventTarget, down) {
    const id = getPointerId(pointer);
    let pointerIndex = this.getPointerIndex(pointer);
    let pointerInfo = this.pointers[pointerIndex];
    down = down === false ? false : down || /(down|start)$/i.test(event.type);
    if (!pointerInfo) {
      pointerInfo = new PointerInfo(id, pointer, event, null, null);
      pointerIndex = this.pointers.length;
      this.pointers.push(pointerInfo);
    } else {
      pointerInfo.pointer = pointer;
    }
    setCoords(this.coords.cur, this.pointers.map((p) => p.pointer), this._now());
    setCoordDeltas(this.coords.delta, this.coords.prev, this.coords.cur);
    if (down) {
      this.pointerIsDown = true;
      pointerInfo.downTime = this.coords.cur.timeStamp;
      pointerInfo.downTarget = eventTarget;
      pointerExtend(this.downPointer, pointer);
      if (!this.interacting()) {
        copyCoords(this.coords.start, this.coords.cur);
        copyCoords(this.coords.prev, this.coords.cur);
        this.downEvent = event;
        this.pointerWasMoved = false;
      }
    }
    this._updateLatestPointer(pointer, event, eventTarget);
    this._scopeFire("interactions:update-pointer", {
      pointer,
      event,
      eventTarget,
      down,
      pointerInfo,
      pointerIndex,
      interaction: this
    });
    return pointerIndex;
  }
  removePointer(pointer, event) {
    const pointerIndex = this.getPointerIndex(pointer);
    if (pointerIndex === -1)
      return;
    const pointerInfo = this.pointers[pointerIndex];
    this._scopeFire("interactions:remove-pointer", {
      pointer,
      event,
      eventTarget: null,
      pointerIndex,
      pointerInfo,
      interaction: this
    });
    this.pointers.splice(pointerIndex, 1);
    this.pointerIsDown = false;
  }
  _updateLatestPointer(pointer, event, eventTarget) {
    this._latestPointer.pointer = pointer;
    this._latestPointer.event = event;
    this._latestPointer.eventTarget = eventTarget;
  }
  destroy() {
    this._latestPointer.pointer = null;
    this._latestPointer.event = null;
    this._latestPointer.eventTarget = null;
  }
  _createPreparedEvent(event, phase, preEnd, type) {
    return new InteractEvent(this, event, this.prepared.name, phase, this.element, preEnd, type);
  }
  _fireEvent(iEvent) {
    var _this$interactable;
    (_this$interactable = this.interactable) == null ? void 0 : _this$interactable.fire(iEvent);
    if (!this.prevEvent || iEvent.timeStamp >= this.prevEvent.timeStamp) {
      this.prevEvent = iEvent;
    }
  }
  _doPhase(signalArg) {
    const {
      event,
      phase,
      preEnd,
      type
    } = signalArg;
    const {
      rect
    } = this;
    if (rect && phase === "move") {
      addEdges(this.edges, rect, this.coords.delta[this.interactable.options.deltaSource]);
      rect.width = rect.right - rect.left;
      rect.height = rect.bottom - rect.top;
    }
    const beforeResult = this._scopeFire(`interactions:before-action-${phase}`, signalArg);
    if (beforeResult === false) {
      return false;
    }
    const iEvent = signalArg.iEvent = this._createPreparedEvent(event, phase, preEnd, type);
    this._scopeFire(`interactions:action-${phase}`, signalArg);
    if (phase === "start") {
      this.prevEvent = iEvent;
    }
    this._fireEvent(iEvent);
    this._scopeFire(`interactions:after-action-${phase}`, signalArg);
    return true;
  }
  _now() {
    return Date.now();
  }
};

// node_modules/.pnpm/@interactjs+core@1.10.27_@interactjs+utils@1.10.27/node_modules/@interactjs/core/interactionFinder.js
var finder = {
  methodOrder: ["simulationResume", "mouseOrPen", "hasPointer", "idle"],
  search(details) {
    for (const method of finder.methodOrder) {
      const interaction = finder[method](details);
      if (interaction) {
        return interaction;
      }
    }
    return null;
  },
  simulationResume(_ref) {
    let {
      pointerType,
      eventType,
      eventTarget,
      scope: scope2
    } = _ref;
    if (!/down|start/i.test(eventType)) {
      return null;
    }
    for (const interaction of scope2.interactions.list) {
      let element = eventTarget;
      if (interaction.simulation && interaction.simulation.allowResume && interaction.pointerType === pointerType) {
        while (element) {
          if (element === interaction.element) {
            return interaction;
          }
          element = parentNode(element);
        }
      }
    }
    return null;
  },
  mouseOrPen(_ref2) {
    let {
      pointerId,
      pointerType,
      eventType,
      scope: scope2
    } = _ref2;
    if (pointerType !== "mouse" && pointerType !== "pen") {
      return null;
    }
    let firstNonActive;
    for (const interaction of scope2.interactions.list) {
      if (interaction.pointerType === pointerType) {
        if (interaction.simulation && !hasPointerId(interaction, pointerId)) {
          continue;
        }
        if (interaction.interacting()) {
          return interaction;
        } else if (!firstNonActive) {
          firstNonActive = interaction;
        }
      }
    }
    if (firstNonActive) {
      return firstNonActive;
    }
    for (const interaction of scope2.interactions.list) {
      if (interaction.pointerType === pointerType && !(/down/i.test(eventType) && interaction.simulation)) {
        return interaction;
      }
    }
    return null;
  },
  hasPointer(_ref3) {
    let {
      pointerId,
      scope: scope2
    } = _ref3;
    for (const interaction of scope2.interactions.list) {
      if (hasPointerId(interaction, pointerId)) {
        return interaction;
      }
    }
    return null;
  },
  idle(_ref4) {
    let {
      pointerType,
      scope: scope2
    } = _ref4;
    for (const interaction of scope2.interactions.list) {
      if (interaction.pointers.length === 1) {
        const target = interaction.interactable;
        if (target && !(target.options.gesture && target.options.gesture.enabled)) {
          continue;
        }
      } else if (interaction.pointers.length >= 2) {
        continue;
      }
      if (!interaction.interacting() && pointerType === interaction.pointerType) {
        return interaction;
      }
    }
    return null;
  }
};
function hasPointerId(interaction, pointerId) {
  return interaction.pointers.some((_ref5) => {
    let {
      id
    } = _ref5;
    return id === pointerId;
  });
}

// node_modules/.pnpm/@interactjs+core@1.10.27_@interactjs+utils@1.10.27/node_modules/@interactjs/core/interactions.js
var methodNames = ["pointerDown", "pointerMove", "pointerUp", "updatePointer", "removePointer", "windowBlur"];
function install3(scope2) {
  const listeners = {};
  for (const method of methodNames) {
    listeners[method] = doOnInteractions(method, scope2);
  }
  const pEventTypes = browser.pEventTypes;
  let docEvents;
  if (domObjects.PointerEvent) {
    docEvents = [{
      type: pEventTypes.down,
      listener: releasePointersOnRemovedEls
    }, {
      type: pEventTypes.down,
      listener: listeners.pointerDown
    }, {
      type: pEventTypes.move,
      listener: listeners.pointerMove
    }, {
      type: pEventTypes.up,
      listener: listeners.pointerUp
    }, {
      type: pEventTypes.cancel,
      listener: listeners.pointerUp
    }];
  } else {
    docEvents = [{
      type: "mousedown",
      listener: listeners.pointerDown
    }, {
      type: "mousemove",
      listener: listeners.pointerMove
    }, {
      type: "mouseup",
      listener: listeners.pointerUp
    }, {
      type: "touchstart",
      listener: releasePointersOnRemovedEls
    }, {
      type: "touchstart",
      listener: listeners.pointerDown
    }, {
      type: "touchmove",
      listener: listeners.pointerMove
    }, {
      type: "touchend",
      listener: listeners.pointerUp
    }, {
      type: "touchcancel",
      listener: listeners.pointerUp
    }];
  }
  docEvents.push({
    type: "blur",
    listener(event) {
      for (const interaction of scope2.interactions.list) {
        interaction.documentBlur(event);
      }
    }
  });
  scope2.prevTouchTime = 0;
  scope2.Interaction = class extends Interaction {
    get pointerMoveTolerance() {
      return scope2.interactions.pointerMoveTolerance;
    }
    set pointerMoveTolerance(value) {
      scope2.interactions.pointerMoveTolerance = value;
    }
    _now() {
      return scope2.now();
    }
  };
  scope2.interactions = {
    list: [],
    new(options) {
      options.scopeFire = (name, arg) => scope2.fire(name, arg);
      const interaction = new scope2.Interaction(options);
      scope2.interactions.list.push(interaction);
      return interaction;
    },
    listeners,
    docEvents,
    pointerMoveTolerance: 1
  };
  function releasePointersOnRemovedEls() {
    for (const interaction of scope2.interactions.list) {
      if (!interaction.pointerIsDown || interaction.pointerType !== "touch" || interaction._interacting) {
        continue;
      }
      for (const pointer of interaction.pointers) {
        if (!scope2.documents.some((_ref) => {
          let {
            doc
          } = _ref;
          return nodeContains(doc, pointer.downTarget);
        })) {
          interaction.removePointer(pointer.pointer, pointer.event);
        }
      }
    }
  }
  scope2.usePlugin(interactablePreventDefault);
}
function doOnInteractions(method, scope2) {
  return function(event) {
    const interactions2 = scope2.interactions.list;
    const pointerType = getPointerType(event);
    const [eventTarget, curEventTarget] = getEventTargets(event);
    const matches = [];
    if (/^touch/.test(event.type)) {
      scope2.prevTouchTime = scope2.now();
      for (const changedTouch of event.changedTouches) {
        const pointer = changedTouch;
        const pointerId = getPointerId(pointer);
        const searchDetails = {
          pointer,
          pointerId,
          pointerType,
          eventType: event.type,
          eventTarget,
          curEventTarget,
          scope: scope2
        };
        const interaction = getInteraction(searchDetails);
        matches.push([searchDetails.pointer, searchDetails.eventTarget, searchDetails.curEventTarget, interaction]);
      }
    } else {
      let invalidPointer = false;
      if (!browser.supportsPointerEvent && /mouse/.test(event.type)) {
        for (let i = 0; i < interactions2.length && !invalidPointer; i++) {
          invalidPointer = interactions2[i].pointerType !== "mouse" && interactions2[i].pointerIsDown;
        }
        invalidPointer = invalidPointer || scope2.now() - scope2.prevTouchTime < 500 || event.timeStamp === 0;
      }
      if (!invalidPointer) {
        const searchDetails = {
          pointer: event,
          pointerId: getPointerId(event),
          pointerType,
          eventType: event.type,
          curEventTarget,
          eventTarget,
          scope: scope2
        };
        const interaction = getInteraction(searchDetails);
        matches.push([searchDetails.pointer, searchDetails.eventTarget, searchDetails.curEventTarget, interaction]);
      }
    }
    for (const [pointer, eventTarget2, curEventTarget2, interaction] of matches) {
      interaction[method](pointer, event, eventTarget2, curEventTarget2);
    }
  };
}
function getInteraction(searchDetails) {
  const {
    pointerType,
    scope: scope2
  } = searchDetails;
  const foundInteraction = finder.search(searchDetails);
  const signalArg = {
    interaction: foundInteraction,
    searchDetails
  };
  scope2.fire("interactions:find", signalArg);
  return signalArg.interaction || scope2.interactions.new({
    pointerType
  });
}
function onDocSignal(_ref2, eventMethodName) {
  let {
    doc,
    scope: scope2,
    options
  } = _ref2;
  const {
    interactions: {
      docEvents
    },
    events: events2
  } = scope2;
  const eventMethod = events2[eventMethodName];
  if (scope2.browser.isIOS && !options.events) {
    options.events = {
      passive: false
    };
  }
  for (const eventType in events2.delegatedEvents) {
    eventMethod(doc, eventType, events2.delegateListener);
    eventMethod(doc, eventType, events2.delegateUseCapture, true);
  }
  const eventOptions = options && options.events;
  for (const {
    type,
    listener
  } of docEvents) {
    eventMethod(doc, type, listener, eventOptions);
  }
}
var interactions = {
  id: "core/interactions",
  install: install3,
  listeners: {
    "scope:add-document": (arg) => onDocSignal(arg, "add"),
    "scope:remove-document": (arg) => onDocSignal(arg, "remove"),
    "interactable:unset": (_ref3, scope2) => {
      let {
        interactable
      } = _ref3;
      for (let i = scope2.interactions.list.length - 1; i >= 0; i--) {
        const interaction = scope2.interactions.list[i];
        if (interaction.interactable !== interactable) {
          continue;
        }
        interaction.stop();
        scope2.fire("interactions:destroy", {
          interaction
        });
        interaction.destroy();
        if (scope2.interactions.list.length > 2) {
          scope2.interactions.list.splice(i, 1);
        }
      }
    }
  },
  onDocSignal,
  doOnInteractions,
  methodNames
};

// node_modules/.pnpm/@interactjs+core@1.10.27_@interactjs+utils@1.10.27/node_modules/@interactjs/core/InteractableSet.js
var InteractableSet = class {
  constructor(scope2) {
    this.list = [];
    this.selectorMap = {};
    this.scope = void 0;
    this.scope = scope2;
    scope2.addListeners({
      "interactable:unset": (_ref) => {
        let {
          interactable
        } = _ref;
        const {
          target
        } = interactable;
        const interactablesOnTarget = is.string(target) ? this.selectorMap[target] : target[this.scope.id];
        const targetIndex = findIndex(interactablesOnTarget, (i) => i === interactable);
        interactablesOnTarget.splice(targetIndex, 1);
      }
    });
  }
  new(target, options) {
    options = extend(options || {}, {
      actions: this.scope.actions
    });
    const interactable = new this.scope.Interactable(target, options, this.scope.document, this.scope.events);
    this.scope.addDocument(interactable._doc);
    this.list.push(interactable);
    if (is.string(target)) {
      if (!this.selectorMap[target]) {
        this.selectorMap[target] = [];
      }
      this.selectorMap[target].push(interactable);
    } else {
      if (!interactable.target[this.scope.id]) {
        Object.defineProperty(target, this.scope.id, {
          value: [],
          configurable: true
        });
      }
      target[this.scope.id].push(interactable);
    }
    this.scope.fire("interactable:new", {
      target,
      options,
      interactable,
      win: this.scope._win
    });
    return interactable;
  }
  getExisting(target, options) {
    const context = options && options.context || this.scope.document;
    const isSelector = is.string(target);
    const interactablesOnTarget = isSelector ? this.selectorMap[target] : target[this.scope.id];
    if (!interactablesOnTarget)
      return void 0;
    return find(interactablesOnTarget, (interactable) => interactable._context === context && (isSelector || interactable.inContext(target)));
  }
  forEachMatch(node, callback) {
    for (const interactable of this.list) {
      let ret;
      if ((is.string(interactable.target) ? is.element(node) && matchesSelector(node, interactable.target) : node === interactable.target) && interactable.inContext(node)) {
        ret = callback(interactable);
      }
      if (ret !== void 0) {
        return ret;
      }
    }
  }
};

// node_modules/.pnpm/@interactjs+core@1.10.27_@interactjs+utils@1.10.27/node_modules/@interactjs/core/InteractStatic.js
function createInteractStatic(scope2) {
  const interact2 = (target, options) => {
    let interactable = scope2.interactables.getExisting(target, options);
    if (!interactable) {
      interactable = scope2.interactables.new(target, options);
      interactable.events.global = interact2.globalEvents;
    }
    return interactable;
  };
  interact2.getPointerAverage = pointerAverage;
  interact2.getTouchBBox = touchBBox;
  interact2.getTouchDistance = touchDistance;
  interact2.getTouchAngle = touchAngle;
  interact2.getElementRect = getElementRect;
  interact2.getElementClientRect = getElementClientRect;
  interact2.matchesSelector = matchesSelector;
  interact2.closest = closest;
  interact2.globalEvents = {};
  interact2.version = "1.10.27";
  interact2.scope = scope2;
  interact2.use = function(plugin, options) {
    this.scope.usePlugin(plugin, options);
    return this;
  };
  interact2.isSet = function(target, options) {
    return !!this.scope.interactables.get(target, options && options.context);
  };
  interact2.on = warnOnce(function on(type, listener, options) {
    if (is.string(type) && type.search(" ") !== -1) {
      type = type.trim().split(/ +/);
    }
    if (is.array(type)) {
      for (const eventType of type) {
        this.on(eventType, listener, options);
      }
      return this;
    }
    if (is.object(type)) {
      for (const prop in type) {
        this.on(prop, type[prop], listener);
      }
      return this;
    }
    if (isNonNativeEvent(type, this.scope.actions)) {
      if (!this.globalEvents[type]) {
        this.globalEvents[type] = [listener];
      } else {
        this.globalEvents[type].push(listener);
      }
    } else {
      this.scope.events.add(this.scope.document, type, listener, {
        options
      });
    }
    return this;
  }, "The interact.on() method is being deprecated");
  interact2.off = warnOnce(function off(type, listener, options) {
    if (is.string(type) && type.search(" ") !== -1) {
      type = type.trim().split(/ +/);
    }
    if (is.array(type)) {
      for (const eventType of type) {
        this.off(eventType, listener, options);
      }
      return this;
    }
    if (is.object(type)) {
      for (const prop in type) {
        this.off(prop, type[prop], listener);
      }
      return this;
    }
    if (isNonNativeEvent(type, this.scope.actions)) {
      let index;
      if (type in this.globalEvents && (index = this.globalEvents[type].indexOf(listener)) !== -1) {
        this.globalEvents[type].splice(index, 1);
      }
    } else {
      this.scope.events.remove(this.scope.document, type, listener, options);
    }
    return this;
  }, "The interact.off() method is being deprecated");
  interact2.debug = function() {
    return this.scope;
  };
  interact2.supportsTouch = function() {
    return browser.supportsTouch;
  };
  interact2.supportsPointerEvent = function() {
    return browser.supportsPointerEvent;
  };
  interact2.stop = function() {
    for (const interaction of this.scope.interactions.list) {
      interaction.stop();
    }
    return this;
  };
  interact2.pointerMoveTolerance = function(newValue) {
    if (is.number(newValue)) {
      this.scope.interactions.pointerMoveTolerance = newValue;
      return this;
    }
    return this.scope.interactions.pointerMoveTolerance;
  };
  interact2.addDocument = function(doc, options) {
    this.scope.addDocument(doc, options);
  };
  interact2.removeDocument = function(doc) {
    this.scope.removeDocument(doc);
  };
  return interact2;
}

// node_modules/.pnpm/@interactjs+core@1.10.27_@interactjs+utils@1.10.27/node_modules/@interactjs/core/scope.js
var Scope = class {
  constructor() {
    this.id = `__interact_scope_${Math.floor(Math.random() * 100)}`;
    this.isInitialized = false;
    this.listenerMaps = [];
    this.browser = browser;
    this.defaults = clone(defaults);
    this.Eventable = Eventable;
    this.actions = {
      map: {},
      phases: {
        start: true,
        move: true,
        end: true
      },
      methodDict: {},
      phaselessTypes: {}
    };
    this.interactStatic = createInteractStatic(this);
    this.InteractEvent = InteractEvent;
    this.Interactable = void 0;
    this.interactables = new InteractableSet(this);
    this._win = void 0;
    this.document = void 0;
    this.window = void 0;
    this.documents = [];
    this._plugins = {
      list: [],
      map: {}
    };
    this.onWindowUnload = (event) => this.removeDocument(event.target);
    const scope2 = this;
    this.Interactable = class extends Interactable {
      get _defaults() {
        return scope2.defaults;
      }
      set(options) {
        super.set(options);
        scope2.fire("interactable:set", {
          options,
          interactable: this
        });
        return this;
      }
      unset() {
        super.unset();
        const index = scope2.interactables.list.indexOf(this);
        if (index < 0)
          return;
        scope2.interactables.list.splice(index, 1);
        scope2.fire("interactable:unset", {
          interactable: this
        });
      }
    };
  }
  addListeners(map, id) {
    this.listenerMaps.push({
      id,
      map
    });
  }
  fire(name, arg) {
    for (const {
      map: {
        [name]: listener
      }
    } of this.listenerMaps) {
      if (!!listener && listener(arg, this, name) === false) {
        return false;
      }
    }
  }
  init(window2) {
    return this.isInitialized ? this : initScope(this, window2);
  }
  pluginIsInstalled(plugin) {
    const {
      id
    } = plugin;
    return id ? !!this._plugins.map[id] : this._plugins.list.indexOf(plugin) !== -1;
  }
  usePlugin(plugin, options) {
    if (!this.isInitialized) {
      return this;
    }
    if (this.pluginIsInstalled(plugin)) {
      return this;
    }
    if (plugin.id) {
      this._plugins.map[plugin.id] = plugin;
    }
    this._plugins.list.push(plugin);
    if (plugin.install) {
      plugin.install(this, options);
    }
    if (plugin.listeners && plugin.before) {
      let index = 0;
      const len = this.listenerMaps.length;
      const before = plugin.before.reduce((acc, id) => {
        acc[id] = true;
        acc[pluginIdRoot(id)] = true;
        return acc;
      }, {});
      for (; index < len; index++) {
        const otherId = this.listenerMaps[index].id;
        if (otherId && (before[otherId] || before[pluginIdRoot(otherId)])) {
          break;
        }
      }
      this.listenerMaps.splice(index, 0, {
        id: plugin.id,
        map: plugin.listeners
      });
    } else if (plugin.listeners) {
      this.listenerMaps.push({
        id: plugin.id,
        map: plugin.listeners
      });
    }
    return this;
  }
  addDocument(doc, options) {
    if (this.getDocIndex(doc) !== -1) {
      return false;
    }
    const window2 = getWindow(doc);
    options = options ? extend({}, options) : {};
    this.documents.push({
      doc,
      options
    });
    this.events.documents.push(doc);
    if (doc !== this.document) {
      this.events.add(window2, "unload", this.onWindowUnload);
    }
    this.fire("scope:add-document", {
      doc,
      window: window2,
      scope: this,
      options
    });
  }
  removeDocument(doc) {
    const index = this.getDocIndex(doc);
    const window2 = getWindow(doc);
    const options = this.documents[index].options;
    this.events.remove(window2, "unload", this.onWindowUnload);
    this.documents.splice(index, 1);
    this.events.documents.splice(index, 1);
    this.fire("scope:remove-document", {
      doc,
      window: window2,
      scope: this,
      options
    });
  }
  getDocIndex(doc) {
    for (let i = 0; i < this.documents.length; i++) {
      if (this.documents[i].doc === doc) {
        return i;
      }
    }
    return -1;
  }
  getDocOptions(doc) {
    const docIndex = this.getDocIndex(doc);
    return docIndex === -1 ? null : this.documents[docIndex].options;
  }
  now() {
    return (this.window.Date || Date).now();
  }
};
function initScope(scope2, window2) {
  scope2.isInitialized = true;
  if (is.window(window2)) {
    init(window2);
  }
  domObjects.init(window2);
  browser.init(window2);
  raf.init(window2);
  scope2.window = window2;
  scope2.document = window2.document;
  scope2.usePlugin(interactions);
  scope2.usePlugin(events);
  return scope2;
}
function pluginIdRoot(id) {
  return id && id.replace(/\/.*$/, "");
}

// node_modules/.pnpm/@interactjs+interact@1.10.27/node_modules/@interactjs/interact/index.js
var scope = new Scope();
var interact = scope.interactStatic;
var _global = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : window;
scope.init(_global);

export {
  raf,
  hypot,
  warnOnce,
  copyAction,
  getStringOptionResult,
  resolveRectLike,
  rectToXY,
  xywhToTlbr,
  tlbrToXywh,
  addEdges,
  getOriginXY,
  interact
};
//# sourceMappingURL=chunk-5BACM2RS.js.map
