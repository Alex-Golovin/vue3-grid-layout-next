{
  "version": 3,
  "sources": ["../../../src/helpers/utils.ts"],
  "sourcesContent": ["export interface LayoutItemRequired {\n  w: number\n  h: number\n  x: number\n  y: number\n  i: string\n}\nexport type LayoutItem = LayoutItemRequired & {\n  minW?: number\n  minH?: number\n  maxW?: number\n  maxH?: number\n  moved?: boolean\n  static?: boolean\n  isDraggable?: boolean\n  isResizable?: boolean\n}\n\nexport type Layout = Array<LayoutItem>\n// export type Position = {left: number, top: number, width: number, height: number};\n/*\nexport type DragCallbackData = {\n  node: HTMLElement,\n  x: number, y: number,\n  deltaX: number, deltaY: number,\n  lastX: number, lastY: number\n};\n*/\n// export type DragEvent = {e: Event} & DragCallbackData;\nexport type Size = {width: number; height: number}\n// export type ResizeEvent = {e: Event, node: HTMLElement, size: Size};\n\n// const isProduction = process.env.NODE_ENV === 'production';\n/**\n * Return the bottom coordinate of the layout.\n *\n * @param  {Array} layout Layout array.\n * @return {Number}       Bottom coordinate.\n */\nexport function bottom(layout: Layout): number {\n  let max = 0,\n    bottomY\n  for (let i = 0, len = layout.length; i < len; i++) {\n    bottomY = layout[i].y + layout[i].h\n    if (bottomY > max) max = bottomY\n  }\n  return max\n}\n\nexport function cloneLayout(layout: Layout): Layout {\n  const newLayout = Array(layout.length)\n  for (let i = 0, len = layout.length; i < len; i++) {\n    newLayout[i] = cloneLayoutItem(layout[i])\n  }\n  return newLayout\n}\n\n// Fast path to cloning, since this is monomorphic\nexport function cloneLayoutItem(layoutItem: LayoutItem): LayoutItem {\n  /*return {\n    w: layoutItem.w, h: layoutItem.h, x: layoutItem.x, y: layoutItem.y, i: layoutItem.i,\n    minW: layoutItem.minW, maxW: layoutItem.maxW, minH: layoutItem.minH, maxH: layoutItem.maxH,\n    moved: Boolean(layoutItem.moved), static: Boolean(layoutItem.static),\n    // These can be null\n    isDraggable: layoutItem.isDraggable, isResizable: layoutItem.isResizable\n  };*/\n  return JSON.parse(JSON.stringify(layoutItem))\n}\n\n/**\n * Given two layoutitems, check if they collide.\n *\n * @return {Boolean}   True if colliding.\n */\nexport function collides(l1: LayoutItem, l2: LayoutItem): boolean {\n  if (l1 === l2) return false // same element\n  if (l1.x + l1.w <= l2.x) return false // l1 is left of l2\n  if (l1.x >= l2.x + l2.w) return false // l1 is right of l2\n  if (l1.y + l1.h <= l2.y) return false // l1 is above l2\n  if (l1.y >= l2.y + l2.h) return false // l1 is below l2\n  return true // boxes overlap\n}\n\n/**\n * Given a layout, compact it. This involves going down each y coordinate and removing gaps\n * between items.\n *\n * @param  {Array} layout Layout.\n * @param  {Boolean} verticalCompact Whether or not to compact the layout\n *   vertically.\n * @param {Object} minPositions\n * @return {Array}       Compacted Layout.\n */\nexport function compact(layout: Layout, verticalCompact: boolean, minPositions?: any): Layout {\n  // Statics go in the compareWith array right away so items flow around them.\n  const compareWith = getStatics(layout)\n  // We go through the items by row and column.\n  const sorted = sortLayoutItemsByRowCol(layout)\n  // Holding for new items.\n  const out = Array(layout.length)\n\n  for (let i = 0, len = sorted.length; i < len; i++) {\n    let l = sorted[i]\n\n    // Don't move static elements\n    if (!l.static) {\n      l = compactItem(compareWith, l, verticalCompact, minPositions)\n\n      // Add to comparison array. We only collide with items before this one.\n      // Statics are already in this array.\n      compareWith.push(l)\n    }\n\n    // Add to output array to make sure they still come out in the right order.\n    out[layout.indexOf(l)] = l\n\n    // Clear moved flag, if it exists.\n    l.moved = false\n  }\n\n  return out\n}\n\n/**\n * Compact an item in the layout.\n */\nexport function compactItem(\n  compareWith: Layout,\n  l: LayoutItem,\n  verticalCompact: boolean,\n  minPositions?: any\n): LayoutItem {\n  if (verticalCompact) {\n    // Move the element up as far as it can go without colliding.\n    while (l.y > 0 && !getFirstCollision(compareWith, l)) {\n      l.y--\n    }\n  } else if (minPositions) {\n    const minY = minPositions[l.i].y\n    while (l.y > minY && !getFirstCollision(compareWith, l)) {\n      l.y--\n    }\n  }\n\n  // Move it down, and keep moving it down if it's colliding.\n  let collides\n  while ((collides = getFirstCollision(compareWith, l))) {\n    l.y = collides.y + collides.h\n  }\n  return l\n}\n\n/**\n * Given a layout, make sure all elements fit within its bounds.\n *\n * @param  {Array} layout Layout array.\n * @param  {Number} bounds Number of columns.\n */\nexport function correctBounds(layout: Layout, bounds: {cols: number}): Layout {\n  const collidesWith = getStatics(layout)\n  for (let i = 0, len = layout.length; i < len; i++) {\n    const l = layout[i]\n    // Overflows right\n    if (l.x + l.w > bounds.cols) l.x = bounds.cols - l.w\n    // Overflows left\n    if (l.x < 0) {\n      l.x = 0\n      l.w = bounds.cols\n    }\n    if (!l.static) collidesWith.push(l)\n    else {\n      // If this is static and collides with other statics, we must move it down.\n      // We have to do something nicer than just letting them overlap.\n      while (getFirstCollision(collidesWith, l)) {\n        l.y++\n      }\n    }\n  }\n  return layout\n}\n\n/**\n * Get a layout item by ID. Used so we can override later on if necessary.\n *\n * @param  {Array}  layout Layout array.\n * @param  {String} id     ID\n * @return {LayoutItem}    Item at ID.\n */\nexport function getLayoutItem(\n  layout: Layout,\n  id: string | number | undefined\n): LayoutItem | undefined {\n  for (let i = 0, len = layout.length; i < len; i++) {\n    if (layout[i].i === id) return layout[i]\n  }\n}\n\n/**\n * Returns the first item this layout collides with.\n * It doesn't appear to matter which order we approach this from, although\n * perhaps that is the wrong thing to do.\n *\n * @param  {Object} layoutItem Layout item.\n * @return {Object|undefined}  A colliding layout item, or undefined.\n */\nexport function getFirstCollision(layout: Layout, layoutItem: LayoutItem): LayoutItem | undefined {\n  for (let i = 0, len = layout.length; i < len; i++) {\n    if (collides(layout[i], layoutItem)) return layout[i]\n  }\n}\n\nexport function getAllCollisions(layout: Layout, layoutItem: LayoutItem): Array<LayoutItem> {\n  return layout.filter(l => collides(l, layoutItem))\n}\n\n/**\n * Get all static elements.\n * @param  {Array} layout Array of layout objects.\n * @return {Array}        Array of static layout items..\n */\nexport function getStatics(layout: Layout): Array<LayoutItem> {\n  //return [];\n  return layout.filter(l => l.static)\n}\n\n/**\n * Move an element. Responsible for doing cascading movements of other elements.\n *\n * @param  {Array}      layout Full layout to modify.\n * @param  {LayoutItem} l      element to move.\n * @param  {Number}     [x]    X position in grid units.\n * @param  {Number}     [y]    Y position in grid units.\n * @param  {Boolean}    [isUserAction] If true, designates that the item we're moving is\n *                                     being dragged/resized by th euser.\n */\nexport function moveElement(\n  layout: Layout,\n  l: LayoutItem,\n  x: number | undefined,\n  y: number | undefined,\n  isUserAction?: boolean,\n  preventCollision?: boolean\n): Layout {\n  if (l.static) return layout\n\n  // Short-circuit if nothing to do.\n  //if (l.y === y && l.x === x) return layout;\n\n  const oldX = l.x\n  const oldY = l.y\n\n  const movingUp = y && l.y > y\n  // This is quite a bit faster than extending the object\n  if (typeof x === \"number\") l.x = x\n  if (typeof y === \"number\") l.y = y\n  l.moved = true\n\n  // If this collides with anything, move it.\n  // When doing this comparison, we have to sort the items we compare with\n  // to ensure, in the case of multiple collisions, that we're getting the\n  // nearest collision.\n  let sorted = sortLayoutItemsByRowCol(layout)\n  if (movingUp) sorted = sorted.reverse()\n  const collisions = getAllCollisions(sorted, l)\n\n  if (preventCollision && collisions.length) {\n    l.x = oldX\n    l.y = oldY\n    l.moved = false\n    return layout\n  }\n\n  // Move each item that collides away from this element.\n  for (let i = 0, len = collisions.length; i < len; i++) {\n    const collision = collisions[i]\n    // console.log('resolving collision between', l.i, 'at', l.y, 'and', collision.i, 'at', collision.y);\n\n    // Short circuit so we can't infinite loop\n    if (collision.moved) continue\n\n    // This makes it feel a bit more precise by waiting to swap for just a bit when moving up.\n    if (l.y > collision.y && l.y - collision.y > collision.h / 4) continue\n\n    // Don't move static items - we have to move *this* element away\n    if (collision.static) {\n      layout = moveElementAwayFromCollision(layout, collision, l, isUserAction)\n    } else {\n      layout = moveElementAwayFromCollision(layout, l, collision, isUserAction)\n    }\n  }\n\n  return layout\n}\n\n/**\n * This is where the magic needs to happen - given a collision, move an element away from the collision.\n * We attempt to move it up if there's room, otherwise it goes below.\n *\n * @param  {Array} layout            Full layout to modify.\n * @param  {LayoutItem} collidesWith Layout item we're colliding with.\n * @param  {LayoutItem} itemToMove   Layout item we're moving.\n * @param  {Boolean} [isUserAction]  If true, designates that the item we're moving is being dragged/resized\n *                                   by the user.\n */\nexport function moveElementAwayFromCollision(\n  layout: Layout,\n  collidesWith: LayoutItem,\n  itemToMove: LayoutItem,\n  isUserAction?: boolean\n): Layout {\n  const preventCollision = false // we're already colliding\n  // If there is enough space above the collision to put this element, move it there.\n  // We only do this on the main collision as this can get funky in cascades and cause\n  // unwanted swapping behavior.\n  if (isUserAction) {\n    // Make a mock item so we don't modify the item here, only modify in moveElement.\n    const fakeItem: LayoutItem = {\n      x: itemToMove.x,\n      y: itemToMove.y,\n      w: itemToMove.w,\n      h: itemToMove.h,\n      i: \"-1\"\n    }\n    fakeItem.y = Math.max(collidesWith.y - itemToMove.h, 0)\n    if (!getFirstCollision(layout, fakeItem)) {\n      return moveElement(layout, itemToMove, undefined, fakeItem.y, preventCollision)\n    }\n  }\n  /* \n  layout: Layout,\n  l: LayoutItem,\n  x: number,\n  y: number,\n  isUserAction: boolean,\n  preventCollision: boolean\n  */\n  // Previously this was optimized to move below the collision directly, but this can cause problems\n  // with cascading moves, as an item may actually leapflog a collision and cause a reversal in order.\n  return moveElement(layout, itemToMove, undefined, itemToMove.y + 1, preventCollision)\n}\n\n/**\n * Helper to convert a number to a percentage string.\n *\n * @param  {Number} num Any number\n * @return {String}     That number as a percentage.\n */\nexport function perc(num: number): string {\n  return num * 100 + \"%\"\n}\n\nexport interface TransformStyle {\n  transform: string\n  WebkitTransform: string\n  MozTransform: string\n  msTransform: string\n  OTransform: string\n  width: string\n  height: string\n  position: \"absolute\" | \"relative\"\n}\n\nexport function setTransform(\n  top: number,\n  left: number,\n  width: number,\n  height: number\n): TransformStyle {\n  // Replace unitless items with px\n  const translate = \"translate3d(\" + left + \"px,\" + top + \"px, 0)\"\n  return {\n    transform: translate,\n    WebkitTransform: translate,\n    MozTransform: translate,\n    msTransform: translate,\n    OTransform: translate,\n    width: width + \"px\",\n    height: height + \"px\",\n    position: \"absolute\"\n  }\n}\n/**\n * Just like the setTransform method, but instead it will return a negative value of right.\n *\n * @param top\n * @param right\n * @param width\n * @param height\n * @returns {{transform: string, WebkitTransform: string, MozTransform: string, msTransform: string, OTransform: string, width: string, height: string, position: string}}\n */\nexport function setTransformRtl(\n  top: number,\n  right: number,\n  width: number,\n  height: number\n): TransformStyle {\n  // Replace unitless items with px\n  const translate = \"translate3d(\" + right * -1 + \"px,\" + top + \"px, 0)\"\n  return {\n    transform: translate,\n    WebkitTransform: translate,\n    MozTransform: translate,\n    msTransform: translate,\n    OTransform: translate,\n    width: width + \"px\",\n    height: height + \"px\",\n    position: \"absolute\"\n  }\n}\n\nexport interface TopLeftStyle {\n  top: string\n  left: string\n  width: string\n  height: string\n  position: \"absolute\"\n}\n\nexport function setTopLeft(top: number, left: number, width: number, height: number): TopLeftStyle {\n  return {\n    top: top + \"px\",\n    left: left + \"px\",\n    width: width + \"px\",\n    height: height + \"px\",\n    position: \"absolute\"\n  }\n}\n/**\n * Just like the setTopLeft method, but instead, it will return a right property instead of left.\n *\n * @param top\n * @param right\n * @param width\n * @param height\n * @returns {{top: string, right: string, width: string, height: string, position: string}}\n */\n\nexport interface TopRightStyle {\n  top: string\n  right: string\n  width: string\n  height: string\n  position: string\n}\nexport function setTopRight(\n  top: number,\n  right: number,\n  width: number,\n  height: number\n): TopRightStyle {\n  return {\n    top: top + \"px\",\n    right: right + \"px\",\n    width: width + \"px\",\n    height: height + \"px\",\n    position: \"absolute\"\n  }\n}\n\n/**\n * Get layout items sorted from top left to right and down.\n *\n * @return {Array} Array of layout objects.\n * @return {Array}        Layout, sorted static items first.\n */\nexport function sortLayoutItemsByRowCol(layout: Layout): Layout {\n  const a: Array<LayoutItem> = []\n  return a.concat(layout).sort(function (a, b) {\n    if (a.y === b.y && a.x === b.x) {\n      return 0\n    }\n\n    if (a.y > b.y || (a.y === b.y && a.x > b.x)) {\n      return 1\n    }\n\n    return -1\n  })\n}\n\n/**\n * Generate a layout using the initialLayout and children as a template.\n * Missing entries will be added, extraneous ones will be truncated.\n *\n * @param  {Array}  initialLayout Layout passed in through props.\n * @param  {String} breakpoint    Current responsive breakpoint.\n * @param  {Boolean} verticalCompact Whether or not to compact the layout vertically.\n * @return {Array}                Working layout.\n */\n/*\nexport function synchronizeLayoutWithChildren(initialLayout: Layout, children: Array<React.Element>|React.Element,\n                                              cols: number, verticalCompact: boolean): Layout {\n  // ensure 'children' is always an array\n  if (!Array.isArray(children)) {\n    children = [children];\n  }\n  initialLayout = initialLayout || [];\n\n  // Generate one layout item per child.\n  let layout: Layout = [];\n  for (let i = 0, len = children.length; i < len; i++) {\n    let newItem;\n    const child = children[i];\n\n    // Don't overwrite if it already exists.\n    const exists = getLayoutItem(initialLayout, child.key || \"1\" /!* FIXME satisfies Flow *!/);\n    if (exists) {\n      newItem = exists;\n    } else {\n      const g = child.props._grid;\n\n      // Hey, this item has a _grid property, use it.\n      if (g) {\n        if (!isProduction) {\n          validateLayout([g], 'ReactGridLayout.children');\n        }\n        // Validated; add it to the layout. Bottom 'y' possible is the bottom of the layout.\n        // This allows you to do nice stuff like specify {y: Infinity}\n        if (verticalCompact) {\n          newItem = cloneLayoutItem({...g, y: Math.min(bottom(layout), g.y), i: child.key});\n        } else {\n          newItem = cloneLayoutItem({...g, y: g.y, i: child.key});\n        }\n      }\n      // Nothing provided: ensure this is added to the bottom\n      else {\n        newItem = cloneLayoutItem({w: 1, h: 1, x: 0, y: bottom(layout), i: child.key || \"1\"});\n      }\n    }\n    layout[i] = newItem;\n  }\n\n  // Correct the layout.\n  layout = correctBounds(layout, {cols: cols});\n  layout = compact(layout, verticalCompact);\n\n  return layout;\n}\n*/\n\n/**\n * Validate a layout. Throws errors.\n *\n * @param  {Array}  layout        Array of layout items.\n * @param  {String} [contextName] Context name for errors.\n * @throw  {Error}                Validation error.\n */\nexport function validateLayout(layout: Layout, contextName?: string): void {\n  contextName = contextName || \"Layout\"\n  const subProps = [\"x\", \"y\", \"w\", \"h\"]\n  const keyArr = []\n  if (!Array.isArray(layout)) throw new Error(contextName + \" must be an array!\")\n  for (let i = 0, len = layout.length; i < len; i++) {\n    const item = layout[i]\n    for (let j = 0; j < subProps.length; j++) {\n      if (typeof item[subProps[j]] !== \"number\") {\n        throw new Error(\n          \"VueGridLayout: \" + contextName + \"[\" + i + \"].\" + subProps[j] + \" must be a number!\"\n        )\n      }\n    }\n\n    if (item.i === undefined || item.i === null) {\n      throw new Error(\"VueGridLayout: \" + contextName + \"[\" + i + \"].i cannot be null!\")\n    }\n\n    if (typeof item.i !== \"number\" && typeof item.i !== \"string\") {\n      throw new Error(\"VueGridLayout: \" + contextName + \"[\" + i + \"].i must be a string or number!\")\n    }\n\n    if (keyArr.indexOf(item.i) >= 0) {\n      throw new Error(\"VueGridLayout: \" + contextName + \"[\" + i + \"].i must be unique!\")\n    }\n    keyArr.push(item.i)\n\n    if (item.static !== undefined && typeof item.static !== \"boolean\") {\n      throw new Error(\"VueGridLayout: \" + contextName + \"[\" + i + \"].static must be a boolean!\")\n    }\n  }\n}\n\n// Flow can't really figure this out, so we just use Object\nexport function autoBindHandlers(el: HTMLElement, fns: Array<string>): void {\n  fns.forEach(key => (el[key] = el[key].bind(el)))\n}\n\n/**\n * Convert a JS object to CSS string. Similar to React's output of CSS.\n * @param obj\n * @returns {string}\n */\ninterface JSStyle {\n  [key: string]: string\n}\nexport function createMarkup(obj: JSStyle): string {\n  const keys = Object.keys(obj)\n  if (!keys.length) return \"\"\n  let i\n  const len = keys.length\n  let result = \"\"\n\n  for (i = 0; i < len; i++) {\n    const key = keys[i]\n    const val = obj[key]\n    result += hyphenate(key) + \":\" + addPx(key, val) + \";\"\n  }\n\n  return result\n}\n\n/* The following list is defined in React's core */\nexport const IS_UNITLESS = {\n  animationIterationCount: true,\n  boxFlex: true,\n  boxFlexGroup: true,\n  boxOrdinalGroup: true,\n  columnCount: true,\n  flex: true,\n  flexGrow: true,\n  flexPositive: true,\n  flexShrink: true,\n  flexNegative: true,\n  flexOrder: true,\n  gridRow: true,\n  gridColumn: true,\n  fontWeight: true,\n  lineClamp: true,\n  lineHeight: true,\n  opacity: true,\n  order: true,\n  orphans: true,\n  tabSize: true,\n  widows: true,\n  zIndex: true,\n  zoom: true,\n\n  // SVG-related properties\n  fillOpacity: true,\n  stopOpacity: true,\n  strokeDashoffset: true,\n  strokeOpacity: true,\n  strokeWidth: true\n}\n\n/**\n * Will add px to the end of style values which are Numbers.\n * @param name\n * @param value\n * @returns {*}\n */\nexport function addPx(name: string, value: number | string) {\n  if (typeof value === \"number\" && !IS_UNITLESS[name]) {\n    return value + \"px\"\n  } else {\n    return value\n  }\n}\n\n/**\n * Hyphenate a camelCase string.\n *\n * @param {String} str\n * @return {String}\n */\n\nexport const hyphenateRE = /([a-z\\d])([A-Z])/g\n\nexport function hyphenate(str: string) {\n  return str.replace(hyphenateRE, \"$1-$2\").toLowerCase()\n}\n\nexport function findItemInArray(array: Array<any>, property: string, value: any) {\n  for (let i = 0; i < array.length; i++) if (array[i][property] == value) return true\n\n  return false\n}\n\nexport function findAndRemove(array: Array<any>, property: string, value: any) {\n  array.forEach(function (result, index) {\n    if (result[property] === value) {\n      //Remove from array\n      array.splice(index, 1)\n    }\n  })\n}\n"],
  "mappings": "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",
  "names": ["collides", "a"]
}
